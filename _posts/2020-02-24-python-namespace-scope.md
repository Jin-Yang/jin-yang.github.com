---
title: Python 命名空间和作用域介绍
layout: post
comments: true
language: chinese
tag: [Python, Program]
keywords: 命名空间, 作用域
description: 在 Python 中，一切皆对象，命名空间实际是一个名称到对象的映射，另外，虽然 Python 是一种动态类型的语言，但是静态作用域语言，变量使用与作用域相关。这里详细介绍命名空间和作用域的关系。
---

在 Python 中，一切皆对象，命名空间实际是一个名称到对象的映射，另外，虽然 Python 是一种动态类型的语言，但是静态作用域语言，变量使用与作用域相关。

这里详细介绍命名空间和作用域的关系。

<!-- more -->

## 简介

在 Python 中，一切皆对象，而命名空间实际是一个名称到对象 (Objects) 的映射关系 (A namespace is a mapping from names to objects)，多数的命名空间是用字典实现的，键就是变量名，值是那些变量的对象，也即变量的值。

另外，Python 是一种动态类型的语言，在编译阶段类型并没有与变量绑定，严格来说，变量名是与具体的变量绑定的。尽管是一种动态语言，但 Python 是静态作用域语言，也就是说，变量的作用域是由它在源代码中的位置决定的。

在使用一个变量之前不必先声明它，但是在真正使用它之前，必须已经绑定到某个对象；而名字绑定将在当前作用域中引入新的变量，同时屏蔽外层作用域中的同名变量，不论这个名字绑定发生在当前作用域中的哪个位置。

## 命名空间

命名空间包含了当前定义的符号名称及其所引用对象的集合，可以将命名空间看作字典，其中键是对象名称，而值就是对象本身。

在 Python 程序中的任何一个地方，都存在如下几个可用的命名空间：

* 局部命名空间，每个函数所有，包括了函数内定义的变量、参数；当函数被调用时创建一个局部命名空间，当函数返回结果或抛出异常时被删除；可以通过 `locals()` 函数访问。
* 全局命名空间，模块中定义，包括了模块内定义的函数、类、其它导入的模块、模块级的变量和常量，在模块导入时创建，会一直保存到解释器退出；可以通过 `globals()` 函数访问。
* 内置命名空间，在 Python 解析器启动时创建，会一直保留，任何模块均可访问，包含了一些常见的函数 (例如 `sin()`、`map()`、`open()` 等)，异常 (例如 `BaseException`、`IOError` 等)；在 Python3 中可以通过 `dir(builtins)` 命令查看。

通过命名空间保存了变量名和值之间的映射关系，而变量的查找则与作用域相关。

## 作用域

变量的查询顺序为 LEGB ，也就是局部作用域 (Local)，嵌套作用域 (Enclosing)，全局作用域 (Global)，内置作用域 (Build-in)，在查询的过程中如果找到则停止搜索，否则抛出 `NameError: name 'xxx' is not defined.` 错误。

另外，在早些时候，Python 的是按照 LGB 查找的，后来由于闭包和嵌套函数的出现，于是又增加了嵌套作用域。

### 示例

内置作用域一般不建议修改 (实际可以通过 `builtins` 模块修改)，可以通过如下的示例验证 LEG 的查找顺序。

``` python
float = "global scope"                 # <3>
def foobar():
	float = "enclosing scope"      # <2>
	def bar():
		float = "local scope"  # <1>
		print(float)
	bar()
foobar()
```

直接运行会输出 `local scope` ，当注释掉 `<1>` 行后，会显示 `enclosing scope` ，再注释掉 `<2>` 之后，会显示 `global scope` ，如果再注释掉 `<3>` 行，那么就会输出内建的 `float` 对象，也就是 `<class 'float'>` 。










<!--

是新类的特性


描述符实际上就是可以重用的属性，

通常Python默认对属性的操作是从对象的字典(\_\_dict\_\_)中获取get，设置set或者删除delete。如，对于实例a，a.x的查找顺序为a.\_\_dict\_\_['x']，接着是type(a).\_\_dict\_\_['x']，然后是父类中查找。而如果属性x是一个描述符，那么访问a.x时不再从字典\_\_dict\_\_中读取，而是调用描述符的\_\_get\_\_()方法，对于设置和删除也是同样的原理。因此个人猜测没有验证，实际上是先查找属性是否有\_\_get\_\_()等方法，如果没有则在\_\_dict\_\_中查找。

例如，我们要求薪水的值应该大于0，可以在\_\_init\_\_中进行检测，但是可以在外部调用修改为负值，详见property.py中的PayBug类。为了对该值进行检测，可以通过@property修饰符进行修改，内容详见property.py中的Pay类。

但是这样修改仍然存在这麻烦，如果一个类里含有多个相似的属性（要求不能为负值），那么需要重复添加多个类似的函数。

我们可以通过类的__init__函数对变量进行初始化（初始化的变量名与类的变量名相同），当通过instance.__dict__查看时，不存在对应的变量；只能通过Class.__dict__来查看。而对于正常的类，这样操作实际是保存了一组类变量和一组实例变量。也就是说我们可以在__init__中对属性进行赋值，但是操作还是在描述符中进行。

在参考文献1中，在描述符类中采用了WeakKeyDictionary来解决不同实例之间的冲突，但是测试发现，现在的Python中不存在类似的问题。


http://nbviewer.ipython.org/urls/gist.github.com/ChrisBeaumont/5758381/raw/descriptor_writeup.ipynb
http://www.geekfan.net/7862/
-->

