---
title: 背包问题
layout: post
comments: true
usemath: true
language: chinese
category: [linux,misc]
keywords:
description:
---

分治算法和动态规划都是将大问题拆解为小问题，前者针对同一个子问题可能会计算多次，而后者则会将中间结果记录下来，通过空间节约时间，而 `0-1` 背包问题是最基本的动态规划问题。

<!-- more -->

## 01 背包问题

![knapsack logo]({{ site.url }}/images/algorithm/knapsack.svg "knapsack svg"){: .pull-center width="50%" }

给定 `N` 种物品和一个容量为 `C` 的背包，其中物品 `i` 的重量是 `w[i]`，其对应的价值为 `v[i]` ；那么，如何选择装入背包的物品，使得装入背包中物品的总价值最大？

对于一个物品来说，只能是取或者不取，且只能取一次，这也就是 0-1 的含义。

### 贪婪算法

以单位质量的价值作为衡量标准进行选取，很容易找出反例。

{% highlight text %}
(20, 20) (30, 30) (40, 44) (50, 55) (60, 60)
{% endhighlight %}

其中容量为 100 ，如果按照上述的贪婪规则获取，那么应该是 40 50 ，总价值为 99；而实际最优为 20 30 50 ，价值为 105 。

<!--
https://blog.csdn.net/Jhno99/article/details/78555982
-->

### 问题求解

我们将物品标记为 $(w[i], v[i])$ ，同时将子问题 $P(i, W)$ 定义为，在 $i$ 个物品中挑选总重量不超过 $W$ 的物品 (每种物品最多挑选一个)，使得总价值最大，此时的最优解为 $m(i, W)$ 。

现在考虑第 $i$ 个物品，那么无外乎两种可能，选或者不选。

* 选中，背包容量变小，对于 $i - 1$ 个物品来说，问题变为 $P(i - 1, W - w[i])$；
* 不选，背包容量不变，对于 $i - 1$ 个物品来说，问题变为 $P(i - 1, W)$。

而最优方案就是比较这两种方案，那个会更好，也即是选取两者的最大值。

$$m(i, W) = max\{m(i - 1, W - w[i]) + v[i], m(i - 1, W)\}$$

可以得到最终的公式为。

$$
m(i, W)=
\begin{cases}
0 & i = 0 \\
0 & W = 0 \\
m(i-1, W) & w_i > W \\
max\{m(i - 1, W - w_i) + v_i, m(i - 1, W)\} & otherwise
\end{cases}
$$

上述等式的第三行意味着，如果第 $i$ 个物品的重量大于背包的容量，那么这个物品是无法装入背包的，那么仍然保持前 $i - 1$ 的价值。

对于上述的公式，会申请 $(n + 1) \times (C + 1)$ 大小的数组，其中第 0 行以及第 0 列均会初始化为 0 ；那么，算法可以表示为：

{% highlight text %}
for i=0 to N
    m[i, 0] = 0
for j=1 to C
    m[0, j] = 0
for i = 1 to N
    for j = 1 to C
        if w[i] > j
            m[i][j] = m[i-1][j]
        else
            m[i][j] = max(m[i-1][j-w[i]] + v[i], m[i-1][j])
return m[N][C]
{% endhighlight %}

最后的值就是背包可容纳的最大价值。

### 示例

假设背包的容量为 11 ，当前总共有五个物品，其对应的质量以及价值分别为 `(1, 1)` `(2, 6)` `(5, 18)` `(6, 22)` `(7, 28)` ，可以根据递推方式得到如下的表格。

|     | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  |
| --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: | --: |
| 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| 1   | 0   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
| 2   | 0   | 1   | 6   | 7   | 7   | 7   | 7   | 7   | 7   | 7   | 7   | 7   |
| 3   | 0   | 1   | 6   | 7   | 7   | 18  | 19  | 24  | 25  | 25  | 25  | 25  |
| 4   | 0   | 1   | 6   | 7   | 7   | 18  | 22  | 24  | 28  | 29  | 29  | 40  |
| 5   | 0   | 1   | 6   | 7   | 7   | 18  | 22  | 24  | 28  | 29  | 29  | 40  |

也就是最大的值是 40 ，接着需要判断具体选取了那些物品。

从最后一列开始，也就是当容量最大时最后选取的是哪一个，是使得容量增加到最大的那个值，也就是第 4 个；去除掉第四个的容量 6 ，应该查找容量为 5 时选取的物品，同理，应该是第 3 个。

所以，选择的是 3 和 4 。

### 代码实现

实现时通过一个二维数组计算，行 `i` 表示重量，列 `j` 表示容量，每个元素的值表示 `m[i][j]` 容量不超过 `j` 时的总价值最大值。

### 优化

以上方法的时间和空间复杂度均为 `O(NC)` ，时间复杂度已经不太好优化，但是空间复杂度可以优化到 `O(C)` ，但是未确定其原理，以及如何确定所选择的物品。



<!--
https://oi.men.ci/noip2006-budget/
树形 DP
https://zhuanlan.zhihu.com/p/30959069


## 完全背包问题

仍然是上述的问题，但是不在限制某个物品添加的次数，可以是无限次。

Complete

给定 `n` 种物品和一个容量为 `C` 的背包，物品 `i` 的重量是 `w[i]`，其价值为 `v[i]` ；那么，如何选择装入背包的物品，使得装入背包中物品的总价值最大？

### 问题求解

将子问题 $P(i, W)$ 定义为，在 $i$ 个物品中挑选总重量不超过 $W$ 的物品 (不再限制每种物品挑选个数)，使得总价值最大，此时的最优值为 $m(i, W)$ 。

同样，对于第 $i$ 个物品来说，无外乎两种可能，选 $k$ 件或者不选。

* 选中，背包容量变小，对于 $i - 1$ 个物品来说，问题变为 $P(i - 1, W - k * w[i])$；
* 不选，背包容量不变，对于 $i - 1$ 个物品来说，问题变为 $P(i - 1, W)$。

而最优方案就是比较这两种方案，那个会更好，也即是选取两者的最大值。

$$m(i, W) = max{m(i - 1, W), m(i - 1, W - k * w[i]) + k * v[i]}$$

可以得到最终的公式为。

## 多重背包问题

对于某个物品的个数是有限制的，

Multiple

什么是P问题、NP问题和NPC问题
http://www.matrix67.com/blog/archives/105

### 时间复杂度

时间复杂度并非衡量一个程序解决某个问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长有多快。

* `O(1)` 不管数据量有多大，程序处理所消耗的时间始终固定，例如 HashMap；
* `O(n)` 消耗时间随着数据规模增加，例如 List ；
* `O(n^2)` 当数据扩大 2 倍时，时间会变慢 4 倍，例如冒泡、插入排序；
* `O(a^n)` 一般有些暴力穷举算法，消耗时间会成几何阶数上涨，有些也可能会是 `O(n!)` 阶乘级复杂度。

注意，不存在 `O(2*n^2)` 复杂度，前面的系数，不会影响到整个程序的时间增长；而 `O(n^3+n^2)` 与 `O(n^3)` 等价；而且 `O(n^100)` 小于 `O(1.01^n)` 的复杂度。

这里面基本可以分成两类：A) 类似 `O(1)` `O(log(n))` `O(n^a)` 等，称为多项式级的复杂度，因为它的规模 `n` 出现在底数的位置；B)  像 `O(a^n)` `O(n!)` 等，是非多项式级的，其复杂度对于计算机往往不能承受。

在解决一个问题时，选择算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。

所谓的 P (Polynomial) 类问题是指，一个问题可以找到一个能在多项式的时间里解决它的算法。大部分的比赛问题，基本都是 P 类问题。

注意，NP 问题并非指不是非 P 类问题，而是指可以在多项式的时间里验证一个解的问题。

假设猜测了某个问题的一个解，但是无法在多项式的时间内进行验证，所以这个解实际也没有意义。也就是说，我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。

而所谓的 "NP问题"，实际上是在探讨 NP 问题与 P 类问题的关系。

显然，所有的 P 类问题都是 NP 问题，也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解。关键是，人们想知道，是否所有的 NP 问题都是 P 类问题。

会按照分类进行解析
https://www.zybuluo.com/Yano/note/255436



Knuth-Morris-Pratt, KMP 是常用的字符串查找算法之一，以三个发明者命名。

而所谓的字符串查找，举例来说，有一个字符串 "BBC ABCDAB ABCDABCDABDE"，如果要知道，该字符串中是否包含字符串 "ABCDABD" ？

AG一个快速的代码搜索工具
https://github.com/ggreer/the_silver_searcher
http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/

valgrind --track-origins=yes --leak-check=full
cgroup内存限制
https://www.cnblogs.com/keithtt/p/7000095.html
https://man.openbsd.org/ohash_init.3

http://zlib.net/zlib_how.html
https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html

https://zh4ui.net/post/2018-08-03-zlib-intro/





panic_on_oom
hung_task_panic
oom_adj

https://segmentfault.com/a/1190000012948613

uthash

压缩库
https://github.com/kobolabs/liblzma
http://zlib.net/zlib_how.html

FailPoint实现
https://github.com/freebsd/freebsd/blob/master/sys/sys/fail.h
https://github.com/freebsd/freebsd/blob/master/sys/kern/kern_fail.c
-->


{% highlight text %}
{% endhighlight %}
