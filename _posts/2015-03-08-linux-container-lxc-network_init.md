---
Date: October 19, 2013
title: LXC 网络设置相关
layout: post
comments: true
language: chinese
category: [linux]
---

LXC 本身就是基于内核的 Namespace、Cgroup 的隔离技术，对于网络同样使用了网络上常用的虚拟技术，包括 veth、vlan、macvlan 等等。

在此仅介绍一下 LXC 中与网络相关的使用方法。

<!-- more -->


# 网络设置

创建完容器之后，默认会将容器的配置文件保存在 /var/lib/lxc/centos/config，可以参考网络相关的配置，默认使用 veth，此时可以自动联网。

网络相关的设置可以查看源码中的 lxc-net 脚本，通过如下命令查看容器中的网络配置。

{% highlight text %}
----- 容器中的网络设置
[root@centos ~]# ip address show eth0
23: eth0@if24: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether fe:cf:69:db:e7:3c brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 192.168.122.118/24 brd 192.168.122.255 scope global dynamic eth0
       valid_lft 3542sec preferred_lft 3542sec
    inet6 fe80::fccf:69ff:fedb:e73c/64 scope link
       valid_lft forever preferred_lft forever

----- 容器中的路由设置
[root@centos ~]# ip route show
default via 192.168.122.1 dev eth0
169.254.0.0/16 dev eth0  scope link  metric 1023
192.168.122.0/24 dev eth0  proto kernel  scope link  src 192.168.122.118

----- DNS解析地址
[root@centos ~]# cat /etc/resolv.conf
; generated by /usr/sbin/dhclient-script
nameserver 192.168.122.1

----- 测试下能否ping通外部网络
[root@centos ~]# ping www.hao123.com  -c 3
PING hao123.n.shifen.com (180.149.132.3) 56(84) bytes of data.
64 bytes from 180.149.132.3: icmp_seq=1 ttl=53 time=40.3 ms
64 bytes from 180.149.132.3: icmp_seq=2 ttl=53 time=34.1 ms
64 bytes from 180.149.132.3: icmp_seq=3 ttl=53 time=32.6 ms

--- hao123.n.shifen.com ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2002ms
rtt min/avg/max/mdev = 32.694/35.728/40.303/3.291 ms
{% endhighlight %}

其中与网络相关的默认的配置如下。

{% highlight text %}
lxc.network.type = veth
lxc.network.flags = up
lxc.network.link = virbr0
lxc.network.hwaddr = fe:cf:69:db:e7:3c
{% endhighlight %}

也就是说，如上的配置文件采用的是 veth (Virtual Ethernet Interface) 模式。该模式会创建一对网络设备，其中一端在容器中，另一端会添加到 bridge (通过 lxc.network.link 指定)。

{% highlight text %}
----- 查看网桥的设置
# brctl show virbr0
bridge name     bridge id               STP enabled     interfaces
virbr0          8000.52540054901b       yes             vethXTBOA0

----- 查看主机是否打开了路由转发
# cat /proc/sys/net/ipv4/ip_forward
1

----- 查看iptables的SNAT设置
# iptables -nL POSTROUTING -t nat --line-number
Chain POSTROUTING (policy ACCEPT)
num  target     prot opt source               destination
1    MASQUERADE  tcp  --  192.168.122.0/24    !192.168.122.0/24     masq ports: 1024-65535
2    MASQUERADE  udp  --  192.168.122.0/24    !192.168.122.0/24     masq ports: 1024-65535
3    MASQUERADE  all  --  192.168.122.0/24    !192.168.122.0/24
{% endhighlight %}

veth 实际上就是模拟了一对以太网络设备，类似于一个管道，从设备的一端传入，然后从另一端传出；两个设备处在同一个广播域中，而非基于 IP 的端对端的传输。

{% highlight text %}
实际上网络设备的大致创建过程如下。

创建一对 VETH 网络设备。后续的网络设置将会通过 DNSmasq 进行，该程序实际会监听网桥 (在此为 virbr0) 上的端口，而且网桥的 IP 将作为容器的默认网关。
<pre style="font-size:0.8em; face:arial;">
# netstat -atunp | grep dnsmasq                 # 在主机中查看DNSmasq，包括其监听的端口等
# ip addr show virbr0                           # 查看网桥对应的IP

# grep nameserver /etc/resolv.conf              # 容器中的DNS服务器实际上是网桥上的IP
# route -nee                                    # 默认路由同样是
</pre></li><br><li>

主机一侧的 VETH 设备，实际上会链接网桥，也就是 virbr0 。</li><br><li>

另一侧的 VETH 设备会移动到容器中，并且重命名为 eth0，并在容器中进行配置。</li><br><li>

当 init 进程启动之后，会设置相应的网络设备，并可以使用网络了。
</li></ol>
通过上述的步骤之后，通过一对网络设备可以在主机和容器之间进行通讯。<br><br>

在主机中会有一个 vethXXXXX 的设备，而另一端在容器中；而主机端的设备会添加到配置中的网桥中。
# brctl show                 # 查看网桥的配置

在如下的步骤中，我们尝试模拟 lxc 配置网络设备。当新建 NET-NS 之后，会默认创建一个 lo 设备；然后可以进入这个命名空间，创建一对设备，不过此时还没有设置 IP 。

# mkdir -p /var/run/netns
# ip netns add mynamespace
# ip netns list
# ls -l /var/run/netns

# ip netns exec mynamespace bash                       # 进入NET-NS
# ip link add vethMYTEST type veth peer name eth0      # NS中新建一对设备
# ip link list                                         # NS中的网络设备，应该有3个

# ip address add 192.168.122.63/24 dev eth0            # 设置IP，注意网段
# ip link set eth0 up                                  # 启动设备
# ip address list                                      # 查看

# ip link set vethMYTEST netns 1                       # 将另一个设备添加到PID=1的命名空间
# ip link set vethMYTEST up                            # 返回主机执行
# ip link list vethMYTEST                              # 主机中查看
# ping -c 2 192.168.122.63                             # 此时网络是不通的

# brctl addif virbr0 vethMYTEST                        # 将设备添加到网桥中
# ping -c 2 192.168.122.63                             # 好了现在网络是通的
{% endhighlight %}

可以从源码的 config_network_type() 函数中看到，LXC 中可供选择的网络类型包括了 veth、macvlan、vlan、phys、empty、none 六种，不太清楚 empty 和 none 什么区别。

# empty

配置文件中相关的网络配置如下。

{% highlight text %}
# grep network /var/lib/lxc/centos/config
lxc.network.type = empty
lxc.network.hwaddr = fe:cf:69:db:e7:3c
lxc.network.flags = up
{% endhighlight %}

此时通过 lxc-info 查看时会发现，实际上是没有联网的，不过这正好符合预期，empty 网络定义如下：

{% highlight text %}
empty network type creates only the loopback interface
{% endhighlight %}

此时会创建一个 Namespace，所以在 host 上是看不到 lo 设备的。

{% highlight text %}
----- 查看进程ID
# ps aux | grep 'lxc-start -n centos'

----- 通过procfs查看对应的namespace
# ls -l /proc/17923/ns/
{% endhighlight %}



# veth

如下是对于 veth 的描述。

{% highlight text %}
a peer network device is created with one side assigned to the container and
the other side is attached to a bridge specified by the lxc.network.link.
{% endhighlight %}

与网络相关的配置如下。

{% highlight text %}
# grep network /var/lib/lxc/veth01/config
lxc.network.type = veth
lxc.network.flags = up
lxc.network.link = virbr0
lxc.network.hwaddr = fe:cf:69:db:e7:3c
{% endhighlight %}





# phys

{% highlight text %}
an already existing interface specified by the lxc.network.link is assigned to the container
{% endhighlight %}

















# 参考

[Exploring LXC Networking](http://containerops.org/2013/11/19/lxc-networking/)，介绍 LXC 网络不错的文章，可以参考 [本地文档](/reference/linux/container/Exploring LXC Networking.mht) 。



{% highlight text %}
{% endhighlight %}
