<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="baidu-site-verification" content="B786jeR0MV" />
  <meta name="msvalidate.01" content="29F791E7F785800340E37AD7C714D2A7" />
  <meta name="google-site-verification" content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0" />
  <title>MySQL 代码导读|JinYang's Blog</title>
  <meta name="keywords" content="mysql,database,数据库,源码,解析">
  <meta name="description" content="在 MySQL 的官网上，MySQL 号称是 The World's Most Popular Open Source Database ，既然是开源的，据说又这么牛掰，那不看看源码真有点对不起 MySQL 了。 不禁想起了 PostgreSQL 号称是 The World's Most Advanced Open Source Database ^_^'' 废话少说，本文简单介绍一下 MySQL 的执行流程。">

  <script src="https://cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>
  <script type="text/javascript">
  !window.jQuery && document.write('<script src="/static/js/jquery.min.js"><\/script>');
  </script>
  <script src="https://cdn.bootcss.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
  <script type="text/javascript">
  !$('body').popover && document.write('<script src="/static/js/bootstrap.min.js"><\/script>');
  </script>
  <script type="text/javascript" src="/static/js/main.js"></script>
  <!-- <link rel="stylesheet prefetch" href="http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css"> -->
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/bootstrap.min.css">
  <!-- <link href="http://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/font-awesome.min.css">
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/pygments.css">
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/screen.css">
  <style type="text/css">
  
    .post-container > p {text-indent: 2em;}
  
  </style>
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-124556620-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-124556620-1');
</script>

</head>

<body>
<nav class="navbar navbar-default navbar-inverse navbar-fixed-top navbar-wrapper">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span>
      </button><a class="navbar-brand" href="/">Jin-Yang</a>
    </div>
    <div id="navbar" class="collapse navbar-collapse">
      <ul class="nav navbar-nav">
        <li  ><a href="/"> Home </a></li>
        <li  ><a href="/archives.html"> Archive </a></li>
        <li  ><a href="/categories.html"> Categories </a></li>
        <li  ><a href="/projects.html"> Projects </a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"> Others <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li class="dropdown-header">常用网站</li>
            <li role="separator" class="divider"></li>
            <li><a href="https://www.rtems.org/">www.rtems.org</a></li>
            <li><a href="http://www.gnu.org/">www.gnu.org</a></li>
            <li><a href="https://www.kernel.org/">www.kernel.org</a></li>
            <li><a href="https://www.arduino.cc/">www.arduino.cc</a></li>
          </ul>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li  ><a href="/about.html"> About </a></li>
      </ul>
    </div><!--/.nav-collapse -->
  </div>
</nav>

<div id="myCarousel" class="carousel slide" data-ride="carousel">
  <!-- Indicators -->
  <ol class="carousel-indicators">
    <li data-target="#myCarousel" data-slide-to="0" class="active"></li>
    <li data-target="#myCarousel" data-slide-to="1"></li>
    <li data-target="#myCarousel" data-slide-to="2"></li>
    <li data-target="#myCarousel" data-slide-to="3"></li>
    <li data-target="#myCarousel" data-slide-to="4"></li>
  </ol>
  <div class="carousel-inner" role="listbox">
    <div class="item active">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>KISS</h1>
          <h2>Keep It Simple and Stupid.</h2>
          <!--<a class="btn btn-lg btn-primary" href="#" role="button">Sign up today</a>-->
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Seize The Day</h1><h1>And Get Busy Living</h1>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Stay hungry</h1><h1>Stay foolish</h1>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
	  <h2>Ever tried, ever failed</h2><h2>No matter, try again</h2><h2>Fail again, fail better</h2>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Nothing is true</h1><h1>Every is permitted</h1>
        </div>
      </div>
    </div>
  </div>
  <a class="left carousel-control" href="#myCarousel" role="button" data-slide="prev">
    <span class="glyphicon glyphicon-chevron-left"></span>
    <span class="sr-only">Previous</span>
  </a>
  <a class="right carousel-control" href="#myCarousel" role="button" data-slide="next">
    <span class="glyphicon glyphicon-chevron-right"></span>
    <span class="sr-only">Next</span>
  </a>
</div><!-- /.carousel -->

<div class="container">
  <div class="row">
    <div class="col-lg-9 blog-main" style="min-width: 500px">
    
<div class="post-container">
  <div class="blog-header">
    <h1>MySQL 代码导读</h1>
    <div class="post-description">
      <i class="fa fa-calendar"></i> 2015-05-02 Saturday &nbsp; &nbsp;
      <i class="fa fa-tags"></i>  mysql ,  database  
      
    </div>
  </div>
  <hr>
  <p>在 MySQL 的官网上，MySQL 号称是 The World’s Most Popular Open Source Database ，既然是开源的，据说又这么牛掰，那不看看源码真有点对不起 MySQL 了。</p>

<p>不禁想起了 PostgreSQL 号称是 The World’s Most Advanced Open Source Database ^_^’’</p>

<p>废话少说，本文简单介绍一下 MySQL 的执行流程。</p>

<!-- more -->

<p><img src="/images/databases/mysql/skeleton-logo.jpg" alt="mysql skeleton" title="mysql skeleton" class="pull-center" width="50%" /></p>

<h2 id="简介">简介</h2>

<p>MySQL 是基于线程的，在进程启动之后可以通过如下方式查看 MySQL 启动的进程信息。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ cat /proc/`pidof mysqld`/status | grep ^Threads           ← 查看线程数
$ cat /proc/`pidof mysqld`/sched                            ← 第一行即为线程数
$ ls /proc/`pidof mysqld`/task                              ← 查看对应线程信息

$ pstree                                                    ← 查看启动后进程之间的关系
$ pstree -p `pidof mysqld`                                  ← 查看进程对应的线程

$ ps -Lf `pidof mysqld`                                     ← 同样查看线程
$ ps -eo ruser,pid,ppid,lwp,psr,args -L | grep mysql        ← psr为线程运行的cpu-id

$ pstack `pidof mysqld` | less                              ← 打印对应进程的调用堆栈</code></pre></figure>

<h2 id="源码导读">源码导读</h2>

<p>简单介绍下 MySQL 源码实现。</p>

<h3 id="简介-1">简介</h3>

<p>在 MySQL 源码中，有很多类似 HAVE_XXX 的宏定义，如果是 RPM 安装包，也可以查看 mysql-xxx.devel 包中包含的 my_config.h 文件定义，也就是编译相关二进制时的宏定义。</p>

<p>实际上，在通过 CMake 编译源码时，会以 config.h.cmake 为模板扫描系统的一些配置，并生成 config.h 文件，然后 CMake 脚本会把 config.h 拷贝一份保存为 my_config.h 文件。</p>

<p>下面以 HAVE_SYS_EPOLL_H 宏定义为例，看下是如何实现的；在 configure.cmake 文件中，有如下的定义。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">CHECK_INCLUDE_FILES(sys/epoll.h HAVE_SYS_EPOLL_H)</code></pre></figure>

<p>上述文件中包含了 <code>INCLUDE(CheckSymbolExists)</code>，而 CheckSymbolExists 是 CMake 的公共模块，一般在 cmake 的安装目录下，通常位于 /usr/share/cmake-X.X/Modules 目录下。</p>

<p>继续研究上述的文件，在源代码中有 <code>MACRO(CHECK_SYMBOL_EXISTS SYMBOL FILES VARIABLE)</code> 定义；这个宏的作用就是，查找相关文件 (FILES) 里面是否包含相关符号 (SYMBOL)；如果存在则设置变量为 1，MESSAGE 宏会在屏幕上做相关打印。</p>

<p>部分宏也可以在编译时，通过类似 <code>-DEMBEDDED_LIBRARY</code> 定义。</p>

<h3 id="ut_ad宏定义">ut_ad()宏定义</h3>

<p>在代码中，会有 <code>ut_ad(dict_index_is_clust(index));</code> 类似的代码，下面看看这段代码的作用。</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &quot;os0thread.h&quot;</span>
<span class="cp">#define ut_a(EXPR) do {                     \</span>
<span class="cp">    if (UNIV_UNLIKELY(!(ulint) (EXPR))) {           \</span>
<span class="cp">        ut_dbg_assertion_failed(#EXPR,          \</span>
<span class="cp">                __FILE__, (ulint) __LINE__);    \</span>
<span class="cp">    }                           \</span>
<span class="cp">} while (0)</span>

<span class="cp">#define ut_error                        \</span>
<span class="cp">    ut_dbg_assertion_failed(0, __FILE__, (ulint) __LINE__)</span>

<span class="cp">#ifdef UNIV_DEBUG</span>
<span class="cp">#define ut_ad(EXPR) ut_a(EXPR)</span>
<span class="cp">#define ut_d(EXPR)  EXPR</span>
<span class="cp">#else</span>
<span class="cp">#define ut_ad(EXPR)</span>
<span class="cp">#define ut_d(EXPR)</span>
<span class="cp">#endif</span></code></pre></figure>

<p>也就是只有在 debug 模式下，会执行上述的代码。</p>

<p><br /></p>

<p>我们从 MySQL 启动开始，看一下 MySQL 业务流程，详细的执行流程如下。</p>

<h3 id="系统启动">系统启动</h3>

<p>首先是入口函数，也就是 C/C++ 的通用入口 main()，该函数在 sql/main.cc 文件中，而实际上其最终调用的是 mysqld_main()@sql/mysqld.cc，也就是 MySQL 的真正入口函数。其详细内容如下：</p>

<!--
 | |-init_glob_errs()                   ← 设置初始化错误提示信息，现在是静态设置，因此为空
 | |-my_mutex_init()                    ← 互斥量的初始化，用来初始化互斥量的属性，修改线程互斥量的默认属性
 -->

<figure class="highlight"><pre><code class="language-text" data-lang="text">mysqld_main()
 |-my_init()                            ← 做一些基本的初始化工作
 | |-getenv()                           ← 设置umask，获取HOME等
 | |-my_thread_global_ init()           ← 初始化全局线程环境，包括私有数据、互斥量的初始化等
 | |-my_thread_init()                   ← 分配线程内存，主要用于mysys以及dbug
 |
 |-load_defaults()                      ← 加载默认的配置项
 |-handle_early_options()               ← 做些初始参数解析，例如PS的初始化
 | |-handle_options()                   ← 通用的解析命令行函数
 |-init_sql_statement_names()           ← 通过com_status_vars[]初始化，例如analyze等
 |-sys_var_init()                       ← 系统变量初始化
 | |-my_hash_init()                     ← 通过hash保存系统变量
 |-adjust_related_options()             ← 调整参数，如open_file_limit等
 |-initialize_performance_schema()      ← 如果需要则初始化PS
 |-init_server_psi_keys()               ← 如果需要则初始化PSI
 |
 |-init_error_log()
 |-mysql_audit_initialize()             ← 初始化audit全局接口，具体初始化稍后完成
 |
 |-init_common_variables()              ← 变量的初始化
 |-my_init_signals()
 |-init_server_components()             ← MySQL Server常用模块的初始化
 | |-mdl_init()
 | |-partitioning_init()
 | |-my_timer_initialize()
 | |-init_server_query_cache()
 | |-randominit()
 | |-setup_fpu()
 | |-init_slave_list()
 | |-open_error_log()
 | |-transaction_cache_init()
 | |-delegates_init()
 | |-process_key_caches()
 | |-ha_init_errors()
 | |-gtid_server_init()
 | |-plugin_init()
 | | |-plugin_load_list()
 | |   |-plugin_dl_add()                ← 包含了线程池类似插件的处理
 | |
 | |-ha_init()
 | |-initialize_storage_engine()
 | |-init_optimizer_cost_module()
 |
 |-init_ssl()
 |-network_init()                       ← 初始化网络模块，包括初始化调度器，创建socket监听端口
 |
 |-init_status_vars()
 |
 |-connection_event_loop()              ← 管理、创建新连接，会是一个死循环
 | |-listen_for_connection_event()
 | | |-poll()
 | |-process_new_connection()
 |   |-add_connection()
 |     |-mysql_thread_create()          ← 根据thread_handling参数选择具体方法
 |
 |-my_thread_join()
 |-clean_up()
 |-mysqld_exit()                        ← 程序退出</code></pre></figure>

<h3 id="初始化网络配置">初始化网络配置</h3>

<p>网络配置其实比较简单，就是设置端口，创建套接字，绑定端口，监听端口，实现全部集中在 network_init() 函数中，下面直接给出相应的伪代码：</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">network_init()
 |-set_ports()                          ← 设置端口号，#define MYSQL_PORT 3306
 |-Mysqld_socket_listener()             ← 根据参数等，启动实例
 |-init_connection_acceptor()
   |-setup_listener()                   ← 不同类型listerner调用接口不同，如socket、pipe、share_memory
     |-tcp_socket()                     ← 创建tcp_socket实例
     |-get_listener_socket()            ← 创建监听socket，并准备接收连接
       |-create_lockfile()
       |-mysql_socket_socket()
       | |-inline_mysql_socket_socket()
       |   |-socket()                   ← 创建套接字
       |
       |-mysql_socket_bind()
       | |-inline_mysql_socket_bind()
       |   |-bind()                     ← 绑定端口号
       |
       |-mysql_socket_listen()
         |-inline_mysql_socket_listen()
           |-listen()                   ← 监听端口号</code></pre></figure>

<p>客户端与服务端通信的方式不止是 SOCKET 一种，MySQL 还支持三种连接方式：namepipe、unix socket 和 shared memory，即命名管道、unix 套接字和共享内存的方式，这三种方式是可以共存的，只是有些只支持本地，socket 是最通用的方式。</p>

<h3 id="管理创建新连接--">管理/创建新连接  !!!!</h3>

<p>通过 connection_event_loop() 实现，而且 socket 管理其实比较简单，下面是其简单的处理代码：</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">connection_event_loop()                 ← 对应死循环，不断判断abort_loop参数
 |-get_instance()                       ← 获取连接处理的实例
 |-listen_for_connection_event()
 | |-poll()/select()                    ← 监视socket文件描述符
 | |-mysql_socket_accept()              ← 处理到来的客户端连接
 | |-Channel_info_tcpip_socket()        ← 创建一个实例
 |
 |-process_new_connection()
   |-add_connection()                   ← 创建一个新的线程，不同方式会有不同处理方式
     |-mysql_thread_create()
       |-pthread_create()               ← 对应的处理函数是handle_connection()</code></pre></figure>

<p>主要处理函数，一系列异常保护之后会停止在 select()/poll() 函数处，等待接受到新的连接，如果监控到有连接，则通过 accept() 函数接受客户端的连接。</p>

<p>，然后新建一个 THD 类，将连接参数全部设置到 THD 类的参数上，最后调用 create_new_thread() 函数，这个函数便是重点。</p>

<p>mysql 为每个连接设置一个线程，而 oracle 同时也可以将请求放入一个队列当中。</p>

<p>接着是创建线程来处理客户端发送来的请求，通过 create_new_thread()@sql/mysqld.cc 实现，该函数执行的主要流程如下：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">create_new_thread</span><span class="p">(</span><span class="n">THD</span> <span class="o">*</span><span class="n">thd</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++*</span><span class="n">thd</span><span class="o">-&gt;</span><span class="n">scheduler</span><span class="o">-&gt;</span><span class="n">connection_count</span><span class="p">;</span>       <span class="c1">// 全局连接数自增</span>
    <span class="n">thread_count</span><span class="o">++</span><span class="p">;</span>                            <span class="c1">// 全局线程数自增</span>

    <span class="c1">// 真正创建线程，实际调用的是 thd-&gt;scheduler.add_connection(thd);</span>
    <span class="n">MYSQL_CALLBACK</span><span class="p">(</span><span class="n">thd</span><span class="o">-&gt;</span><span class="n">scheduler</span><span class="p">,</span> <span class="n">add_connection</span><span class="p">,</span> <span class="p">(</span><span class="n">thd</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<p>在创建链接时，会对当前连接数检测 connection_count，先对互斥量 LOCK_connection_count 加锁，如果大于 max_connections+1，则报错，没有问题，才新建线程，一个典型的互斥线程。此时，全局连接数+1，全局线程数+1，然后调用 add_connection() 函数，现在线程创建成功了。</p>

<p>在 create_new_thread(thd) 的末尾，有一行代码，也就是如下的宏定义：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">MYSQL_CALLBACK</span><span class="p">(</span><span class="n">thd</span><span class="o">-&gt;</span><span class="n">scheduler</span><span class="p">,</span> <span class="n">add_connection</span><span class="p">,</span> <span class="p">(</span><span class="n">thd</span><span class="p">));</span>   <span class="n">sql</span><span class="o">/</span><span class="n">sql_callback</span><span class="p">.</span><span class="n">h</span>

<span class="cp">#define MYSQL_CALLBACK(OBJ, FUNC, PARAMS)   \</span>
<span class="cp">    do {                                    \</span>
<span class="cp">        if ((OBJ) &amp;&amp; ((OBJ)-&gt;FUNC))         \</span>
<span class="cp">            (OBJ)-&gt;FUNC PARAMS;             \</span>
<span class="cp">    } while (0)</span></code></pre></figure>

<p>这样，这个代码就是调用 thd-&gt;scheduler 的 add_connection 函数，参数是 (thd) 。这个函数就是我们在上面第一步设置连接的线程数中，one_thread_scheduler 和 one_thread_per_connection_scheduler 中设置的一个参数。这两者的区别便是是否创建了一个新的线程来处理到来的连接。</p>

<p>thd-&gt;scheduler 在 THD::THD() 构建函数中初始化，该值将继承全局的 thread_scheduler 。</p>

<h2 id="链接处理">链接处理</h2>

<p>在此，根据不同的链接方式会调用不同的接口，现在 MariaDB 支持三种处理方式。one_thread_scheduler 是单线程方式，也就是不会去新建线程，而线程池实现方式有些复杂，以后再详细了解。</p>

<p>所以，在此，重点研究 one_thread_per_connection_scheduler 链接方式，也就是说设置的 add_connection 函数实际最终调用的是 create_thread_to_handle_connection()。</p>

<p>void create_thread_to_handle_connection(THD *thd)@sql/mysqld.cc，在该函数中，如果设置了线程缓存，且缓存中有空闲的线程，则直接从栈中取出一个线程即可。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">create_thread_to_handle_connection</span><span class="p">(</span><span class="n">THD</span> <span class="o">*</span><span class="n">thd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cached_thread_count</span> <span class="o">&gt;</span> <span class="n">wake_thread</span><span class="p">)</span>
        <span class="n">thread_cache</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">thd</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">thread_created</span><span class="o">++</span><span class="p">;</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">thd</span><span class="p">);</span>               <span class="c1">// 创建线程数自增，并加入到threads链表上</span>
        <span class="n">mysql_thread_create</span><span class="p">(</span><span class="n">key_thread_one_connection</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">thd</span><span class="o">-&gt;</span><span class="n">real_id</span><span class="p">,</span><span class="o">&amp;</span><span class="n">connection_attrib</span><span class="p">,</span>
                <span class="n">handle_one_connection</span><span class="p">,</span>
                <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">thd</span><span class="p">)</span> <span class="p">;</span>              <span class="c1">// 这就是真正创建线程的地方了</span>
<span class="p">}</span></code></pre></figure>

<p>可见，最后调用了 mysql_thread_create() 函数，这是一个封装之后的函数，用于跨平台调用，对于 Linux，最后实际是通过 pthread_create() 创建了一个新的线程，而新线程的 处理函数为 handle_one_connection()。</p>

<h3 id="新线程处理流程">新线程处理流程</h3>

<p>新线程处理函数为 void *handle_connection(void *arg)，到此为止，一个新的 connection 被一个新创建的线程所单独处理，我们看下其中是如何进行处理的。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// 连接处理函数，入参是连接对象Channel_info</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">handle_connection</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">my_thread_init</span><span class="p">()</span>                               <span class="c1">// 初始化线程</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="n">THD</span> <span class="o">*</span><span class="n">thd</span><span class="o">=</span> <span class="n">init_new_thd</span><span class="p">(</span><span class="n">channel_info</span><span class="p">);</span>      <span class="c1">// 新建一个线程对象</span>
        <span class="n">thd_manager</span><span class="o">-&gt;</span><span class="n">add_thd</span><span class="p">(</span><span class="n">thd</span><span class="p">);</span>                 <span class="c1">// 添加到线程管理</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">thd_prepare_connection</span><span class="p">(</span><span class="n">thd</span><span class="p">))</span>           <span class="c1">// 包括用户认证</span>
          <span class="n">handler_manager</span><span class="o">-&gt;</span><span class="n">inc_aborted_connects</span><span class="p">();</span>
        <span class="k">else</span>
        <span class="p">{</span>
          <span class="k">while</span> <span class="p">(</span><span class="n">thd_connection_alive</span><span class="p">(</span><span class="n">thd</span><span class="p">))</span>
          <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">do_command</span><span class="p">(</span><span class="n">thd</span><span class="p">))</span>                   <span class="c1">// 处理命令</span>
              <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">end_connection</span><span class="p">(</span><span class="n">thd</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">close_connection</span><span class="p">(</span><span class="n">thd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

        <span class="n">thd</span><span class="o">-&gt;</span><span class="n">get_stmt_da</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">reset_diagnostics_area</span><span class="p">();</span>
        <span class="n">thd</span><span class="o">-&gt;</span><span class="n">release_resources</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>在新建完线程之后，会先调用 my_thread_init() 做线程的初始化，到目前为止，才算创建了一个新的线程，接着会有一些初始化的工作。</p>

<p><strong>注意，在此新建完线程后，后续的很多操作都会携带上该线程对象指针。</strong></p>

<p>接着会通过 thd_prepare_connection() 函数进行一些登陆认证等操作，通过 login_connection() 函数实现，还有一些其它的初始化工作。</p>

<p>接下来主要执行工作是在 do_command() 函数，也就是主要的命令处理函数。</p>

<h3 id="命令分发">命令分发</h3>

<p>接下来是主要的命令处理函数 <code>bool do_command(THD *thd)@sql/sql_parse.cc</code>，该函数主要用来接收、解析、执行命令报文；在线程中，该函数会不断循环执行。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">bool</span> <span class="nf">do_command</span><span class="p">(</span><span class="n">THD</span> <span class="o">*</span><span class="n">thd</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">thd</span><span class="o">-&gt;</span><span class="n">m_server_idle</span><span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="c1">// 如下的命令会阻塞在网络读取，直到读取了最新的报文</span>
  <span class="n">rc</span><span class="o">=</span> <span class="n">thd</span><span class="o">-&gt;</span><span class="n">get_protocol</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">get_command</span><span class="p">(</span><span class="o">&amp;</span><span class="n">com_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">command</span><span class="p">);</span>
  <span class="n">thd</span><span class="o">-&gt;</span><span class="n">m_server_idle</span><span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="c1">// 接下来准备分发命令</span>
  <span class="n">return_value</span><span class="o">=</span> <span class="n">dispatch_command</span><span class="p">(</span><span class="n">thd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">com_data</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>当客户端通过 TCP 连接上 MySQL 的服务器后，在发送请求之前，服务端的线程实际上是阻塞在 do_command() 函数中，也就是 socket 里的 read()。当接收到报文后，该函数同时还会作一些处理，如去除头部等。</p>

<!--
当客户端键入 sql 语句，如 select * from test，发送到服务端之后，my_net_read() 返回，并从 tcpbuffer 中读取数据，将 packet 指针指向读取的字符串位置。现在开始基本上每个函数执行的时候都会带有一个 thd 参数，也就是线程描述符。

packet 的第一个字节是个命令的标志位，决定数据包是查询还是命令、成功、或者出错，然后做一些简单的处理（也就是预处理），接下来就进入 dispatch_command()@sql/sql_parse.cc 函数，也就是主要的命令处理函数，此时数据类型不再需要。
-->

<p><strong>需要注意的是</strong>，有的命令只需要在 dispatch_command() 执行，例如 COM_REGISTER_SLAVE；而部分则会在 mysql_execute_command() 中执行，例如 SQLCOM_CHANGE_MASTER 。</p>

<p>在 dispatch_command() 函数中，其主要的处理流程如下。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">bool</span> <span class="nf">dispatch_command</span><span class="p">(</span><span class="k">enum</span> <span class="n">enum_server_command</span> <span class="n">command</span><span class="p">,</span> <span class="n">THD</span> <span class="o">*</span><span class="n">thd</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">packet</span><span class="p">,</span> <span class="n">uint</span> <span class="n">packet_length</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">command</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">COM_INIT_DB</span><span class="p">:</span> <span class="p">...</span> <span class="p">...;</span>
    <span class="k">case</span> <span class="nl">COM_QUERY</span><span class="p">:</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">alloc_query</span><span class="p">(</span><span class="n">thd</span><span class="p">,</span> <span class="n">com_data</span><span class="o">-&gt;</span><span class="n">com_query</span><span class="p">.</span><span class="n">query</span><span class="p">,</span>
                      <span class="n">com_data</span><span class="o">-&gt;</span><span class="n">com_query</span><span class="p">.</span><span class="n">length</span><span class="p">))</span>
        <span class="k">break</span><span class="p">;</span>                    <span class="c1">// fatal error is set</span>

      <span class="n">Parser_state</span> <span class="n">parser_state</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">parser_state</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">thd</span><span class="p">,</span> <span class="n">thd</span><span class="o">-&gt;</span><span class="n">query</span><span class="p">().</span><span class="n">str</span><span class="p">,</span> <span class="n">thd</span><span class="o">-&gt;</span><span class="n">query</span><span class="p">().</span><span class="n">length</span><span class="p">))</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="c1">// 开始进行SQL解析</span>
      <span class="n">mysql_parse</span><span class="p">(</span><span class="n">thd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parser_state</span><span class="p">);</span>

      <span class="c1">// 如果SQL中有通过分号分割的多条语句，同时会在下面处理，在此不赘述</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<!---
首先通过 statistic_increment() 函数增加统计量，可以通过 show global status questions 查看。
-->

<p>在该函数中，其主要作用的是一个巨大的 switch 语句，涵盖了 MySQL 支持的所有语句，包括了查询、PING、QUIT等指令，这些命令会在 include/my_command.h 中定义：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">enum</span> <span class="n">enum_server_command</span>
<span class="p">{</span>
    <span class="n">COM_SLEEP</span><span class="p">,</span> <span class="n">COM_QUIT</span><span class="p">,</span> <span class="n">COM_INIT_DB</span><span class="p">,</span> <span class="n">COM_QUERY</span><span class="p">,</span> <span class="n">COM_FIELD_LIST</span><span class="p">,</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="n">COM_END</span>
<span class="p">};</span></code></pre></figure>

<p>接下来命令的处理，就是根据不同的请求通过 switch 进入不同的函数入口，对于查询命令最后进入的是 COM_QUERY，先做一些初始化、写日志等后进入 <code>mysql_parse()@sql/sql_parse.cc</code>，该函数是 SQL 语句解析的总入口。</p>

<h3 id="命令解析">命令解析</h3>

<p>SQL 的解析包括了：词法分析，语法分析，语义分析，构造执行树，生成执行计划，计划的执行。SQL92 是最新的标准，里面的定义都是一些巴科斯范式(BNF)，就是一种语法定义的标准。</p>

<p>MySQL 通过 YACC(Yet Another Compiler Compiler) 进行语法解析，不过没有采用 LEX 进行词法分析，YACC 接收来自词法分析阶段分解出来的 token 然后去匹配那些 BNF 。</p>

<p>另外，比较不错的嵌入式数据库 SQLite，词法分析器是手工写的，语法分析器由 Lemon 生成，如果感兴趣可以看下代码，在此就不详述了。</p>

<p>在 sql/sql_yacc.cc 源码中，有如下的定义；其中词法解析相关的主要处理函数在 sql/sql_lex.cc 文件中，其入口即 MYSQLlex() ，而主要的分词处理函数为 lex_one_token() 。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define yyparse         MYSQLparse</span>
<span class="cp">#define yylex           MYSQLlex</span></code></pre></figure>

<h4 id="词法解析">词法解析</h4>

<p>可以直接通过 state_map[] 获得对应的状态，该数组在 init_state_maps() 中初始化，首先会将字符设置为 MY_LEX_IDENT 、数字设置为 MY_LEX_NUMBER_IDENT、空白字符设置为 MY_LEX_SKIP、其它的设置为 MY_LEX_CHAR ，然后会将一些特殊字符初始化。</p>

<p>而关于字符的判断如下，其中 s 为对应的字符集，c 对应的序号，也就是通过 _MY_X 进行判断。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define my_isalpha(s, c)  (((s)-&gt;ctype+1)[(uchar) (c)] &amp; (_MY_U | _MY_L))</span></code></pre></figure>

<p>每个字符集都会对应一个 ctype ，会通过该数组判断其类型。在 sql/lex.h 中定义了关键字，用两个数组存储 static SYMBOL symbols[] 和 static SYMBOL sql_functions[]。</p>

<h4 id="sql解析">SQL解析</h4>

<p>仍回到如上的函数入口。</p>

<p>SQL 命令解析的入口是 mysql_parse(); sql/sql_parse.cc，如上所述 SQL 的语法/语义解析是通过 yacc 实现，规则文件是 sql/sql_yacc.yy 。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">mysql_parse</span><span class="p">(</span><span class="n">THD</span> <span class="o">*</span><span class="n">thd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rawbuf</span><span class="p">,</span> <span class="n">uint</span> <span class="n">length</span><span class="p">,</span> <span class="n">Parser_state</span> <span class="o">*</span><span class="n">parser_state</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">mysql_reset_thd_for_next_command</span><span class="p">(</span><span class="n">thd</span><span class="p">);</span>              <span class="c1">// 重置结构体</span>
    <span class="n">lex_start</span><span class="p">(</span><span class="n">thd</span><span class="p">);</span>                                     <span class="c1">// 初始化词法分析结构体</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">query_cache_send_result_to_client</span><span class="p">(...)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 在cache中查询</span>
        <span class="n">err</span><span class="o">=</span> <span class="n">parse_sql</span><span class="p">(</span><span class="n">thd</span><span class="p">,</span> <span class="n">parser_state</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>        <span class="c1">// 不在cache中，直接查询</span>
        <span class="n">error</span><span class="o">=</span> <span class="n">mysql_execute_command</span><span class="p">(</span><span class="n">thd</span><span class="p">);</span>              <span class="c1">// 解析完后开始执行SQL</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                            <span class="c1">// 命中cache，直接返回</span>
        <span class="n">hd</span><span class="o">-&gt;</span><span class="n">lex</span><span class="o">-&gt;</span><span class="n">sql_command</span><span class="o">=</span> <span class="n">SQLCOM_SELECT</span><span class="p">;</span>            <span class="c1">// 设置结果，更新统计</span>
        <span class="p">...</span> <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>在 mysql_parse() 中有段注释，大概的意思是：本来应该先调用 query_cache_send_result_to_client()，也即在 query_cache 中查询该语句，加快查询速度。失败才调用 lex_start() 和 mysql_reset_thd_for_next_command() 来初始化 thd 解析 sql。但是查询 cache 也需要干净的 thd，只能先调用 lex_start() 和 mysql_reset_thd_for_next_command() 来初始化 thd 了，这样导致代码和逻辑有悖。</p>

<p>首先是初始化以及重置操作，接着会在 cache 中查询，如果有相同的语句，则立即从 cache 返回结果，于是整个 sql 就结束了。</p>

<p>如果 cache 里不存在该 sql，则继续前进来到 parse_sql()@sql/sql_parse.cc，这个函数主要就是调用了 MYSQLparse()，而 MYSQLparse() 其实就是 bison/yacc 里的 yyparse。</p>

<p>下面就开始解析 sql 了，主要是关于词法分析和语法匹配，对于一条像 select * from test 的语句首先进入词法分析，此时会找到 2 个 token(select, from)，然后根据 token 进行语法匹配，规则在 sql/sql_yacc.yy 里。</p>

<p>最后的解析结果中，lex-&gt;sql_command 保存了相应的命令。</p>

<p>sql 解析完了，然后是一些优化操作等，接着进入 mysql_execute_command()@sql/sql_ parse.cc 函数，这个函数是所有 sql 命令执行的总入口。</p>

<h3 id="命令执行">命令执行</h3>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">mysql_execute_command</span><span class="p">(</span><span class="n">THD</span> <span class="o">*</span><span class="n">thd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">lex</span><span class="o">-&gt;</span><span class="n">sql_command</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">SQLCOM_SHOW_EVENTS</span><span class="p">:</span> <span class="p">...;</span>
        <span class="k">case</span> <span class="nl">SQLCOM_SELECT</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">check_table_access</span><span class="p">(...);</span>
            <span class="n">res</span><span class="o">=</span> <span class="n">execute_sqlcom_select</span><span class="p">(</span><span class="n">thd</span><span class="p">,</span> <span class="n">all_tables</span><span class="p">);</span>    <span class="c1">// 执行查询</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>在 mysql_execute_command() 中，先确定 command 要对哪张表操作 lex-&gt;first_lists_tables_same(); 根据该表的状态，会做一些预处理，尽量减少之后的操作对表的影响（因为目前还不知道这条指令执行之后，会对数据库产生什么样的影响）做好保护是必须的。</p>

<p>然后有个 switch 语句，他决定了 command 属于哪种类型，这些类型定义在 sql/sql_ lex.h 中：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">enum</span> <span class="n">enum_sql_command</span> <span class="p">{</span>
    <span class="n">SQLCOM_SELECT</span><span class="p">,</span> <span class="n">SQLCOM_CREATE_TABLE</span><span class="p">,</span> <span class="p">......</span> <span class="n">SQLCOM_END</span>
<span class="p">};</span></code></pre></figure>

<p>仍然以查询命令为例，最后会进入 SQLCOM_SELECT 这个 case 分支。之后就是命令的解析，处理，以及然后查询，规整结果集。</p>

<p>最后 select 的执行，通过 execute_sqlcom_select()@sql/sql_parse.cc 实现，在 execute_sqlcom_select() 函数中，调用 handle_select() (优化入口)，然后调用 mysql_select()。</p>

<p>mysql_select() 就是执行模块，这个模块代码比较复杂，可以清楚看到创建优化器 (JOIN::prepare)、优化 (JOIN::optimize)、执行 (JOIN::exec) 的3个步骤，在 MySQL 中，会将任何 select 都转换为 JOIN 来处理的。</p>

<p>MySQL 在设计时，采用了这样的思路：针对主要应用场景选择一个或几个性能优异的核心算法作为引擎，然后努力将一些非主要应用场景作为该算法的特例或变种植入到引擎当中。具体而言，MySQL 的 select 查询中，核心功能就是 JOIN 查询，因此在设计时，核心实现 JOIN 功能，对于其它功能，都通过转换为 JOIN 来实现。</p>

<p>即使对于最简单的 select name from student 也会转换为 JOIN 来操作。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">join</span><span class="o">=</span> <span class="n">new</span> <span class="n">JOIN</span><span class="p">(</span><span class="n">thd</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">select_options</span><span class="p">,</span> <span class="n">result</span><span class="p">)))</span>
    <span class="p">...</span>
<span class="k">if</span> <span class="p">((</span><span class="n">err</span><span class="o">=</span> <span class="n">join</span><span class="o">-&gt;</span><span class="n">optimize</span><span class="p">()))</span>
    <span class="p">...</span>
<span class="n">join</span><span class="o">-&gt;</span><span class="n">exec</span><span class="p">();</span></code></pre></figure>

<p>结束了优化，我们要具体执行 join-&gt;exec()，该函数实际进入的是 JOIN::exec()@sql_select.cc。</p>

<p>exec()首先向客户端发送字段title的函数send_result_set_metadata()，没数据但字段也是要的。然后再进入 do_select() ，根据表的存储引擎跳入到引擎具体的实现。如果是 myisam，则通过 myisam 引擎扫描文件，其中 info-&gt;filename 实际保存的是文件的地址。</p>

<p>最后通过 join-&gt;result-&gt;send_data() 将数据发送给用户。并从 dispatch_command() 返回，最后在 net_end_statement 结束整个 sql 。</p>

<h2 id="总结">总结</h2>

<p>处理 MySQL 客户端命令，在此以 one_thread_per_connection_scheduler 方式为例，也就是创建 handle_one_connection() 独立线程处理请求。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">handle_connections_sockets()
  |-poll()                           通过gdb查看，可以看到在此等待连接
  |-thd = new THD; my_net_init()
  |-create_new_thread()              根据不同的thread handler调用不同的函数
     |-create_thread_to_handle_connection()       one_thread_per_connection_scheduler方式
          |-handle_one_connection()                创建的新线程来处理
              |-do_handle_one_connection()
                  |-do_command()                   在死循环中处理
                      |-my_net_read_packet()
                      |-dispatch_command()         一堆的switch，根据客户端报文类型解析，include/mysql_com.h
++=== SQL Interface ==|+++|
                      |   |-mysql_change_db()      执行use db命令，COM_INIT_DB
                      |   |-sql_kill()             执行kill命令，COM_PROCESS_KILL
                      |   |- ... ...
                      |   |-mysql_parse()          执行SQL语句，COM_QUERY
                      |     |-lex_start()
                      |     |-mysql_reset_thd_for_next_command()
                      |     |-query_cache_send_result_to_client()
                      |     |-parse_sql()
                      |     |   |-MYSQLparse()   通过yacc解析SQL，规则文件保存在sql/sql_yacc.yy
                      |     |
                      |     | &lt;font color=&quot;red&quot;&gt;各种类型的SQL，一个大switch语句&lt;/font&gt;
                      |     |-mysql_execute_command()         根据不同的SQL语句执行，sql/sql_cmd.h，对item调试
                      |         |-execute_show_status()       执行show status，SQLCOM_SHOW_STATUS
                      |         |- ... ...
                      |         |-check_table_access()        执行select，&lt;font color=&#39;red&#39;&gt;SQLCOM_SELECT&lt;/font&gt;
                      |         |-execute_sqlcom_select()
                      |         |   |-open_and_lock_tables()
                      |         |   |   |-open_tables()
                      |         |   |   |   |-open_and_process_table()
                      |         |   |   |       |-open_table()
                      |         |   |   |           |-Table_cache::get_table()
                      |         |   |   |           |-get_table_share_with_discover()
                      |         |   |   |           |   |-get_table_share()
                      |         |   |   |           |       |-open_table_def()
                      |         |   |   |           |           |-my_open()
                      |         |   |   |           |           |-open_binary_frm()
                      |         |   |   |           |               |-get_new_handler()  获取表的handler
                      |         |   |   |           |-my_malloc // 申请表数据结构
                      |         |   |   |           |-open_table_from_share
                      |         |   |   |               |-handler::ha_open
                      |         |   |   |                   |-ha_innobase::open
                      |         |   |   |                       |-dict_table_open_on_name
                      |         |   |   |                           |-dict_load_table
                      |         |   |   |                               |-btr_pcur_is_on_user_rec
                      |         |   |   |                               |-dict_load_table_low
                      |         |   |   |                               |   |-dict_mem_table_create
                      |         |   |   |                               |-fil_space_for_table_exists_in_mem
                      |         |   |   |                               |-fil_open_single_table_tablespace // 打开表空间文件
                      |         |   |   |-lock_tables()
                      |         |   |   |-mysql_handle_derived()
                      |         |   |-query_cache_store_query()       先查看缓存
                      |         |   |
                      |         |   |-handle_select()                 SQL处理的真正入口，会判断是否为union
                      |         |       |-mysql_union()               如果含有union，则调用该函数
                      |         |       |-mysql_select()              否则调用该函数
++=== Query Parser ===|++       |           |&lt;/font&gt;
                      |         |           |-mysql_prepare_select()
                      |         |           | |-JOIN::prepare()@sql/sql_select.cc
                      |         |           | | |-setup_tables_and_check_access()
                      |         |           | | |-setup_wild()
                      |         |           | | |-setup_fields()
                      |         |           | | |-setup_without_group()
                      |         |           | | |-setup_order()                      order by语句相关
                      |         |           |     |-find_order_in_list()
                      |         |           |       |-find_item_in_list()
                      |         |           |
                      |         |           |-lock_tables()
                      |         |           |-query_cache_store_query()
                      |         |           |-mysql_execute_select()
                      |         |               |
++=== Query Prepare ==|+++      |               |&lt;font color=&quot;blue&quot;&gt;
                      |         |               |-JOIN::optimize()                     @sql/sql_optimizer.cc
                      |         |               |
                      |         |               |
                      |         |               |-JOIN::explain()                      @sql/sql_explain.cc
                      |         |               |   |                                  如果使用的是explain语句，返回而不执行
                      |         |               |   |-prepare_result()
                      |         |               |   |-explain_query_specification()
                      |         |               |
                      |                            Explain_query::send_explain()
++=== Query Optimizer |==+++    |               |&lt;/font&gt;
                      |         |               |-JOIN::exec()            根据执行计划进行相应处理
                      |         |                   |-exec_inner()
                      |         |                       |-select_result::prepare()
                      |         |                       |-select_result::prepare2()
                      |         |                       |-select_send::send_result_set_metadata()
                      |         |                       |   |-Protocol::send_result_set_metadata()
                      |         |                       |
                      |         |                       |-do_select()                           查询入口函数
                      |         |                         |-join-&gt;first_select()            1. 实际调用sub_select()，也即循环调用
                                                          | |                                  rnd_next()+evaluate_join_record()
                      |         |                         | |
                      |         |                         | |                               while循环读取数据
                      |         |                         | |-join_tab-&gt;read_first_record() 首次调用，实际为init_read_record()
                      |         |                         | |   |-ha_rnd_init()
                      |         |                         | |   |   |-change_active_index()
                      |         |                         | |   |       |-innobase_get_index()
                      |         |                         | |   |-innobase_trx_init()
                      |         |                         | |-info-&gt;read_record()           再次调用，该函数在init中初始化
                      |         |                         | |
                      |         |                         | |-evaluate_join_record()        处理一条查询记录
                      |         |                         |     |-end_send()
                      |         |                         |         |-select_send::send_data()
                      |         |                         |             |-Protocol::write()
                      |         |                         |
                      |         |                         |-join-&gt;result-&gt;send_eof()
++=== Query Execution |==+++    |                         |
   st_select_lex::cleanup       |
                      |         |
                      |         |
                      |         |-update_precheck()
                      |         |-mysql_update()
                      |         |   |-open_normal_and_derived_tables()
                      |         |   |-mysql_prepare_update()
                      |         |   |-innobase_register_trx()
                      |         |   |-innobase_register_trx()
                      |         |
                      |         |
                      |         |
                      |         |
                      |         |
                      |         |
                      |         |
                      |         |
                      |
                      |-thd-&gt;protocol-&gt;end_statement()        将获得的查询结果发送到客户端</code></pre></figure>

<p>在查询记录时，会循环调用 ha_innobase::rnd_next() 和 evaluate_join_record() 获取并处理该部分的每条记录。</p>

<h3 id="结论">结论</h3>

<p>整个 connection manager 的流程十分清晰，单线程的连接一般很少使用，大多使用多线程方式。多线程连接中其实还涉及到线程缓冲池的概念，即如果一个连接断开后，其所创建的线程不会被销毁掉，而是放到缓冲池中，等待下一个新的 connection 到来时，首先去线程缓冲池查找是否有空闲的线程，有的话直接使用，木有的话才去创建新的线程来管理这个 connection。</p>


  <hr>
  <nav>
    <ul class="pager">
         <li class="previous"><a href="/post/mysql-security_init.html" title="MySQL 安全设置">&larr; Older</a></li> 
         <li class="next"><a href="/post/charsets-encoding.html" title="字符集与编码杂谈">Newer &rarr;</a></li> 
    </ul>
  </nav><br>
<!--
  <hr><div id="section-donate"><span>赏</span></div><br>
  <p style="text-indent:0px;text-align:center;">如果喜欢这里的文章，而且又不差钱的话，欢迎打赏个早餐 ^_^</p><br>
  <div class="row" style="text-align:center;" >
    <div class="col-md-6"><img src="/images/system/barcode-pay-alipay.jpg" style="width:150px;height:150px;" title="支付宝捐赠" /><br>支付宝打赏</div>
    <div class="col-md-6"><img src="/images/system/barcode-pay-wechat.jpg" style="width:150px;height:150px;" title="微信捐赠" /><br>微信打赏</div>
  </div><br><hr>
-->
  <p style="text-indent:0px;text-align:center;">如果喜欢这里的文章，而且又不差钱的话，欢迎打赏个早餐 ^_^</p>
  <div id="donate_module">
    <style type="text/css">
      .donate_bar a.btn_donate{
        display: inline-block;
        position:      relative;
        text-align:    center;
        width: 82px;
        height: 82px;
        background: url("/images/misc/btn_reward.gif") no-repeat;
        _background: url("/images/misc/btn_reward.gif") no-repeat;
        -webkit-transition: background 0s;
        -moz-transition: background 0s;
        -o-transition: background 0s;
        -ms-transition: background 0s;
        transition: background 0s;
      }
      .donate_bar a.btn_donate:hover{ background-position: 0px -82px;}
      .donate_bar .donate_txt {
        display: block;
        color: #9d9d9d;
        font: 14px/2 "Microsoft Yahei";
      }
    </style>
    <div id="donate_board" class="donate_bar row" style="text-align:center;" >
      <a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏"></a>
    </div>
    <div id="donate_guide" class="donate_bar center hidden">
      <div class="row" style="text-align:center;" >
        <div class="col-md-6"><img src="/images/system/barcode-pay-alipay.jpg" style="width:150px;height:150px;" title="支付宝捐赠" /><br>支付宝打赏</div>
        <div class="col-md-6"><img src="/images/system/barcode-pay-wechat.jpg" style="width:150px;height:150px;" title="微信捐赠" /><br>微信打赏</div>
      </div>
    </div>
    <script type="text/javascript">
      document.getElementById('btn_donate').onclick = function(){
        $('#donate_board').addClass('hidden');
        $('#donate_guide').removeClass('hidden');
      }
      function donate_on_web(){
        $('#donate').submit();
      }
    </script>
  </div>

  <hr>

  <div id="gitmentContainer"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
  var gitment = new Gitment({
      id: '1430496000',
      owner: 'Jin-Yang',
      repo: 'jin-yang.github.com',
      oauth: {
          client_id: '6d89d48ce689192bf95d',
          client_secret: 'c9a720aafb8e3084e3feb46cadee80b03cdc792f',
      },
  });
  gitment.render('gitmentContainer');
  </script>

  <!-- 多说评论框 start -->
  <!--<div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>-->
  <!--
  <div class="ds-thread" data-thread-key="/post/mysql-skeleton_init.html" data-title="MySQL 代码导读" data-url="/post/mysql-skeleton_init.html"></div>
  -->
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <!--
  <script type="text/javascript">
      var duoshuoQuery = {short_name:"jinyangposts"};
      (function() {
          var ds = document.createElement('script');
          ds.type = 'text/javascript';ds.async = true;
          ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
          ds.charset = 'UTF-8';
          (document.getElementsByTagName('head')[0]
           || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
  </script>
  -->
  <!-- 多说公共JS代码 end -->
</div>

    </div>
    <div class="col-lg-3 visible-lg blog-sidebar">
    <center><a href="/"><img src="/images/system/linux-liberty.png" width="200" /></a></center>
<h2>About This Blog</h2>
<div class="sidebar-module">
<p style="text-indent:0em;margin:0px;padding:0px;">This is a personal weblog ^_^ generated with Jekyll, if you like it or have some questions,
just feel free to contact me :)</p>
</div><!-- end of "node" "about" -->



<h2>Recent Posts</h2>
<div class="list-group">
  
    <a class="list-group-item" href="/post/linux-program-cpu-cache-introduce_init.html">CPU Cache</a>
  
    <a class="list-group-item" href="/post/artificial-intelligence-decision-tree-introduce.html">决策树</a>
  
    <a class="list-group-item" href="/post/linux-ebpf-bcc-tools-introduce.html">BCC 工具使用</a>
  
    <a class="list-group-item" href="/post/linux-ebpf-basic-usage-introduce.html">eBPF 简介</a>
  
    <a class="list-group-item" href="/post/math-monte-carlo-sample-introduce.html">采样算法</a>
  
</div>

<h2>Categories</h2>
<ul class="list-group" style="margin:0px;">
  
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#bash"> bash</a>
    <span class="badge">2</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#database"> database</a>
    <span class="badge">86</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#golang"> golang</a>
    <span class="badge">28</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#linux"> linux</a>
    <span class="badge">301</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#misc"> misc</a>
    <span class="badge">244</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#mysql"> mysql</a>
    <span class="badge">79</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#network"> network</a>
    <span class="badge">49</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#postgresql"> postgresql</a>
    <span class="badge">4</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#program"> program</a>
    <span class="badge">138</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#python"> python</a>
    <span class="badge">25</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#react"> react</a>
    <span class="badge">1</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#rtems"> rtems</a>
    <span class="badge">1</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#sql"> sql</a>
    <span class="badge">10</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#tools"> tools</a>
    <span class="badge">1</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#webserver"> webserver</a>
    <span class="badge">25</span>
  </li>
  
</ul><!-- end of "node" "categories" -->

<h2>Related Links</h2>
<ul class="list-group" style="margin:0px">
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
       <a href="http://www.rtems.org" title="To RTEMS"><img class="img-thumbnail img-responsive" src="/images/system/rtems.png"  alt="RTEMS"/></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>RTEMS</strong><br>
        <div class="sidebar-description">Real-Time Executive for Multiprocessor System</div>
      </div>
    </div>
  </li>
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
       <a href="http://www.gnu.org" title="To GNU">
       <img class="img-thumbnail img-responsive" src="/images/system/gnu.jpg" alt="GNU" /></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>GNU</strong><br>
        <div class="sidebar-description">A Unix-linux Operating System</div>
      </div>
    </div>
  </li>
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
    <a href="http://www.kernel.org" title="To Linux Kernel">
    <img class="img-thumbnail img-responsive" src="/images/system/linux.png"  alt="LINUX" /></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>Linux Kernel</strong><br>
        <div class="sidebar-description">Maintained by Linux Kernel Organization</div>
      </div>
    </div>
  </li>
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
    <a href="http://arduino.cc" title="To Arduino">
    <img class="img-thumbnail img-responsive" src="/images/system/arduino.png"  alt="ARDUINO" /></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>Arduino</strong><br>
        <div class="sidebar-description">Open-source Electronic Prototyping Platform</div>
      </div>
    </div>
  </li>
</ul>

<h2>Search</h2>
<div class="sidebar-module">
  <form class="search" method="GET" action="https://www.google.com.hk/search">
    <input type="text" name="q" class="search-query" placeholder=" Search on Google">
    <input type="hidden" name="ie" value="utf-8">
    <input type="submit" name="sa" value="Search" />
  </form><br>
  <input type="text" class="search-field" placeholder=" Search This Site">
  <div class="search-results"></div>
</div>



    </div>
  </div>
<hr><p class="text-center">This Site was built by Jin Yang, generated with Jekyll, and hosted on GitHub Pages<br/> &copy;2013-2019 &ndash; Jin Yang</p><div class="footer-logo"></div>

</div>
</body>
</html>
