<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="baidu-site-verification" content="B786jeR0MV" />
  <meta name="msvalidate.01" content="29F791E7F785800340E37AD7C714D2A7" />
  <meta name="google-site-verification" content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0" />
  <title>ETCD 示例源码|JinYang's Blog</title>
  <meta name="keywords" content="golang,go,etcd">
  <meta name="description" content="现在已知的 Golang 版本的 RAFT 的开源实现主要有两个：一个是 CoreOS 的 etcd 中的实现，使用的项目有比如 tidb、cockroachdb 等；另外一个是 hashcorp 的 RAFT 实现，使用的项目有比如 consul、InfluxDB 等。相比而言，前者只实现了一个整体框架，很多的功能需要用户实现，难度增加但是更加灵活；而后者则是完整的实现，WAL、SnapShot、存储、序列化等。">

  <script src="https://cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>
  <script type="text/javascript">
  !window.jQuery && document.write('<script src="/static/js/jquery.min.js"><\/script>');
  </script>
  <script src="https://cdn.bootcss.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
  <script type="text/javascript">
  !$('body').popover && document.write('<script src="/static/js/bootstrap.min.js"><\/script>');
  </script>
  <script type="text/javascript" src="/static/js/main.js"></script>
  <!-- <link rel="stylesheet prefetch" href="http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css"> -->
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/bootstrap.min.css">
  <!-- <link href="http://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/font-awesome.min.css">
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/pygments.css">
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/screen.css">
  <style type="text/css">
  
    .post-container > p {text-indent: 2em;}
  
  </style>
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-124556620-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-124556620-1');
</script>

</head>

<body>
<nav class="navbar navbar-default navbar-inverse navbar-fixed-top navbar-wrapper">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span>
      </button><a class="navbar-brand" href="/">Jin-Yang</a>
    </div>
    <div id="navbar" class="collapse navbar-collapse">
      <ul class="nav navbar-nav">
        <li  ><a href="/"> Home </a></li>
        <li  ><a href="/archives.html"> Archive </a></li>
        <li  ><a href="/categories.html"> Categories </a></li>
        <li  ><a href="/projects.html"> Projects </a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"> Others <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li class="dropdown-header">常用网站</li>
            <li role="separator" class="divider"></li>
            <li><a href="https://www.rtems.org/">www.rtems.org</a></li>
            <li><a href="http://www.gnu.org/">www.gnu.org</a></li>
            <li><a href="https://www.kernel.org/">www.kernel.org</a></li>
            <li><a href="https://www.arduino.cc/">www.arduino.cc</a></li>
          </ul>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li  ><a href="/about.html"> About </a></li>
      </ul>
    </div><!--/.nav-collapse -->
  </div>
</nav>

<div id="myCarousel" class="carousel slide" data-ride="carousel">
  <!-- Indicators -->
  <ol class="carousel-indicators">
    <li data-target="#myCarousel" data-slide-to="0" class="active"></li>
    <li data-target="#myCarousel" data-slide-to="1"></li>
    <li data-target="#myCarousel" data-slide-to="2"></li>
    <li data-target="#myCarousel" data-slide-to="3"></li>
    <li data-target="#myCarousel" data-slide-to="4"></li>
  </ol>
  <div class="carousel-inner" role="listbox">
    <div class="item active">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>KISS</h1>
          <h2>Keep It Simple and Stupid.</h2>
          <!--<a class="btn btn-lg btn-primary" href="#" role="button">Sign up today</a>-->
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Seize The Day</h1><h1>And Get Busy Living</h1>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Stay hungry</h1><h1>Stay foolish</h1>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
	  <h2>Ever tried, ever failed</h2><h2>No matter, try again</h2><h2>Fail again, fail better</h2>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Nothing is true</h1><h1>Every is permitted</h1>
        </div>
      </div>
    </div>
  </div>
  <a class="left carousel-control" href="#myCarousel" role="button" data-slide="prev">
    <span class="glyphicon glyphicon-chevron-left"></span>
    <span class="sr-only">Previous</span>
  </a>
  <a class="right carousel-control" href="#myCarousel" role="button" data-slide="next">
    <span class="glyphicon glyphicon-chevron-right"></span>
    <span class="sr-only">Next</span>
  </a>
</div><!-- /.carousel -->

<div class="container">
  <div class="row">
    <div class="col-lg-9 blog-main" style="min-width: 500px">
    
<div class="post-container">
  <div class="blog-header">
    <h1>ETCD 示例源码</h1>
    <div class="post-description">
      <i class="fa fa-calendar"></i> 2017-11-05 Sunday &nbsp; &nbsp;
      <i class="fa fa-tags"></i>  program ,  golang ,  linux  
      
    </div>
  </div>
  <hr>
  <p>现在已知的 Golang 版本的 RAFT 的开源实现主要有两个：一个是 CoreOS 的 etcd 中的实现，使用的项目有比如 tidb、cockroachdb 等；另外一个是 hashcorp 的 RAFT 实现，使用的项目有比如 consul、InfluxDB 等。</p>

<p>相比而言，前者只实现了一个整体框架，很多的功能需要用户实现，难度增加但是更加灵活；而后者则是完整的实现，WAL、SnapShot、存储、序列化等。</p>

<!-- more -->

<h2 id="简介">简介</h2>

<p>整体来说，该库实现了 RAFT 协议核心内容，如 append log、选主逻辑、snapshot、成员变更等；但该库没有实现消息传输和接收，只会把待发送消息保存在内存中，通过用户自定义的网络传输层取出消息并发送出去，并且在网络接收端，需要调一个库函数，用于将收到的消息传入库。</p>

<p>同时，该库定义了一个 Storage 接口，需要库的使用者自行实现。</p>

<h3 id="示例程序">示例程序</h3>

<p>RAFT 协议的实现主要包括了四部分：协议逻辑、存储、消息序列化和网络传输，而 ETCD 对应的 RAFT 库只实现了最核心算法。</p>

<p>源码可以直接下载 <a href="https://github.com/coreos/etcd">Github coreos/etcd</a> 其中有一个简单的示例 <a href="https://github.com/coreos/etcd/tree/master/contrib/raftexample">contrib/raftexample</a>，这是一个内存的 KV 存储引擎。</p>

<p>示例中的 wal 和 snapshot 实际上使用的是 ETCD 中的实现。</p>

<!--
RAFT 交互流程相关的内容都放在 raftNode 中，而节点状态、IO调用、事件触发起点等入口都放在了 node 中，两者都在启动后起了一个 for-select 结构的协程循环处理各自负责的事件。
1) 递增currentTerm，投票给自己；2) 重置ElectionTimer；3) 向所有的服务器发送 RequestVote RPC请求
-->

<h3 id="使用">使用</h3>

<p>看下如何在系统中使用。</p>

<h4 id="编译">编译</h4>

<p>直接修改编译脚本 build 中的编译命令，然后直接运行 <code>./build</code> 即可。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">go build -o &quot;${out}/raftexample&quot; ${REPO_PATH}/contrib/raftexample || return</code></pre></figure>

<h4 id="测试">测试</h4>

<p>可以在一个节点上启动三个服务进程(也可以只启动一个)。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ raftexample --id 1 --cluster http://127.0.0.1:12379,http://127.0.0.1:22379,http://127.0.0.1:32379 --port 12380
$ raftexample --id 2 --cluster http://127.0.0.1:12379,http://127.0.0.1:22379,http://127.0.0.1:32379 --port 22380
$ raftexample --id 3 --cluster http://127.0.0.1:12379,http://127.0.0.1:22379,http://127.0.0.1:32379 --port 32380</code></pre></figure>

<p>如上，通过参数指定整个集群的节点数，启动后会发起一次选举过程。</p>

<p>为了调试方便，可以通过 <a href="https://jin-yang.github.io/post/golang-introduce.html#goreman">goreman</a> 启动。</p>

<h4 id="发送数据">发送数据</h4>

<p>然后，通过如下方式发送和获取数据。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">curl -L http://127.0.0.1:12380/my-key -XPUT -d hello
curl -L http://127.0.0.1:12380/my-key</code></pre></figure>

<h4 id="结点管理">结点管理</h4>

<p>可以通过以下方式将一个新节点加入集群:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ curl -L http://127.0.0.1:12380/4 -XPOST -d http://127.0.0.1:42379
$ raftexample --id 4 --port 42380 --join \
     --cluster http://127.0.0.1:12379,http://127.0.0.1:22379,http://127.0.0.1:32379,http://127.0.0.1:42379</code></pre></figure>

<p>或者删除节点。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ curl -L http://127.0.0.1:12380/3 -XDELETE</code></pre></figure>

<h4 id="压测">压测</h4>

<p>可以通过如下的脚本生成压测的脚本。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/sh -e</span>

<span class="k">for</span> <span class="o">((</span><span class="nv">i</span><span class="o">=</span>1<span class="p">;</span> i&lt;<span class="o">=</span>150<span class="p">;</span> i ++<span class="o">))</span><span class="p">;</span> <span class="k">do</span>
        <span class="nv">uuid</span><span class="o">=</span><span class="sb">`</span>uuidgen<span class="sb">`</span>
        <span class="nb">echo</span> <span class="s2">&quot;curl -L http://127.0.0.1:12380/${uuid} -XPUT -d &#39;${uuid}-hello&#39;&quot;</span>
<span class="k">done</span></code></pre></figure>

<!--
仔细阅读了下源代码发现，其主要区别在于启动RaftNode的时候，如果是join，就不会传递集群其他peers信息给raft组件，否则就会传递。但是是否传递该参数对raft组件的行为有什么影响目前还不太清楚，有待接下来继续分析raft组件了。
-->

<h2 id="数据结构">数据结构</h2>

<p>简单介绍下常见的数据结构。</p>

<h3 id="kvstore">KVStore</h3>

<p>通过 kvstore 抽象了应用的全部相关内容。</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">kvstore</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">proposeC</span>    <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">string</span>
	<span class="nx">mu</span>          <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
	<span class="nx">kvStore</span>     <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
	<span class="nx">snapshotter</span> <span class="o">*</span><span class="nx">snap</span><span class="p">.</span><span class="nx">Snapshotter</span>
<span class="p">}</span></code></pre></figure>

<p>最核心的成员有：</p>

<ul>
  <li>proposeC 这是应用和底层 RAFT 库之间的通信管道(Channel)，所有对应用的更新请求都会由应用通过该管道向底层 RAFT 库传递；</li>
  <li>kvStore：内存状态机，存储应用的状态数据；</li>
  <li>snapshotter 应用管理 Snapshot 的接口。</li>
</ul>

<h3 id="raftnode">RaftNode</h3>

<p>该结构用来衔接底层 RAFT 协议以及应用层，通过该结构可以简化 RAFT 底层的细节，降低系统耦合度。该结构需要处理的任务包括：</p>

<ul>
  <li>应用的更新请求传递给底层 RAFT 协议；</li>
  <li>RAFT 已提交的请求传输给应用以更新应用的状态机；</li>
  <li>处理 RAFT 组件产生的指令，如选举指令、数据复制指令、集群节点变更指令等；</li>
  <li>处理 WAL 日志；</li>
  <li>将底层 RAFT 组件的指令通过网络传输至集群其它节点等。</li>
</ul>

<p>相较于应用来说，该结构 (type raftNode struct) 功能的实现更为复杂，其核心数据结构定义如下：</p>

<ul>
  <li>proposeC 应用将客户的更新请求传递至底层 RAFT 组件的管道；</li>
  <li>commitC 底层 RAFT 组件通知应用层准备提交的通道；</li>
</ul>

<!--
node：是对底层的raft组件的抽象，所有与底层raft组件的交互都通过该结构暴露的API来实现；
wal：WAL日志管理，etcd-raft将日志的管理交给应用层来处理；
snapshotter：同wal，etcd-raft将快照的管理也交给应用层来处理；
transport：应用同其他节点应用的网络传输接口，同wal，etcd-raft将集群节点之间的网络请求发送和接收也交给应用层来处理。

ETCD RAFT 的核心层实现相对轻量级，而带来的后果是应用需要处理较为复杂的与协议有关内容，带来灵活性的同时也增加了应用的复杂性。
-->

<h2 id="ready-数据">Ready 数据</h2>

<p>通过 <code>type Ready struct</code> 定义可以知道，其中保存了多种状态的数据：</p>

<ol>
  <li>什么时候可以读。ReadState 用来支持 Linearizable Read。</li>
  <li>需要持久话的状态。HardState、Entries 需要在正式发送数据之前持久化。</li>
  <li>需要执行SnapShot的数据。Snapshot 。</li>
  <li>已经提交的数据，可以应用到状态机。CommittedEntries 。</li>
  <li>需要发送到其它机器的消息。Messages 需要在处理完持久化数据之后处理。</li>
</ol>

<p>在 <code>node.run()[raft/node.go]</code> 中，会通过 <code>newReady()</code> 新建 Ready 对象，其中包含了上述的成员内容，那么新建 Ready 对象无非就是如何构建其中的成员变量。</p>

<p>另外，在示例代码 <code>raftNode.serveChannels()</code> 中，可以将 Ready 对象打印出来。</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Ready</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="o">*</span><span class="nx">SoftState</span>
        <span class="nx">pb</span><span class="p">.</span><span class="nx">HardState</span>                <span class="c1">// 在发送信息前需要持久化的状态</span>
        <span class="nx">ReadStates</span> <span class="p">[]</span><span class="nx">ReadState</span>
        <span class="nx">Entries</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span>          <span class="c1">// 通过raftLog.unstableEntries()读取的是raftLog.unstable.entries中的数据</span>
        <span class="nx">Snapshot</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">Snapshot</span>
        <span class="nx">CommittedEntries</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span> <span class="c1">// 包括了所有已经持久化到日志但是还没有应用到状态机的数据</span>
                                    <span class="c1">//   raftLog.nextEnts() raft/log.go 用来获取所有需要提交的日志，用来应用到状态机</span>
	<span class="nx">Messages</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span>       <span class="c1">// 包含了应该发送给对端的数据，也就是直接读取的raft.msgs[]中缓存的数据</span>
        <span class="nx">MustSync</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">raftLog</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">storage</span> <span class="nx">Storage</span>             <span class="c1">// 包含了上次snapshot之后所有持久化的日志</span>
        <span class="nx">unstable</span> <span class="nx">unstable</span>           <span class="c1">// 未提交的日志，包括snapshot</span>
        <span class="nx">committed</span> <span class="kt">uint64</span>            <span class="c1">// 已经在多数节点上持久化的最大日志号</span>
        <span class="nx">applied</span> <span class="kt">uint64</span>              <span class="c1">// 在本节点已经应用到状态机的日志号</span>
        <span class="nx">logger</span> <span class="nx">Logger</span>
<span class="p">}</span></code></pre></figure>

<!--
首先看下


<figure class="highlight"><pre><code class="language-text" data-lang="text">firstIndex() 用来获取已经持久化的最近序号  正常来说applyid应该大于snapshot id，为什么还需要比较？？？
 |-maybeFirstIndex() 如果有snapshot，那么就返回snapshot的下一条记录
 |-FirstIndex() raft/storage.go 如果没有snapshot，尝试从storage中获取 不确认是否是该文件中的实现
   |-MemoryStorage.firstIndex()


raftNode.serveChannels()
 | &lt;&lt;&lt;readyc&gt;&gt;&gt; 等待处理上述的请求
 |-wal.Save() 保存HardState和Entries
 |-
 |-raftNode.entriesToApply() 选取需要提交的日志，也就是rd.CommittedEntries
 |-raftNode.publishEntries() 处理提交的日志，此时会发送到commitC管道中


RestartNode() raft/node.go
 |-newRaft() raft/raft.go
   |-newLog() raft/log.go 对应的Logger接口实现在raft/logger.go文件中定义</code></pre></figure>

-->

<p>在启动时会将已经写入到 WAL 中的数据写入到 Ready CommittedEntries 。</p>

<h2 id="处理流程">处理流程</h2>

<p>RAFT 协议是一种在多节点组成的集群之间进行状态同步的协议，示例是通过 <code>newRaftNode()</code> 新建一个 raftNode 抽象对象，在创建时需要指定其它节点的 IP(peers)、该节点的 ID(id) 等信息。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">main()                                  main.go
  |-make(chan string)                   新建proposeC管道，用来将用户层数据发送给RAFT协议层
  |-make(chan raftpb.ConfChange)        新建confChangeC管道，用来将配置修改信息发送给RAFT协议层
  |-newRaftNode()                       raft.go 返回结构体会作为底层RAFT协议与上层应用的中间结合体
  | |                                       同时会返回commitC errorC管道，用来接收请求和错误信息
  | |-raftNode()                        &lt;&lt;&lt;1&gt;&gt;&gt;新建raftNode对象，重点proposeC
  | |-raftNode.startRaft()              [协程] 启动示例中的代码
  |   |-os.Mkdir()                      如果snapshot目录不存在则创建
  |   |-snap.New()                      snap/snapshotter.go 只是实例化一个对象，并设置其中的dir成员
  |   |-wal.Exist()                     wal/util.go 判断WAL日志目录是否存在，用来确定是否是第一次启动
  |   |-raftNode.replayWAL()            raft.go 开始读取WAL日志，并赋值到raftNode.wal中
  |   | |-raftNode.loadSnapshot()
  |   | | |-snap.Snapshotter.Load()     snap/snapshotter.go 中的Load()函数
  |   | |   |-Snapshotter.snapNames()   会打开目录并遍历目录下的文件，按照文件名进行排序
  |   | |   |-Snapshotter.loadSnap()
  |   | |     |-Snapshotter.Read()      会读取文件并计算CRC校验值，判断文件是否合法
  |   | |-raftNode.openWAL()            打开snapshot，如果不存在则创建目录，否则加载snapshot中保存的值并尝试加载
  |   | | |-wal.Open()                  wal/wal.go 打开指定snap位置的WAL日志，注意snap需要持久化到WAL中才可以
  |   | |   |-wal.openAtIndex()         打开某个snapshot处的日志，并读取之后
  |   | |     |-readWalNames()          wal/util.go读取日志目录下的文件，会检查命名格式
  |   | |     |-searchIndex()           查找指定的index序号
  |   | |-ReadAll()                     读取所有日志，真正开始读取WAL
  |   | |-raft.NewMemoryStorage()       使用ETCD中的内存存储
  |   | |-raft.NewMemoryStorage()       raft/storage.go 新建内存存储
  |   | |---&gt;&gt;&gt;                         从这里开始的三步操作是文档中启动节点前要求的
  |   | |-MemoryStorage.ApplySnapshot() 这里实际上只更新snapshot和新建ents成员，并未做其它操作
  |   | |-MemoryStorage.SetHartState()  更新hardState成员
  |   | |-MemoryStorage.Append()        添加到ents中
  |   | |-raftNode.lastIndex            更新成员变量
  |   |
  |   |-raft.Config{}                   raft/raft.go 构建RAFT核心的配置项，详细可以查看源码中的定义
  |   |-raft.RestartNode()              raft/node.go 如果已经安装过WAL则直接重启Node，这最常见场景
  |   |  |-raft.newRaft()               raft/raft.go
  |   |  | |-raft.becomeFollower()      启动后默认先成为follower 【became follower at term】
  |   |  | |                            返回新建对象 【newRaft】
  |   |  |-newNode()                    raft/node.go 这里只是实例化一个node对象，并未做实际初始化操作
  |   |  |-node.run()                   启动一个后台协程开始运行
  |   |
  |   |-raft.StartNode()                第一次安装，则重新部署
  |   |
  |   |-rafthttp.Transport{}            传输层的配置参数
  |   |-transport.Start()               rafthttp/transport.go 启动HTTP服务
  |   |  |-newStreamRoundTripper()      如下的实现是对http库的封装，保存在pkg/transport目录下
  |   |  | |-NewTimeoutTransport()
  |   |  |   |-NewTransport()
  |   |  |     |-http.Transport{}       调用http库创建实例
  |   |  |-NewRoundTripper()
  |   |-transport.AddPeer()             rafthttp/transport.go 添加对端服务，如果是三个节点，会添加两个
  |   | |-startPeer()                   rafthttp/peer.go 【starting peer】
  |   | | |-pipeline.start()            rafthttp/pipeline.go
  |   | | | |-pipeline.handle()         这里会启动一个协程处理
  |   | | |---&gt;                        【started HTTP pipelining with peer】
  |   | | |-peer{}                      新建对象
  |   | | | |-startStreamWriter()       会启动两个streamWriter
  |   | | |   |-streamWriter.run()      启动协程处理 【started streaming with peer (writer)】
  |   | | |     |  &lt;&lt;&lt;cw.connc&gt;&gt;&gt;
  |   | | |     |-cw.status.active()    与对端已经建立链接【peer 1 became active】
  |   | | |     |---&gt;                  【established a TCP streaming connection with peer (... writer)】
  |   | | |-streamReader.start()        这里会启动msgAppV2Reader、msgAppReader两个streamReader读取
  |   | |   |-streamReader.run()        启动协程处理，这里是一个循环处理 【started streaming with peer (... reader)】
  |   | |---&gt;                          【started peer】
  |   |
  |   |-raftNode.serveRaft()            [协程] 主要是启动网络监听
  |   |-raftNode.serveChannels()        [协程] raft.go 真正的业务处理，在协程中监听用户请求、配置等命令
  |   | |-raftStorage.Snapshot()        获取snapshot
  |   | |-raft.Node.Propose()           阻塞等待该用户请求被RAFT状态机接受
  |   | |-raft.Node.ProposeConfChange() 发送配置请求
  |   |
  |   |-raft.Node.Tick()                另外的协程处理RAFT组件的同步信息
  |
  |-newKVStore()                        kvstore.go 创建内存KV存储结构
  | |-kvstore{}                         实例化KVStore存储对象
  | |-kvstore.readCommits()             会启动一个协程，也是存储的核心，用于读取已经提交的数据
  |   |                                    这里实际上调用了两次，第一次是函数内调用，第二次是协程
  |   |-snapshot.Load()                 第一次commitC中没有数据，实际上是加载snapshot
  |   |-recoverFromSnapshot()           从snapshot中恢复
  |   |                                 接下来是协程的处理
  |   |-gob.NewDecoder()                反序列化
  |   |-kvStore[]                       保存到内存中
  |
  |-serveHttpKVAPI()                    启动对外提供服务的HTTP端口
    |-srv.ListenAndServe()              真正启动客户端的监听服务

一般是定时器超时
raft.Step()
 | &lt;&lt;&lt;pb.MsgHup&gt;&gt;&gt;
 |---&gt;                                  【is starting a new election at term】
 |-raft.campaign()
   |-raft.becomeCandidate()             进入到选举状态，也可以是PreCandidate
   |-raft.poll()                        首先模拟收到消息给自己投票
   |-raft.quorum()                      因为集群可能是单个节点，这里会检查是否满足条件，如果是
   | |-raft.becomeLeader()              如果满足则成为主
   |-raft.send()                        发送选举请求，消息类型可以是MsgPreVote或者MsgVote
   |---&gt;                                【sent MsgVote request】

raft.stepCandidate()
 |-raft.poll()                          【received MsgVoteResp from】
 | |-raft.becomeLeader()                如果满足多数派
 | | |-raft.appendEntry()               添加一个空日志，记录成为主的事件
 | | |---&gt;                              【became leader at term】
 | |-raft.bcastAppend()                 广播发送
 |   |-raft.sendAppend()
 |---&gt;                                  【has received 2 MsgVoteResp votes and 0 vote rejections】

node.run()
 |---&gt;                                  【raft.node ... elected leader at term ...】</code></pre></figure>

<p>其中 <code>RestartNode()</code> 与 <code>StartNode()</code> 的区别在于，前者从日志文件中读取配置，而后者需要从命令行中传参。</p>

<h2 id="初始化">初始化</h2>

<p>启动流程主要分为了三步：</p>

<ol>
  <li>初始化 RAFT</li>
  <li>应用初始化</li>
  <li>应用开启对外服务</li>
</ol>

<p>应用和 RAFT 组件之间是通过 Channel 进行信息传递。</p>

<p>上述的 HTTP 端口中真正处理请求的函数为 <code>ServeHTTP()</code> 函数，下面会挨个介绍。</p>

<!--
raftNode
raftNode是etcd中真正的执行者. 它主要是封装了一个Node的interface在里边，然后围绕这个interface做各种事情. 其中包括：

维护几个主要的数据通道: proposeC, confChangeC, commitC, errorC 等
节点的各种信息: id, peers, index, raftStorage, ...
WAL 的读写
snapshot 读写
状态机的操作等等
其中Node主要用到的一些方法有：

Tick()
Stop()
Advance()
ProposeConfChange(ctx context.Context, cc pb.ConfChange) error
ApplyConfChange(cc pb.ConfChange) *pb.ConfState
Propose(ctx context.Context, data []byte) error
Ready() <-chan Ready
Step(ctx context.Context, msg pb.Message) error
这些函数看名字都大体知道其作用，在这里我们先不细说，下面流程中会依次碰到。
-->

<h3 id="新建raftnode对象">新建raftNode对象</h3>

<p>在初始化时，为了与 RAFT 内的协议层进行通讯，需要提供 4 个 Channel，分别是：</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">proposeC := make(chan string)
confChangeC := make(chan raftpb.ConfChange)
commitC := make(chan *string)
errorC := make(chan error)</code></pre></figure>

<p>其中，前两个在创建 <code>raftNode</code> 前创建传入，就是数据的入口；而后两个则是在创建完成后返回，相当于数据的出口。</p>

<ul>
  <li>proposeC 用于向RAFT协议层提交写请求，也就是 Propose；</li>
  <li>confChangeC 用于向RAFT协议层提交配置变更请求，也就是 ProposeConfChange；</li>
  <li>commitC 把已经提交的entries从RAFT协议层暴露给用户 State Machine；</li>
  <li>errorC 让用户可以及时处理RAFT协议层抛出的错误信息。</li>
</ul>

<h2 id="写数据">写数据</h2>

<p>简单来说就是，用户发送一个 PUT 请求，用来写入 KV 内存数据，可以分为如下步骤。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">http PUT -1-&gt; kvStore.Propose -2-&gt; proposeC -3-&gt; raft -4-&gt; commitC -5-&gt; map[string] string</code></pre></figure>

<p>HTTP 请求数据调用 <code>kvStore.Propose()</code> 方法把请求数据通过 <code>proposeC</code> 管道发送给 RAFT 协议核心，在 RAFT 协议中经过一系列的操作后再把数据通过 <code>commitC</code> 这个管道暴露出来。</p>

<p>初始化时，会启动一个协程来消费 <code>commitC</code> 这个管道，也就是把已经提交的结果最终写入到内存中的 <code>map[string]stringe</code> 里边去。</p>

<!--
需要指出的是用户代码在消费commitC的数据之前，还需要处理raft的snapshot数据. 例子中用的是etcd已经实现好的github.com/coreos/etcd/snap这个包来处理的. 在本例中做的事情其实非常简单，snapshot有正反两个相对的操作: 序列化和反序列化. 例子中直接对内存中的map做json.Marshal(s.kvStore) 和 json.Unmarshal(snapshot, &store)。

整个流程中真正能让我们感兴趣的应该在4. raft, 5. commitC, 以及5->6这几个部分。从这里开始复杂起来了，我们也不得不一步一步在代码中挖下去.
-->

<h3 id="处理流程-1">处理流程</h3>

<p>如上所述，HTTP 真正处理请求是在 <code>ServeHTTP()</code> 函数中，包括了 PUT(增加数据) GET(查看数据) POST(修改配置) DELETE(删除数据) 四种类型的请求处理。</p>

<p>对于客户端的更新请求，首先通过 HTTP 协议传输给应用，目前无法直接处理更新 KVStore，需要先提交至 RAFT 组件在集群内部对本次提交达成一致。也即是，要将这次请求通过 proposeC 管道将请求发送给 raftNode 结构。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">ServeHTTP()                           httpapi.go
  |====&gt; PUT方法
  |-ioutil.ReadAll()                  从HTTP中读取请求
  |-kvstore.Propose()                 kvstore.go 正式提交请求，阻塞直到RAFT状态机提交成功
  | |-glob.NewEncoder()               序列化
  | |-s.proposeC &lt;- buf.String()      通过proposeC管道发送请求到RAFT核心，会阻塞直到返回
  |
  |-http.ResponseWriter.WriteHeader() 返回数据结果
  |
  |====&gt; GET方法
  |-kvstore.Lookup()                  查找并返回数据</code></pre></figure>

<p>在发送到 proposeC 之后，实际上会开始调用 <code>serveChannels()</code> 启动的协程中，然后会一直阻塞直到该请求返回结果。</p>

<p>接下来就是 RAFT 组件的核心处理部分，也即是提供的 <code>Propose()</code> API 接口，这里暂时不讨论。</p>

<h3 id="提交数据">提交数据</h3>

<p>也就是第二步，会调用 raftNode 中的 <code>raftNode.node.Propose()</code> 方法把数据交给 raft 核心处理。</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c1">// raft/node.go</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nx">Propose</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">n</span><span class="p">.</span><span class="nx">step</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">{</span><span class="nx">Type</span><span class="p">:</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgProp</span><span class="p">,</span> <span class="nx">Entries</span><span class="p">:</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">})</span>
<span class="p">}</span></code></pre></figure>

<p>其中的 <code>step</code> 是一个函数指针，根据角色可以是 <code>stepFollower()</code>、<code>stepCandidate()</code>、<code>stepLeader()</code> 等不同的函数，当然这些处理都是在 RAFT 核心中完成的。</p>

<p>在启动之后，实际上会在后台运行一个 long running 的协程，也就是 <code>raft/node.go</code> 中的 <code>run()</code> 方法，核心代码的示例如下。</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nx">run</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span> <span class="c1">// 死循环</span>
		<span class="k">if</span> <span class="nx">advancec</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">readyc</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">rd</span> <span class="p">=</span> <span class="nx">newReady</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">prevSoftSt</span><span class="p">,</span> <span class="nx">prevHardSt</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">rd</span><span class="p">.</span><span class="nx">containsUpdates</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">readyc</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">readyc</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">readyc</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>消息先进入 <code>r.msgs</code> 被 <code>newReady()</code> 函数取走，用户代码通过消费 <code>Ready() &lt;-chan Ready</code> 来处理各种消息。</p>

<!--
之所有消息没有立刻通过commitC暴露给用户的state machine, 就是因为上边我们了解掉的commit的过程。当raft说这个消息已经被commit掉了，它就会以committedEntries身份出现。这时候用户代码需要负责自己把这些committedEntries通过commitC抛给State Machine.
-->

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rc</span> <span class="o">*</span><span class="nx">raftNode</span><span class="p">)</span> <span class="nx">serveChannels</span><span class="p">()</span> <span class="p">{</span>

	<span class="c1">// event loop on raft state machine updates</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
			<span class="nx">rc</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">Tick</span><span class="p">()</span>

		<span class="c1">// store raft entries to wal, then publish over commit channel</span>
		<span class="k">case</span> <span class="nx">rd</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">rc</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">Ready</span><span class="p">():</span>
			<span class="nx">rc</span><span class="p">.</span><span class="nx">wal</span><span class="p">.</span><span class="nx">Save</span><span class="p">(</span><span class="nx">rd</span><span class="p">.</span><span class="nx">HardState</span><span class="p">,</span> <span class="nx">rd</span><span class="p">.</span><span class="nx">Entries</span><span class="p">)</span> <span class="c1">// 保存到持久化存储中</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">raft</span><span class="p">.</span><span class="nx">IsEmptySnap</span><span class="p">(</span><span class="nx">rd</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">rc</span><span class="p">.</span><span class="nx">saveSnap</span><span class="p">(</span><span class="nx">rd</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">)</span>
				<span class="nx">rc</span><span class="p">.</span><span class="nx">raftStorage</span><span class="p">.</span><span class="nx">ApplySnapshot</span><span class="p">(</span><span class="nx">rd</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">)</span>
				<span class="nx">rc</span><span class="p">.</span><span class="nx">publishSnapshot</span><span class="p">(</span><span class="nx">rd</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">rc</span><span class="p">.</span><span class="nx">raftStorage</span><span class="p">.</span><span class="nx">Append</span><span class="p">(</span><span class="nx">rd</span><span class="p">.</span><span class="nx">Entries</span><span class="p">)</span>
			<span class="nx">rc</span><span class="p">.</span><span class="nx">transport</span><span class="p">.</span><span class="nx">Send</span><span class="p">(</span><span class="nx">rd</span><span class="p">.</span><span class="nx">Messages</span><span class="p">)</span>

			<span class="c1">// 通过commitC告诉给下游的用户代码</span>
			<span class="k">if</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">publishEntries</span><span class="p">(</span><span class="nx">rc</span><span class="p">.</span><span class="nx">entriesToApply</span><span class="p">(</span><span class="nx">rd</span><span class="p">.</span><span class="nx">CommittedEntries</span><span class="p">));</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">rc</span><span class="p">.</span><span class="nx">stop</span><span class="p">()</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">rc</span><span class="p">.</span><span class="nx">maybeTriggerSnapshot</span><span class="p">()</span>
			<span class="nx">rc</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">Advance</span><span class="p">()</span>   <span class="c1">// 处理完成需要主动告诉raft</span>

		<span class="k">case</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">rc</span><span class="p">.</span><span class="nx">transport</span><span class="p">.</span><span class="nx">ErrorC</span><span class="p">:</span>
			<span class="nx">rc</span><span class="p">.</span><span class="nx">writeError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>

		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rc</span><span class="p">.</span><span class="nx">stopc</span><span class="p">:</span>
			<span class="nx">rc</span><span class="p">.</span><span class="nx">stop</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// publishEntries writes committed log entries to commit channel and returns</span>
<span class="c1">// whether all entries could be published.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">rc</span> <span class="o">*</span><span class="nx">raftNode</span><span class="p">)</span> <span class="nx">publishEntries</span><span class="p">(</span><span class="nx">ents</span> <span class="p">[]</span><span class="nx">raftpb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ents</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">ents</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Type</span> <span class="p">{</span>
		<span class="c1">// 正常的HTTP PUT会触发一个EntryNormal请求</span>
		<span class="k">case</span> <span class="nx">raftpb</span><span class="p">.</span><span class="nx">EntryNormal</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ents</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// ignore empty messages</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nx">s</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">ents</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Data</span><span class="p">)</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">commitC</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="nx">s</span><span class="p">:</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rc</span><span class="p">.</span><span class="nx">stopc</span><span class="p">:</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>

		<span class="k">case</span> <span class="nx">raftpb</span><span class="p">.</span><span class="nx">EntryConfChange</span><span class="p">:</span>
			<span class="kd">var</span> <span class="nx">cc</span> <span class="nx">raftpb</span><span class="p">.</span><span class="nx">ConfChange</span>
			<span class="nx">cc</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">ents</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Data</span><span class="p">)</span>
			<span class="nx">rc</span><span class="p">.</span><span class="nx">confState</span> <span class="p">=</span> <span class="o">*</span><span class="nx">rc</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">ApplyConfChange</span><span class="p">(</span><span class="nx">cc</span><span class="p">)</span>
			<span class="k">switch</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">Type</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">raftpb</span><span class="p">.</span><span class="nx">ConfChangeAddNode</span><span class="p">:</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nx">rc</span><span class="p">.</span><span class="nx">transport</span><span class="p">.</span><span class="nx">AddPeer</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">ID</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">NodeID</span><span class="p">),</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nb">string</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">Context</span><span class="p">)})</span>
				<span class="p">}</span>
			<span class="k">case</span> <span class="nx">raftpb</span><span class="p">.</span><span class="nx">ConfChangeRemoveNode</span><span class="p">:</span>
				<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">NodeID</span> <span class="o">==</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">rc</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
					<span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;I&#39;ve been removed from the cluster! Shutting down.&quot;</span><span class="p">)</span>
					<span class="k">return</span> <span class="kc">false</span>
				<span class="p">}</span>
				<span class="nx">rc</span><span class="p">.</span><span class="nx">transport</span><span class="p">.</span><span class="nx">RemovePeer</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">ID</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">NodeID</span><span class="p">))</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// after commit, update appliedIndex</span>
		<span class="nx">rc</span><span class="p">.</span><span class="nx">appliedIndex</span> <span class="p">=</span> <span class="nx">ents</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Index</span>

		<span class="c1">// special nil commit to signal replay has finished</span>
		<span class="k">if</span> <span class="nx">ents</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Index</span> <span class="o">==</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">lastIndex</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">commitC</span> <span class="o">&lt;-</span> <span class="kc">nil</span><span class="p">:</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rc</span><span class="p">.</span><span class="nx">stopc</span><span class="p">:</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span></code></pre></figure>

<h2 id="raft-指令处理">RAFT 指令处理</h2>

<p>现在客户端的请求通过 <code>proposeC</code> 管道进入了 RAFT 组件，在数据完成同步之后还是通过 <code>Ready()</code> 暴露给应用，然后由应用负责写日志，完成提交，同步给其它的 Follower 节点等。</p>

<p>也就是如何一步步的处理 RAFT 组件内部的指令请求，同样是在 <code>serveChannels()</code> 中启动的协程。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">func (rc *raftNode) serveChannels() {
    // 上面部分是启动了一个协程处理Propose请求
    // event loop on raft state machine updates
    for {
        select {
        case &lt;-ticker.C:
            rc.node.Tick()

        // 1. 通过Ready()获取到RAFT组件指令
        case rd := &lt;-rc.node.Ready():
            // 2. 写WAL日志，包含的是当前的状态信息
            rc.wal.Save(rd.HardState, rd.Entries)
            if !raft.IsEmptySnap(rd.Snapshot) {
                rc.saveSnap(rd.Snapshot)
                rc.raftStorage.ApplySnapshot(rd.Snapshot)
                rc.publishSnapshot(rd.Snapshot)
            }
            // 3. 这是干什么?
            rc.raftStorage.Append(rd.Entries)
            // 4. 发送给某个Follower
            rc.transport.Send(rd.Messages)
            // 5. 将已经commit的日志提交到应用状态机
            ok := rc.publishEntries(rc.entriesToApply(rd.CommittedEntries))
            if !ok {
                rc.stop()
                return
            }
            rc.maybeTriggerSnapshot()
			// 6. 通知RAFT组件该请求已经处理完成，可以进行下次的请求了
            rc.node.Advance()
        case err := &lt;-rc.transport.ErrorC:
            rc.writeError(err)
            return
        case &lt;-rc.stopc:
            rc.stop()
            return
        }
    }
}</code></pre></figure>

<p>当 RAFT 组件判定已经复制到了多个节点之后，也就是认为已经提交(Commit)，此时 RAFT 组件会通过 commitC 管道将请求返回给应用(KVStore)，应用收到请求后将其应用到状态机，也就是内存中的 KV 存储。</p>

<p>简单来说，通过 <code>readCommits()</code> 接收用户发送的请求并发送给 RAFT 组件；在 RAFT 组件处理完成提交后，再发送给 <code>serveChannels()</code> 继续处理，保存到应用的 KV 存储中。</p>

<h2 id="定时器">定时器</h2>

<p>在 <code>raft/raft.go</code> 中定义了 <code>type Config struct</code> 结构体。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">type Config struct {
	ID uint64                // 本节点的ID，不能为0
	peers []uint64           // 当前集群的所有ID列表，目前仅用来测试
	learners []uint64        // 集群中的Learner列表，仅用来接收Leader节点发送的消息，不会进行投票选举
	ElectionTick int         // 也就是选举的超时时间，单位是Node.Tick；当Follower在当前选举周期内没有
	                         //   收到任何消息时开始变成Candidate开始选举
	HeartbeatTick int Leader // 为了维持其当前的角色发起的心跳请求
}</code></pre></figure>

<p>一般来说要满足 <code>ElectionTick &gt;&gt; HeartbeatTick</code> ，以防一些无必要的主切换，一般为 <code>ElectionTick = 10 * HeartbeatTick</code> 。</p>

<h3 id="定时器创建">定时器创建</h3>

<p>对于 ETCD 来说，在 newRaftNode() 函数中，会新建一个 ticker 时钟触发器，用来产生时钟事件。示例中，会在 <code>raftNode.serveChannels()</code> 中初始化定时器。</p>

<p>对于时间间隔，默认是保存在 <code>embed/config.go</code> 中的 <code>cfg.TickMs</code> ，当然，也可以通过命令行的入参 <code>--heartbeat-interval</code> 指定。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">NewServer()                 etcdserver/server.go
 |-heartbeat                会设置为cfg.TickMs的值，而该值默认在embed/config.go中初始化为100ms
 |-newRaftNode()            etcdserver/raft.go 在该函数中会将相应的heartbeat的值传入
   |-time.NewTicker()       调用time包中提供的函数实现</code></pre></figure>

<p>接着看下这里的配置是如何生效的。</p>

<p>无论是通过 <code>RestartNode()</code> 还是 <code>StartNode()</code> ，最终都会调用 <code>newRaft()</code> 新建一个 raft 对象，其中会将上述的配置分别赋值给 <code>electionTimeout</code> 和 <code>heartbeatTimeout</code> 。</p>

<h3 id="定时器触发">定时器触发</h3>

<p>在 <code>raftNode.start()[etcdserver/raft.go]</code> 中，会等待时钟事件的触发，一次也就是一个 Tick 。</p>

<p>每次 Tick 都需要调用 <code>node.Tick()[raft/node.go]</code> 函数，该函数实际上就是向 tickc 中发送一个空的结构体，用来触发一次心跳事件。</p>

<p>为了防止由于负载过高导致时钟事件丢失，会将管道设置为 128 缓冲。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">raftNode.start()
 | &lt;&lt;&lt;raftNode.ticker.C&gt;&gt;&gt;
 |-node.Tick() 触发tick事件，向tickc中发送一个结构体

node.run() raft/node.go
 | &lt;&lt;&lt;node.tickc&gt;&gt;&gt; 触发了心跳事件
 |-raft.tick() 这里是一个函数指针，不同的角色调用的函数不同
 |=== Leader
 |-raft.tickHeartBeat() 对于Leader会调用该函数
   | 判断是否要发送心跳信息，如果需要则发送MsgBeat类型的消息</code></pre></figure>

<h2 id="日志管理">日志管理</h2>

<p>在实现时，实际上日志 (WAL) 和 Snapshot 已经糅合到了一起，因此在重新构建状态机时必须要两者合作才可以，那么介绍时同样合到一起。</p>

<p>首先需要加载 snapshot 的最新值，然后根据这个 index 在 WAL 目录下查找之后的日志，并回放这些日志即可。</p>

<p>示例使用了 ETCD 提供的通用日志库来进行日志管理，这里重点看下应用层如何使用提供的 WAL 日志模块，其实现后面再详细描述。</p>

<h3 id="日志追加">日志追加</h3>

<p>为了防止数据丢失，在更新之前会先将日志项追加到日志文件中，也就是如下：</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">func (rc *raftNode) serveChannels() {
    ......
    for {
        select {
        case &lt;-ticker.C:
           rc.node.Tick()

        // 正常更新请求,第一步先追加日志
        case rd := &lt;-rc.node.Ready():
            rc.wal.Save(rd.HardState, rd.Entries)
        ......
    }
    ......
}</code></pre></figure>

<h3 id="日志重放">日志重放</h3>

<p>在程序启动时，第一步便是进行日志重放，构建内存状态机。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">func (rc *raftNode) replayWAL() *wal.WAL {
    snapshot := rc.loadSnapshot()
    w := rc.openWAL(snapshot)
    _, st, ents, err := w.ReadAll()
    if err != nil {
        log.Fatalf(&quot;raftexample: failed to read WAL (%v)&quot;, err)
    }
    rc.raftStorage = raft.NewMemoryStorage()
    if snapshot != nil {
        rc.raftStorage.ApplySnapshot(*snapshot)
    }

    rc.raftStorage.SetHardState(st)
    rc.raftStorage.Append(ents)
    if len(ents) &gt; 0 {
        rc.lastIndex = ents[len(ents)-1].Index
    } else {
        rc.commitC &lt;- nil
    }
    return w
}</code></pre></figure>

<!--
因为日志又总是和snapshot搅和在一起的，因此，构建内存状态机必须是Snapshot + 日志一起。

最关键的问题是：由于糅合了snapshot，我们需要明确需要重放哪些日志。在重放日志时，应用程序首先会load最新的snapshot，这个在下面的snapshot管理中会描述。然后根据这个snapshot的日志index在WAL目录下查找该index之后的日志，接下来只需要回放这些日志即可。

日志压缩

日志在追加的过程中可能会一直增长，因此，需要通过一种机制来抑制这种增长，标准做法是snapshot：即将内存当前状态进行压缩成为snapshot存储在文件中，然后，该snapshot之前的日志便可以全部丢弃。

etcd-raft example中如何生成snapshot我们在下面会描述。

在示例应用中好像没有实现日志压缩功能。

## Snapshot

本质上是应用状态的一份拷贝，将状态机当前的状态保存到磁盘上，其主要目的是为了回收日志文件，防止更新日志会越来越大。Snapshot 之前的数据完全可以直接删除，系统重启之后只需要最新的 snapshot 并回放其之后的更新日志即可。

### 创建时机

创建 snapshot 的成本过高，因此不会过于频繁，示例中是没更新 1W 条日志才会创建一次 snapshot 。

maybeTriggerSnapshot()
 |                       首先会判断是否需要进行SnapShot操作
 |-getSnapshot() 这里实际上是一个函数指针，在创建RaftNode时传入
 | |-kvstore.getSnapshot() 调用KVStore中的相应函数，实际会保存所有内存中的数据
 |   |-json.Marshal()
 |-raftStorage.CreateSnapshot() 创建snapshot
 |-saveSnap() 保存
 |-raftStorage.Compact() 用来压缩日志

注意，snapshot 针对的是那些已经被应用到状态机的日志，还未被应用到状态机的更新日志(appliedIndex)是不能被回收的。

在示例应用中，每次进行snapshot后会将snapshot保存在磁盘中，其中包括两方面数据：

snapshot数据：即当前应用内存状态的实际数据，一般被存储在当前的快照目录中；
snapshot索引数据：即当前快照的index信息，这个信息对WAL至关重要，这个index决定了日志压缩的时候哪些可以被回收，也决定了日志重放的时候哪些可以被略过。snapshot索引数据被存放在日志目录下。示例应用好像没有实现日志compact功能。


### 重新加载

readCommits()
 |-recoverFromSnapshot()
   |-json.Unmarshal()

示例实现的代码很简单。

示例应用的snapshot的加载也使用了etcd自身提供的snapshot管理组件，其特点是加载过程中会优先选择最新的snapshot，只有当前snapshot被破坏了才会选择更旧一点的snapshot。


总结

通过上面示例分析，我们了解到，如果应用程序需要使用etcd-raft实现一个分布式系统，就必须要在该library的基础上增加如下子系统：

WAL: 即日志系统，应用程序需要负责日志的append和load；
Snapshot: 负责状态机的定期快照和WAL日志的回收；
应用状态机：实现自己的应用逻辑
raft协议消息的网络收发
而etcd-raft库只是实现了raft协议的核心部分，包括：

选主
多节点一致性语义实现
节点变更
etcd-raft和应用之间是通过channel进行消息的通信，而消息的结构也是由raft库定义好。具体来说，应用通过raft库提供的Ready()接口获取到消息传输管道，并从该管道接收raft库发出的各种指令(Message)，最后再通过Advance()通知raft库命令处理结果。应用处理指令的典型流程是：

将指令写入WAL日志
将指令写入raft组件内存中（为什么要做这个？）
将消息中指定的已经commit的日志进行提交，也即：应用到应用状态机中
调用Advance接口，应该是通知raft当前命令执行完成，可以继续提供下一条指令了。
因此，raft模块所需要完成的工作就相对比较简单了：

为应用准备好需要执行的指令，这些指令是根据raft协议而定义的
应用在执行完成指令后通知raft，raft根据该指令的执行结果（例如，该指令是否已经在多数节点上完成执行）决定是否向前推进commit index，并且，raft会继续向应用准备下一条指令
需要注意的一点是：所有的客户端请求都是直接发往应用的。应用需要将这些请求先提交给raft组件以保证在集群多数节点之间完成数据同步。应用提交的过程其实就是调用raft模块的Propose()接口。



## 等待提交


每次启动之后，及时没有发送数据也会调用 readCommits() 接口？？？？？
为什么会有这么多的readyc数据，都是啥啊？？？？

newKVStore() kvstore.go
 |-kvstore.readCommits() 等待已经提交的数据，也就是阻塞在commitC管道中

serveChannels() raft.go
 | <<<readyc>>>
 |-raftNode.publishEntries() raft.go 这里会将数据发送到commitC管道中

那么 readyc 中的数据又是从何而来，为什么会在启动时就已经有数据的提交了。

实际上，本地启动之后，在与集群的其它节点建立链接之前，已经有 snapshot 之后 WAL 中的数据会在自己的节点中提交，并应用到日志中。














在WAL.sync()[wal/wal.go]中有实现磁盘刷新统计的功能，不过暂时不太确认实现原理
https://github.com/prometheus/client_golang/
https://www.cnblogs.com/gaorong/p/7881203.html


### 创建时机

示例中的 SnapShot 实际上使用的是 raft.MemoryStorage 中的实现，也就是 rc.raftStorage 实际上就是 MemoryStorage 的实现。

maybeTriggerSnapshot()
 |                       首先会判断是否需要进行SnapShot操作
 |-getSnapshot() 这里实际上是一个函数指针，在创建RaftNode时传入
 | |-kvstore.getSnapshot() 调用KVStore中的相应函数，实际会保存所有内存中的数据
 |   |-json.Marshal()
 |-MemoryStorage.CreateSnapshot() raft/storage.go 创建snapshot
 | |- 第一个入参一般是AppliedIndex，此时会根据Index判断是否需要执行SnapShot
 |-saveSnap() 保存
 | |-WAL.SaveSnapshot() 先保存一条WAL日志数据
 | | |-WAL.sync()
 | |-Snapshotter.SaveSnap() snap/snapshotter.go
 | | |-raft.IsEmptySnap() 判断是否为空的snap
 | | |-Snapshotter.save()
 | |   |-crc32.Update() 计算CRC32校验值
 | |   |-WriteAndSyncFile() 然后写入到文件中
 | |-wal.ReleaseLockTo() 这里会释放不需要的文件锁
 |-MemoryStorage.Compact() 用来压缩日志，实际上就是删除内存中不需要的缓存日志

CreateSnapshot() 主要用来判断此时的日志序号是否合法(大于上次SnapShot且小于最新)，然后更新 `snapshot` 中的 `Metadata` 以及 `Data` 。


注意，在调用 Snapshotter.Load()[snap/snapshotter.go] 时，实际上循环遍历所有的 snap 文件，并进行校验，而真正返回的是最后一个文件。

* 开发环境
* 应用场景
* V3接口使用
* RAFT协议介绍
* 安全性(用户密码、通讯协议)
* 网络通讯
* 存储引擎
* RAFT核心(数据CURD)
* RAFT核心(配置修改)
* 运维、监控
* 杂七杂八

### 健康检查

在启动时会通过参数 `--initial-cluster` 指定当前整个集群的内部通讯接口，默认会启动一堆的 REST API 用于通讯，常见的有：


----- 在启动之后会启动一个协程用来探测服务是否正常
curl http://127.0.0.1:22379/raft/probing

在提交完之后，

linearizableReadLoop

## 杂七杂八

### 启动停止

### goAttach()
EtcdServer.Start() etcdserver/server.go
 |-linearizableReadLoop()

以在集群中添加主机为例，需要执行如下操作。

$ curl -L http://127.0.0.1:12380/4 -XPOST -d http://127.0.0.1:42379
$ raftexample --id 4 --port 42380 --join \
			--cluster http://127.0.0.1:12379,http://127.0.0.1:22379,http://127.0.0.1:32379,http://127.0.0.1:42379

在 `ServeHTTP()[httpapi.go]` 中会执行配置修改的操作，简单构建配置请求，并发送给 `confChangeC` 管道。

然后在 `serveChannels()[raft.go]` 中处理管道对应的请求。

serveChannels()
 |-ProposeConfChange() raft/node.go

一台主机宕机之后，会调用 deactivate() rafthttp/peer_status.go 函数。
## 宕机

health check for peer

AddPeer()
addPeerToProber()
monitorProbingStatus()

rafthttp/probing_status.go

-->

<h2 id="其它">其它</h2>

<h3 id="bugfix">BugFix</h3>

<p>如果直接运行示例会发现日志的格式有所区别。</p>

<p>实际上，在 <code>etcdserver/raft.go</code> 文件中，有定义 <code>init()</code> 函数用于设置默认的 logger，也就是 <code>raft.SetLogger()</code> 的处理。</p>

<p>在 <code>raftexample/raft.go</code> 中增加 <code>init()</code> 函数，然后添加如下内容即可。</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">raft</span><span class="p">.</span><span class="nx">SetLogger</span><span class="p">(</span><span class="nx">capnslog</span><span class="p">.</span><span class="nx">NewPackageLogger</span><span class="p">(</span><span class="s">&quot;github.com/coreos/etcd&quot;</span><span class="p">,</span> <span class="s">&quot;raft&quot;</span><span class="p">))</span>
<span class="p">}</span></code></pre></figure>

<h2 id="参考">参考</h2>

<!--
https://zhuanlan.zhihu.com/distributed-storage

RAFT C语言的实现
https://github.com/willemt/raft

Leader election
Log replicationLog compaction
Membership changesLeader transfer
Linearizable/Lease read


基本流程是？
优化点包含了哪些？
核心处理流程：A) AppendLog；B) 选主；C) Snapshot；D) 成员变更等。
存储的接口通过 type Storage interface 指定，其中示例中直接使用了库中的 MemoryStorage 实现，每次从 WAL 和 Snapshot 中读取并恢复到内存中。

https://www.jianshu.com/p/27329f87c104
https://bbs.huaweicloud.com/blogs/f65bc75d3ba811e89fc57ca23e93a89f
-->


  <hr>
  <nav>
    <ul class="pager">
         <li class="previous"><a href="/post/program-c-fuzzing-test-introduce.html" title="Fuzzing 测试">&larr; Older</a></li> 
         <li class="next"><a href="/post/theme-database-etcd.html" title="【专题】Etcd 数据库">Newer &rarr;</a></li> 
    </ul>
  </nav><br>
<!--
  <hr><div id="section-donate"><span>赏</span></div><br>
  <p style="text-indent:0px;text-align:center;">如果喜欢这里的文章，而且又不差钱的话，欢迎打赏个早餐 ^_^</p><br>
  <div class="row" style="text-align:center;" >
    <div class="col-md-6"><img src="/images/system/barcode-pay-alipay.jpg" style="width:150px;height:150px;" title="支付宝捐赠" /><br>支付宝打赏</div>
    <div class="col-md-6"><img src="/images/system/barcode-pay-wechat.jpg" style="width:150px;height:150px;" title="微信捐赠" /><br>微信打赏</div>
  </div><br><hr>
-->
  <p style="text-indent:0px;text-align:center;">如果喜欢这里的文章，而且又不差钱的话，欢迎打赏个早餐 ^_^</p>
  <div id="donate_module">
    <style type="text/css">
      .donate_bar a.btn_donate{
        display: inline-block;
        position:      relative;
        text-align:    center;
        width: 82px;
        height: 82px;
        background: url("/images/misc/btn_reward.gif") no-repeat;
        _background: url("/images/misc/btn_reward.gif") no-repeat;
        -webkit-transition: background 0s;
        -moz-transition: background 0s;
        -o-transition: background 0s;
        -ms-transition: background 0s;
        transition: background 0s;
      }
      .donate_bar a.btn_donate:hover{ background-position: 0px -82px;}
      .donate_bar .donate_txt {
        display: block;
        color: #9d9d9d;
        font: 14px/2 "Microsoft Yahei";
      }
    </style>
    <div id="donate_board" class="donate_bar row" style="text-align:center;" >
      <a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏"></a>
    </div>
    <div id="donate_guide" class="donate_bar center hidden">
      <div class="row" style="text-align:center;" >
        <div class="col-md-6"><img src="/images/system/barcode-pay-alipay.jpg" style="width:150px;height:150px;" title="支付宝捐赠" /><br>支付宝打赏</div>
        <div class="col-md-6"><img src="/images/system/barcode-pay-wechat.jpg" style="width:150px;height:150px;" title="微信捐赠" /><br>微信打赏</div>
      </div>
    </div>
    <script type="text/javascript">
      document.getElementById('btn_donate').onclick = function(){
        $('#donate_board').addClass('hidden');
        $('#donate_guide').removeClass('hidden');
      }
      function donate_on_web(){
        $('#donate').submit();
      }
    </script>
  </div>

  <hr>

  <div id="gitmentContainer"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
  var gitment = new Gitment({
      id: '1509811200',
      owner: 'Jin-Yang',
      repo: 'jin-yang.github.com',
      oauth: {
          client_id: '6d89d48ce689192bf95d',
          client_secret: 'c9a720aafb8e3084e3feb46cadee80b03cdc792f',
      },
  });
  gitment.render('gitmentContainer');
  </script>

  <!-- 多说评论框 start -->
  <!--<div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>-->
  <!--
  <div class="ds-thread" data-thread-key="/post/golang-raft-etcd-example-sourcode-details.html" data-title="ETCD 示例源码" data-url="/post/golang-raft-etcd-example-sourcode-details.html"></div>
  -->
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <!--
  <script type="text/javascript">
      var duoshuoQuery = {short_name:"jinyangposts"};
      (function() {
          var ds = document.createElement('script');
          ds.type = 'text/javascript';ds.async = true;
          ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
          ds.charset = 'UTF-8';
          (document.getElementsByTagName('head')[0]
           || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
  </script>
  -->
  <!-- 多说公共JS代码 end -->
</div>

    </div>
    <div class="col-lg-3 visible-lg blog-sidebar">
    <center><a href="/"><img src="/images/system/linux-liberty.png" width="200" /></a></center>
<h2>About This Blog</h2>
<div class="sidebar-module">
<p style="text-indent:0em;margin:0px;padding:0px;">This is a personal weblog ^_^ generated with Jekyll, if you like it or have some questions,
just feel free to contact me :)</p>
</div><!-- end of "node" "about" -->



<h2>Recent Posts</h2>
<div class="list-group">
  
    <a class="list-group-item" href="/post/linux-program-cpu-cache-introduce_init.html">CPU Cache</a>
  
    <a class="list-group-item" href="/post/artificial-intelligence-decision-tree-introduce.html">决策树</a>
  
    <a class="list-group-item" href="/post/linux-ebpf-bcc-tools-introduce.html">BCC 工具使用</a>
  
    <a class="list-group-item" href="/post/linux-ebpf-basic-usage-introduce.html">eBPF 简介</a>
  
    <a class="list-group-item" href="/post/math-monte-carlo-sample-introduce.html">采样算法</a>
  
</div>

<h2>Categories</h2>
<ul class="list-group" style="margin:0px;">
  
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#bash"> bash</a>
    <span class="badge">2</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#database"> database</a>
    <span class="badge">86</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#golang"> golang</a>
    <span class="badge">28</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#linux"> linux</a>
    <span class="badge">301</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#misc"> misc</a>
    <span class="badge">244</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#mysql"> mysql</a>
    <span class="badge">79</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#network"> network</a>
    <span class="badge">49</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#postgresql"> postgresql</a>
    <span class="badge">4</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#program"> program</a>
    <span class="badge">138</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#python"> python</a>
    <span class="badge">25</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#react"> react</a>
    <span class="badge">1</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#rtems"> rtems</a>
    <span class="badge">1</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#sql"> sql</a>
    <span class="badge">10</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#tools"> tools</a>
    <span class="badge">1</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#webserver"> webserver</a>
    <span class="badge">25</span>
  </li>
  
</ul><!-- end of "node" "categories" -->

<h2>Related Links</h2>
<ul class="list-group" style="margin:0px">
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
       <a href="http://www.rtems.org" title="To RTEMS"><img class="img-thumbnail img-responsive" src="/images/system/rtems.png"  alt="RTEMS"/></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>RTEMS</strong><br>
        <div class="sidebar-description">Real-Time Executive for Multiprocessor System</div>
      </div>
    </div>
  </li>
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
       <a href="http://www.gnu.org" title="To GNU">
       <img class="img-thumbnail img-responsive" src="/images/system/gnu.jpg" alt="GNU" /></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>GNU</strong><br>
        <div class="sidebar-description">A Unix-linux Operating System</div>
      </div>
    </div>
  </li>
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
    <a href="http://www.kernel.org" title="To Linux Kernel">
    <img class="img-thumbnail img-responsive" src="/images/system/linux.png"  alt="LINUX" /></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>Linux Kernel</strong><br>
        <div class="sidebar-description">Maintained by Linux Kernel Organization</div>
      </div>
    </div>
  </li>
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
    <a href="http://arduino.cc" title="To Arduino">
    <img class="img-thumbnail img-responsive" src="/images/system/arduino.png"  alt="ARDUINO" /></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>Arduino</strong><br>
        <div class="sidebar-description">Open-source Electronic Prototyping Platform</div>
      </div>
    </div>
  </li>
</ul>

<h2>Search</h2>
<div class="sidebar-module">
  <form class="search" method="GET" action="https://www.google.com.hk/search">
    <input type="text" name="q" class="search-query" placeholder=" Search on Google">
    <input type="hidden" name="ie" value="utf-8">
    <input type="submit" name="sa" value="Search" />
  </form><br>
  <input type="text" class="search-field" placeholder=" Search This Site">
  <div class="search-results"></div>
</div>



    </div>
  </div>
<hr><p class="text-center">This Site was built by Jin Yang, generated with Jekyll, and hosted on GitHub Pages<br/> &copy;2013-2019 &ndash; Jin Yang</p><div class="footer-logo"></div>

</div>
</body>
</html>
