<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="baidu-site-verification" content="B786jeR0MV" />
  <meta name="msvalidate.01" content="29F791E7F785800340E37AD7C714D2A7" />
  <meta name="google-site-verification" content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0" />
  <title>Linux 网络半链接、链接队列|JinYang's Blog</title>
  <meta name="keywords" content="linux,network,网络,链接,半链接,队列">
  <meta name="description" content="我们知道在建立链接阶段，需要完成三次握手，而这一阶段是在内核中完成，为此保存了两个队列：半链接队列 (SYN队列)、链接队列 (Accepted队列)。 那么，这两个队列分别对应到内核中的那些成员？队列的大小由那些参数决定？当队列满了之后，对应用的影响是什么？其报错的内容是什么？ 在这篇文章里大致介绍下。">

  <script src="https://cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>
  <script type="text/javascript">
  !window.jQuery && document.write('<script src="/static/js/jquery.min.js"><\/script>');
  </script>
  <script src="https://cdn.bootcss.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
  <script type="text/javascript">
  !$('body').popover && document.write('<script src="/static/js/bootstrap.min.js"><\/script>');
  </script>
  <script type="text/javascript" src="/static/js/main.js"></script>
  <!-- <link rel="stylesheet prefetch" href="http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css"> -->
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/bootstrap.min.css">
  <!-- <link href="http://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/font-awesome.min.css">
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/pygments.css">
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/screen.css">
  <style type="text/css">
  
    .post-container > p {text-indent: 2em;}
  
  </style>
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-124556620-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-124556620-1');
</script>

</head>

<body>
<nav class="navbar navbar-default navbar-inverse navbar-fixed-top navbar-wrapper">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span>
      </button><a class="navbar-brand" href="/">Jin-Yang</a>
    </div>
    <div id="navbar" class="collapse navbar-collapse">
      <ul class="nav navbar-nav">
        <li  ><a href="/"> Home </a></li>
        <li  ><a href="/archives.html"> Archive </a></li>
        <li  ><a href="/categories.html"> Categories </a></li>
        <li  ><a href="/projects.html"> Projects </a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"> Others <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li class="dropdown-header">常用网站</li>
            <li role="separator" class="divider"></li>
            <li><a href="https://www.rtems.org/">www.rtems.org</a></li>
            <li><a href="http://www.gnu.org/">www.gnu.org</a></li>
            <li><a href="https://www.kernel.org/">www.kernel.org</a></li>
            <li><a href="https://www.arduino.cc/">www.arduino.cc</a></li>
          </ul>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li  ><a href="/about.html"> About </a></li>
      </ul>
    </div><!--/.nav-collapse -->
  </div>
</nav>

<div id="myCarousel" class="carousel slide" data-ride="carousel">
  <!-- Indicators -->
  <ol class="carousel-indicators">
    <li data-target="#myCarousel" data-slide-to="0" class="active"></li>
    <li data-target="#myCarousel" data-slide-to="1"></li>
    <li data-target="#myCarousel" data-slide-to="2"></li>
    <li data-target="#myCarousel" data-slide-to="3"></li>
    <li data-target="#myCarousel" data-slide-to="4"></li>
  </ol>
  <div class="carousel-inner" role="listbox">
    <div class="item active">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>KISS</h1>
          <h2>Keep It Simple and Stupid.</h2>
          <!--<a class="btn btn-lg btn-primary" href="#" role="button">Sign up today</a>-->
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Seize The Day</h1><h1>And Get Busy Living</h1>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Stay hungry</h1><h1>Stay foolish</h1>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
	  <h2>Ever tried, ever failed</h2><h2>No matter, try again</h2><h2>Fail again, fail better</h2>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Nothing is true</h1><h1>Every is permitted</h1>
        </div>
      </div>
    </div>
  </div>
  <a class="left carousel-control" href="#myCarousel" role="button" data-slide="prev">
    <span class="glyphicon glyphicon-chevron-left"></span>
    <span class="sr-only">Previous</span>
  </a>
  <a class="right carousel-control" href="#myCarousel" role="button" data-slide="next">
    <span class="glyphicon glyphicon-chevron-right"></span>
    <span class="sr-only">Next</span>
  </a>
</div><!-- /.carousel -->

<div class="container">
  <div class="row">
    <div class="col-lg-9 blog-main" style="min-width: 500px">
    
<div class="post-container">
  <div class="blog-header">
    <h1>Linux 网络半链接、链接队列</h1>
    <div class="post-description">
      <i class="fa fa-calendar"></i> 2015-08-05 Wednesday &nbsp; &nbsp;
      <i class="fa fa-tags"></i>  linux ,  network  
      
    </div>
  </div>
  <hr>
  <p>我们知道在建立链接阶段，需要完成三次握手，而这一阶段是在内核中完成，为此保存了两个队列：半链接队列 (SYN队列)、链接队列 (Accepted队列)。</p>

<p>那么，这两个队列分别对应到内核中的那些成员？队列的大小由那些参数决定？当队列满了之后，对应用的影响是什么？其报错的内容是什么？</p>

<p>在这篇文章里大致介绍下。</p>

<!-- more -->

<h2 id="简介">简介</h2>

<p>Linux 内核中的协议栈，在管理 TCP 链接时使用了两个队列，包括：半链接队列，用来保存处于 SYN_SENT 和 SYN_RECV 状态的请求；Accepted 队列，用来保存已经处于 established 状态，但是应用层还没来得及调用 accept() 取走的请求。</p>

<p>对这两个队列比较关心的，也就是这两队列在内核中的对象是什么，其长度又是怎么定义的。</p>

<p>注意，这两个队列都是在服务端的，而我们监听端口的建立是通过 listen() 完成，基本可以判断出来，两个队列的初始化操作也基本在该接口中调用完成。</p>

<p>所以首先看的是 listen() 系统调用。</p>

<h2 id="listen---队列的初始化">listen() - 队列的初始化</h2>

<p>首先开始讨论的是 backlog 参数，英语中的原意是 “积压未办之事；没交付的订货” 。</p>

<p>讨论 backlog 时，容易想到 socket 编程中 <code>listen()</code> 接口的 backlog 参数，而该参数与 Linux 内核中的 backlog 是否一样？通过 <code>man 2 listen</code> 可以看到，对应该接口中 backlog 的解释如下。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">int listen(int sockfd, int backlog);

The backlog argument defines the maximum length to which the queue
of pending connections for sockfd may grow. If a connection request
arrives when the queue is full, the client may receive an error with
an indication of ECONNREFUSED or, if the underlying protocol supports
retransmission, the request may be ignored so that a later reattempt
at connection succeeds.</code></pre></figure>

<p>这里的解释非常简短，对于我们的帮助实际并不是很大，还是那句话 “Show me the CODE!!!” 。</p>

<p>首先是 listen() 系统调用的入口，按照上述的说法，可以想像的到，listen() 系统调用必然要分配一个 listen_sock 结构体。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">listen</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">somaxconn</span><span class="p">;</span>

    <span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* backlog 会选择 listen() 传入的参数与 net.core.somaxconn 的最小值 */</span>
        <span class="n">somaxconn</span> <span class="o">=</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">core</span><span class="p">.</span><span class="n">sysctl_somaxconn</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">backlog</span> <span class="o">&gt;</span> <span class="n">somaxconn</span><span class="p">)</span>
            <span class="n">backlog</span> <span class="o">=</span> <span class="n">somaxconn</span><span class="p">;</span>

        <span class="n">err</span> <span class="o">=</span> <span class="n">security_socket_listen</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">backlog</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
            <span class="cm">/* 实际会调用 inet_listen() */</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">listen</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">backlog</span><span class="p">);</span>

        <span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>也就是取得入参与 somaxconn 的最小值后，调用 inet_listen() 函数，在该函数中会初始化半链接队列，并设置 accepted 队列的最大值。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">inet_listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="cm">/* 如果已经处于 listen 状态了，那么之修改 backlog */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">old_state</span> <span class="o">!=</span> <span class="n">TCP_LISTEN</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span> <span class="p">...</span>                        <span class="c1">// fastopen相关暂时忽略</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">inet_csk_listen_start</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">backlog</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_max_ack_backlog</span> <span class="o">=</span> <span class="n">backlog</span><span class="p">;</span>  <span class="c1">// 设置accept队列的最大值</span>
    <span class="p">...</span> <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>接着来看 inet_csk_listen_start() 函数的实现，其主要工作是调用 reqsk_queue_alloc() 新分配一个 listen socket 以及相应的 accept 队列；然后对申请的端口进行判断。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">inet_csk_listen_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">nr_table_entries</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="c1">// 在下面的函数中分配listen_sock以及相应的accept队列</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">reqsk_queue_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_accept_queue</span><span class="p">,</span> <span class="n">nr_table_entries</span><span class="p">);</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="c1">// 这里之所以还要再次判断一下端口，是为了防止另一个进程 程在我们调用listen之前改变了这个端口的信息.</span>
    <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">TCP_LISTEN</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">get_port</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_num</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 将端口赋值给sport，并加入到inet_hashinfo(上面已经分析过)的listening_hash hash链表中.</span>
        <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_sport</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_num</span><span class="p">);</span>

        <span class="n">sk_dst_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
        <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>  <span class="c1">// 这里调用__inet_hash实现的</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span> <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>对于半链接队列，实际是在 reqsk_queue_alloc() 中完成，在该函数中同样会完成 listen_sock 新建。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">reqsk_queue_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_sock_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span>
              <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_table_entries</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">lopt_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">listen_sock</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">listen_sock</span> <span class="o">*</span><span class="n">lopt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">nr_table_entries</span> <span class="o">=</span> <span class="kt">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">nr_table_entries</span><span class="p">,</span> <span class="n">sysctl_max_syn_backlog</span><span class="p">);</span>
    <span class="n">nr_table_entries</span> <span class="o">=</span> <span class="kt">max_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">nr_table_entries</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">nr_table_entries</span> <span class="o">=</span> <span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">nr_table_entries</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">lopt_size</span> <span class="o">+=</span> <span class="n">nr_table_entries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">lopt_size</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_ALLOC_COSTLY_ORDER</span><span class="p">))</span>
        <span class="n">lopt</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">lopt_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span>
                      <span class="n">__GFP_NOWARN</span> <span class="o">|</span>
                      <span class="n">__GFP_NORETRY</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lopt</span><span class="p">)</span>
        <span class="n">lopt</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">lopt_size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lopt</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

    <span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lopt</span><span class="o">-&gt;</span><span class="n">hash_rnd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lopt</span><span class="o">-&gt;</span><span class="n">hash_rnd</span><span class="p">));</span>
    <span class="n">rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">syn_wait_lock</span><span class="p">);</span>
    <span class="n">queue</span><span class="o">-&gt;</span><span class="n">rskq_accept_head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">lopt</span><span class="o">-&gt;</span><span class="n">nr_table_entries</span> <span class="o">=</span> <span class="n">nr_table_entries</span><span class="p">;</span>
    <span class="n">lopt</span><span class="o">-&gt;</span><span class="n">max_qlen_log</span> <span class="o">=</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">nr_table_entries</span><span class="p">);</span>

    <span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">syn_wait_lock</span><span class="p">);</span>
    <span class="n">queue</span><span class="o">-&gt;</span><span class="n">listen_opt</span> <span class="o">=</span> <span class="n">lopt</span><span class="p">;</span>
    <span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">syn_wait_lock</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>实际上，如果 listen(…, 20)，且内核参数值如下，那么此时 nr_table_entries = 16、max_qlen_log = 4 。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ sysctl -w net.ipv4.tcp_max_syn_backlog=2
$ sysctl -w net.core.somaxconn=3</code></pre></figure>

<p>但是，对于一个 <code>listen sock</code>，我们真的能保存 16 个 <code>SYN_RCV</code> 状态的链接吗？答案是 “不能” 。</p>

<h3 id="数据结构">数据结构</h3>

<p>上面介绍了两个队列的创建过程，接下来再看下相关的数据结构。擦，有点本末倒置 ^_^</p>

<p>每当一个 SYN 请求到来时，都会新建一个 request_sock 结构体，并加入到 listen_sock.request_sock 的 hash 表中。完成握手后，将它放入到 inet_connection_sock.request_sock_queue 队列中；这样当 accept() 函数调用时，就会直接从这个队列中读取。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">request_sock</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">sock_common</span>      <span class="n">__req_common</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">request_sock</span>     <span class="o">*</span><span class="n">dl_next</span><span class="p">;</span>
    <span class="n">u16</span>             <span class="n">mss</span><span class="p">;</span>
    <span class="n">u8</span>              <span class="n">num_retrans</span><span class="p">;</span> <span class="cm">/* number of retransmits */</span>
    <span class="n">u8</span>              <span class="nl">cookie_ts</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* syncookie: encode tcpopts in timestamp */</span>
    <span class="n">u8</span>              <span class="nl">num_timeout</span><span class="p">:</span><span class="mi">7</span><span class="p">;</span> <span class="cm">/* number of timeouts */</span>
    <span class="cm">/* The following two fields can be easily recomputed I think -AK */</span>
    <span class="n">u32</span>             <span class="n">window_clamp</span><span class="p">;</span> <span class="cm">/* window clamp at creation time */</span>
    <span class="n">u32</span>             <span class="n">rcv_wnd</span><span class="p">;</span>      <span class="cm">/* rcv_wnd offered first time */</span>
    <span class="n">u32</span>             <span class="n">ts_recent</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">expires</span><span class="p">;</span>     <span class="c1">// 这个请求在队列中存活的时间</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock_ops</span>   <span class="o">*</span><span class="n">rsk_ops</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sock</span>         <span class="o">*</span><span class="n">sk</span><span class="p">;</span>             <span class="c1">// 链接成功的socket数目???</span>
    <span class="n">u32</span>             <span class="n">secid</span><span class="p">;</span>
    <span class="n">u32</span>             <span class="n">peer_secid</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">listen_sock</span> <span class="p">{</span>
    <span class="n">u8</span>          <span class="n">max_qlen_log</span><span class="p">;</span>
    <span class="n">u8</span>          <span class="n">synflood_warned</span><span class="p">;</span>
    <span class="cm">/* 2 bytes hole, try to use */</span>
    <span class="kt">int</span>         <span class="n">qlen</span><span class="p">;</span>                               <span class="c1">// 当前的半连接队列的长度</span>
    <span class="kt">int</span>         <span class="n">qlen_young</span><span class="p">;</span>                         <span class="c1">// 队列新成员的个数</span>
    <span class="kt">int</span>         <span class="n">clock_hand</span><span class="p">;</span>
    <span class="n">u32</span>         <span class="n">hash_rnd</span><span class="p">;</span>
    <span class="n">u32</span>                 <span class="n">nr_table_entries</span><span class="p">;</span>                   <span class="c1">// 当前的syn_backlog(半开连接队列)的最大值</span>
    <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">syn_table</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>              <span class="c1">// 存放SYN队列，也即半链接队列</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">request_sock_queue</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">request_sock</span>       <span class="o">*</span><span class="n">rskq_accept_head</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">request_sock</span>       <span class="o">*</span><span class="n">rskq_accept_tail</span><span class="p">;</span>
    <span class="kt">rwlock_t</span>                  <span class="n">syn_wait_lock</span><span class="p">;</span>
    <span class="n">u8</span>                        <span class="n">rskq_defer_accept</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">listen_sock</span>        <span class="o">*</span><span class="n">listen_opt</span><span class="p">;</span>          <span class="c1">// 对应的listen_sock结构体</span>
    <span class="k">struct</span> <span class="n">fastopen_queue</span>     <span class="o">*</span><span class="n">fastopenq</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">inet_sock</span>          <span class="n">icsk_inet</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">request_sock_queue</span> <span class="n">icsk_accept_queue</span><span class="p">;</span>    <span class="c1">// 已经建立链接的FIFO队列</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="n">__u8</span>                      <span class="n">icsk_syn_retries</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span>             <span class="n">icsk_timeout</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">timer_list</span>         <span class="n">icsk_retransmit_timer</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">timer_list</span>         <span class="n">icsk_delack_timer</span><span class="p">;</span>
    <span class="n">u32</span>                       <span class="n">icsk_user_timeout</span><span class="p">;</span>
    <span class="p">...</span> <span class="p">...</span>
<span class="p">};</span></code></pre></figure>

<!--
    struct listen_sock {
         u8           max_qlen_log;
    /*qlen最大长度取对数log，即log2 (max_qlen)，这个值在进入SYN/ACK定时器时有用*/
        int          qlen_young;
    /*也是指当前的半开连接队列长度,不过这个值会当重传syn/ack的时候(这里要注意是这个syn/ack第一次重传的时候才会减一)自动减一，也就是重传了SYN/ACK的request_sock不在是新的request_sock，在SYN/ACK定时器时有用*/

        int          clock_hand;
    /*每次SYN-ACK定时器超时时，我们需要遍历SYN队列哈希表，但表太大了，所以每次都只遍历部分哈希表，而每次遍历完，将哈希索引值放在clock_hand这里，下次遍历时直接从clock_hand开始，而不用从头开始*/
         u32          hash_rnd;
    };
-->

<p>上述的结构体中，只包括了半链接的队列长度，而对于 accept 队列的长度，实际保存在 sock 结构体中。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">sock</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">short</span>      <span class="n">sk_ack_backlog</span><span class="p">;</span>     <span class="c1">// 队列长度</span>
    <span class="kt">unsigned</span> <span class="kt">short</span>      <span class="n">sk_max_ack_backlog</span><span class="p">;</span> <span class="c1">// 最大的队列长度</span>
<span class="p">};</span></code></pre></figure>

<p>该 sock 是 server 端的 listen 队列长度，而 client 只保留成 request_sock 。</p>

<p>最后，当 accept() 从 icsk_accept_queue 队列中取得 request_sock 之后，将该变量从这个队列中释放，然后在 BSD 层新建一个 socket 结构，并将它和接收端新建的 sock 结构关联起来。</p>

<h3 id="accept-系统调用">accept() 系统调用</h3>

<p>最终调用的是 inet_csk_accept() 函数，该函数会调用 reqsk_queue_get_child() 从 accept 队列中取一个 request_sock。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">inet_csk_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">request_sock_queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_accept_queue</span><span class="p">;</span>
    <span class="c1">// 查找已经建立的链接</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">reqsk_queue_empty</span><span class="p">(</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">long</span> <span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_rcvtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>

        <span class="cm">/* If this is a non blocking socket don&#39;t sleep */</span>
        <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeo</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

        <span class="n">error</span> <span class="o">=</span> <span class="n">inet_csk_wait_for_connect</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">timeo</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">req</span> <span class="o">=</span> <span class="n">reqsk_queue_remove</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
    <span class="n">newsk</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

    <span class="n">sk_acceptq_removed</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<h2 id="源码解析">源码解析</h2>

<p>内核中与队列相关的设置参数如下：</p>

<ul>
  <li>
    <p>net.ipv4.tcp_max_syn_backlog[256]：用于保存半链接队列。注意，如果开启了 syncookies，那么基本上没有限制，所以在如下的实验中要关闭 cookies 。</p>
  </li>
  <li>
    <p>net.core.somaxconn[128]：Accepted 队列最大长度，表示最多有 129 个 established 链接等待 accept()。</p>
  </li>
</ul>

<h3 id="握手过程">握手过程</h3>

<p>如上所述，握手链接过程包括了如下的步骤：</p>

<ol>
  <li>收到客户端的 SYN 请求，并将这个请求放入 syn_table 中去；</li>
  <li>服务器端回复 SYNACK；</li>
  <li>收到客户端的 ACK；</li>
  <li>放入 accept queue 中。</li>
</ol>

<p>对于 IPv4 来说，对应的操作函数通过如下结构体定义：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock_af_ops</span> <span class="n">ipv4_specific</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="p">.</span><span class="n">conn_request</span>      <span class="o">=</span> <span class="n">tcp_v4_conn_request</span><span class="p">,</span>   <span class="c1">// 对应收到SYN请求</span>
    <span class="p">.</span><span class="n">syn_recv_sock</span>     <span class="o">=</span> <span class="n">tcp_v4_syn_recv_sock</span><span class="p">,</span>  <span class="c1">// 对应收到ACK请求</span>
    <span class="p">...</span> <span class="p">...</span>
<span class="p">};</span></code></pre></figure>

<p>接下来查看各个阶段的内容。</p>

<h3 id="客户端发送-syn-请求报文到服务端">客户端发送 SYN 请求报文到服务端</h3>

<p>此时，客户端和服务端分别处于 SYN_SENT 和 SYN_RECV 状态。</p>

<p>其中服务端的处理流程如下：</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">tcp_v4_do_rcv()
 |-tcp_v4_hnd_req()                         # 被动打开时的处理，包括收到SYN或ACK
 |-sock_rps_save_rxhash()                   # 如果返回值nsk!=sk，则表示是收到了ACK报文
 |-tcp_child_process()                      # 处理新的sock
   |-tcp_rcv_state_process()
     |-icsk-&gt;icsk_af_ops-&gt;conn_request()    # 实际调用tcp_v4_conn_request()
       |-tcp_conn_request()</code></pre></figure>

<p>tcp_conn_request() 函数是主要的处理流程，其处理流程如下，在此重点关注一下 drop 的处理逻辑。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">tcp_conn_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_sock_ops</span> <span class="o">*</span><span class="n">rsk_ops</span><span class="p">,</span>
             <span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_request_sock_ops</span> <span class="o">*</span><span class="n">af_ops</span><span class="p">,</span>
             <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="cm">/* 1. 判断半链接队列是否已满，listen_sock.qlen &gt;&gt; listen_sock.max_qlen_log */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">sysctl_tcp_syncookies</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span>         <span class="c1">// 为2表示用来测试</span>
         <span class="n">inet_csk_reqsk_queue_is_full</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isn</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">want_cookie</span> <span class="o">=</span> <span class="n">tcp_syn_flood_action</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">rsk_ops</span><span class="o">-&gt;</span><span class="n">slab_name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">want_cookie</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 2. 判断accept队列是否已满，sock.sk_ack_backlog &gt; sock.sk_max_ack_backlog；</span>
<span class="cm">     * 以及 listen_sock.qlen_young 的值是否大于 1 。</span>
<span class="cm">     * 也就意味着，如果全连接队列满了，且有未重传过的半连接，则直接丢弃SYN请求</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sk_acceptq_is_full</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">inet_csk_reqsk_queue_young</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_LISTENOVERFLOWS</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 链接未满，申请一个struct request_sock变量 */</span>
    <span class="n">req</span> <span class="o">=</span> <span class="n">inet_reqsk_alloc</span><span class="p">(</span><span class="n">rsk_ops</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

    <span class="p">...</span> <span class="p">...</span>

    <span class="cm">/* OK, 一切正常，发送 SYNACK */</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">af_ops</span><span class="o">-&gt;</span><span class="n">send_synack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fl</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span>
                  <span class="n">skb_get_queue_mapping</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">foc</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fastopen</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span> <span class="p">...</span>
        <span class="cm">/* 实际调用 inet_csk_reqsk_queue_hash_add() 函数将该请求添加到半链接队列中 */</span>
        <span class="n">af_ops</span><span class="o">-&gt;</span><span class="n">queue_hash_add</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">TCP_TIMEOUT_INIT</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="p">...</span> <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<h4 id="判断半链接队列是否已满">判断半链接队列是否已满</h4>

<p>该判断通过 inet_csk_reqsk_queue_is_full(sk) 实现，也即比较如下的值。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">listen_sock.qlen &gt;&gt; listen_sock.max_qlen_log 。</code></pre></figure>

<p>其中的 qlen 代表的是 listen_sock 中的 syn_table 的长度，那什么是 max_qlen_log 呢？可以直接参考上面的介绍。</p>

<h4 id="判断accept队列已满">判断accept队列已满</h4>

<p>在上述的第二步中，在通过 sk_acceptq_is_full() 判断 accept 队列已满的情况下，同是也会判断 listen_sock 结构体中的 qlen_young 变量是否大于 1 。</p>

<p>而 qlen_young 是对 syn_table 的计数，当进入 syn_table 时加 1，出了syn_table 时减 1 。</p>

<p>首先介绍一下什么是 qlen_young，下面是摘抄自网络上的注释：</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">qlen_young
sum of new open_request on syn_table. after TCP_TIMEOUT_INIT, if the open_request
hadn&#39;t be acked, then it can retrans corresponding syn/ack and it becoms old , the
qlen_young will dec 1. when open_request migrate to acceptq the qlen_yong will also
dec 1 except it had been retransmitted.

see tcp_synack_timer() for more details about qlen_young and clock_hand.</code></pre></figure>

<p>这也就意味着，qlen_young 记录了半链接队列里面第一次接收到的 SYN 报文数量，当然，其中不含已经超时重传的链接。</p>

<p>这也就意味着，如果 accept 队列满了，那么 qlen_young 就一直增加，而新来的请求就会直接被 drop 掉。但是，真实情况是，我们在客户端却很少发现这种情况，Why？？？</p>

<p>原因有两个：A) 客户端会不断重试，通过 tcp_syn_retries 设置；B) 在 inet_csk_reqsk_queue_prune() 函数中，会不断尝试发送 SYN+ACK 报文，此时 qlen_young 会减小。</p>

<p>这也就是说，在第一次的时候，之前的握手过程都没有重传过，所以这个 syn 包 server 端会直接 drop 掉，之后 client 会重传 syn，当 inet_csk_reqsk_queue_yong(sk) &lt; 1 时，那么这个 syn 会被 server 端接受。server 会回复 synack 给 client，这样一来两边的状态就变为 client(ESTABLISHED)+server(SYN_SENT) 。</p>

<h3 id="客户端回复-ack-报文到服务端">客户端回复 ACK 报文到服务端</h3>

<p>当 client 收到 synack 后回复 ack 给 server，此时 server 端的处理流程为：</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">tcp_v4_do_rcv()
 |-tcp_rcv_state_process()
   |-tcp_check_req()
   | |-inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock()     # 实际调用tcp_v4_syn_recv_sock()
   |   |-sk_acceptq_is_full()                         # 判断接收队列是否已满
   |   |-tcp_create_openreq_child()                   # 完成三次握手之后，才正式创建新的socket
   |
   |-req-&gt;rsk_ops-&gt;send_reset()                       # 如果设置了overflow，则会返回reset报文</code></pre></figure>

<p>如果 server 端设置了 sysctl_tcp_abort_on_overflow 那么 server 会发送 rst 给 client，并删除掉这个链接；否则 server 端只是记录一下 LINUX_MIB_LISTENOVERFLOWS，然后返回。</p>

<p>默认情况下是不会设置的，server 端只是标记连接请求块的 acked 标志，之后连接建立定时器，会遍历半连接表，重新发送 synack，重复上面的过程，具体的过程可以查看 inet_csk_reqsk_queue_prune()，重传会直到超过 synack 重传的阀值，才会把该连接从半连接链表中删除。</p>

<p><br /></p>

<p>在函数 tcpp_create_openreq_child() 中才真正 clone 出一个新的 socket，也就是只有通过了 3 次握手后，Linux 才会产生新的 socket。而在 3 次握手中所传的 socket 实际上是 server 处于 listen 状态的 socket，那也就是说这个 socket 只有一个 TCP_LISTEN 状态。</p>

<h2 id="实验">实验</h2>

<p>为了方便我们观察，需要修改一下 Linux 内核的配置参数。首先查看下操作系统默认的内核参数值，为了后面恢复。下面是自己笔记本上的默认配置参数。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ sysctl net.ipv4.tcp_max_syn_backlog
net.ipv4.tcp_max_syn_backlog = 256

$ sysctl net.core.somaxconn
net.core.somaxconn = 128

$ sysctl net.ipv4.tcp_syncookies
net.ipv4.tcp_syncookies = 1

$ sysctl net.ipv4.tcp_abort_on_overflow
net.ipv4.tcp_abort_on_overflow = 0

$ sysctl net.ipv4.tcp_syn_retries
net.ipv4.tcp_syn_retries = 6

$ sysctl net.ipv4.tcp_synack_retries
net.ipv4.tcp_synack_retries = 5</code></pre></figure>

<p>为了方便查看，我们先修改几个参数。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ sysctl -w net.ipv4.tcp_max_syn_backlog=2        # 将半链接队列设置较小的值
$ sysctl -w net.core.somaxconn=3                  # 监听队列的长度同样设小
$ sysctl -w net.ipv4.tcp_syncookies=0             # 关闭sync cookies
$ sysctl -w net.ipv4.tcp_syn_retries=2            # 当客户端无法链接时，重发SYN报文的次数，设置较小值
$ sysctl -w net.ipv4.tcp_synack_retries=20        # 服务端没有收到ACK时，重发SYN+ACK的次数，同样设置较大值</code></pre></figure>

<p>在代码中使用的是 listen(…, 20)，那么在设置完内核参数之后，我们首先计算一下两个队列的长度，其实上面已经计算过了。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">----- accept队列长度
entries = min(backlog/*from listen()*/, net.core.somaxconn) = 3

----- 半链接队列长度
entries = min(entries, net.ipv4.sysctl_max_syn_backlog) = 2
entries = max(entries, 8) = 8
entries = roundup_pow_of_two( 8 + 1) = 16</code></pre></figure>

<p>也就是说，半链接队列大小是 16；accept 队列大小是 3 。</p>

<h3 id="测试程序">测试程序</h3>

<p>测试程序直接用 C 写的一个简单回显程序，源码可以从 <a href="/reference/linux/network/syn_ack.tar.bz2" title="简单的回显测试程序源码">本地</a> 直接下载。</p>

<p>这个程序非常简单，服务端每次最多只会处理一个请求，只有当第一个客户端关闭之后，才会接着响应其它的请求，否则就一直保存在内核的队列中。</p>

<p>上述的服务器默认使用 8080 端口，为了观察方便，我们直接通过 ss 监控链接数，命令如下：</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># watch -n 1 &quot;ss -tann &#39;( sport = 8080 or dport = 8080 )&#39;&quot;</code></pre></figure>

<p>也就是查看源端口或者目的端口是 8080 的所有 TCP 链接，且每秒刷新一次。</p>

<p>接下来验证的时候简单分为两个场景，是否设置 net.ipv4.tcp_abort_on_overflow 。</p>

<h3 id="设置-tcp_abort_on_overflow">设置 tcp_abort_on_overflow</h3>

<p>如果设置 overflow=1 则在尝试建立第 6 个链接时报错 Connection reset by peer 。</p>

<p><img src="/images/linux/network-synack-overflow-1.png" alt="overflow1" title="设置overflow时的参数" class="pull-center" /></p>

<p>其中包括了一个 accept 的链接 + 四个在 accept 队列中的链接，那么在尝试建第六个的时候就会报错。</p>

<p>这里有个问题，我们设置的 accept 队列是 3，为什么保存了 4 个链接，可以参考如下的介绍，忘了从那里摘抄的了。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">When I use linux TCP socket, and find there is a bug in function sk_acceptq_is_full():
  When a new SYN comes, TCP module first checks its validation. If valid, send SYN+ACK to
the client and add the sock to the syn hash table.

  Next time if received the valid ACK for SYN+ACK from the client. server will accept this
connection and increase the sk-&gt;sk_ack_backlog (which is done in function tcp_check_req()).

  We check wether acceptq is full in function tcp_v4_syn_recv_sock().

Consider an example:
  After listen(sockfd, 1) system call, sk-&gt;sk_max_ack_backlog is set to 1. As we know,
sk-&gt;sk_ack_backlog is initialized to 0. Assuming accept() system call is not invoked now.

1. 1st connection comes. invoke sk_acceptq_is_full(). sk-&gt;sk_ack_backlog=0 sk-&gt;sk_max_ack_backlog=1,
   function return 0 accept this connection. Increase the sk-&gt;sk_ack_backlog
2. 2nd connection comes. invoke sk_acceptq_is_full(). sk-&gt;sk_ack_backlog=1 sk-&gt;sk_max_ack_backlog=1,
   function return 0 accept this connection. Increase the sk-&gt;sk_ack_backlog
3. 3rd connection comes. invoke sk_acceptq_is_full(). sk-&gt;sk_ack_backlog=2 sk-&gt;sk_max_ack_backlog=1,
   function return 1. Refuse this connection.

I think it has bugs. after listen system call. sk-&gt;sk_max_ack_backlog=1 but now it can accept 2 connections.</code></pre></figure>

<p>也就是说，accept 的链接数总是 +1 。</p>

<h3 id="取消-tcp_abort_on_overflow">取消 tcp_abort_on_overflow</h3>

<p>将该参数设置为 0 时，在 accept 队列溢出时就不会发送 rst 报文，而是直接 drop 报文。如果此时通过 tcpdump 之类的工具查看时，可以发现客户端一直在重试。</p>

<p><img src="/images/linux/network-synack-overflow-0.png" alt="overflow0" title="取消overflow时的参数" class="pull-center" width="700" /></p>

<p>此时，是在尝试建立第 9 个链接时报错 Connection timed out 。</p>

<p>我们在上述的计算过程中，半链接队列应该是 16 个才对，此时只有 3 个处于 SYN-RECV 的报文，这是为什么？？？ 还是看一下代码。</p>

<p>仍然是在 tcp_conn_request() 函数中，在已经尝试建立链接时，会发现如下的代码。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">tcp_conn_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_sock_ops</span> <span class="o">*</span><span class="n">rsk_ops</span><span class="p">,</span>
             <span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_request_sock_ops</span> <span class="o">*</span><span class="n">af_ops</span><span class="p">,</span>
             <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="cm">/* Kill the following clause, if you dislike this way. */</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sysctl_tcp_syncookies</span> <span class="o">&amp;&amp;</span>
         <span class="p">(</span><span class="n">sysctl_max_syn_backlog</span> <span class="o">-</span> <span class="n">inet_csk_reqsk_queue_len</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&lt;</span>
          <span class="p">(</span><span class="n">sysctl_max_syn_backlog</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
         <span class="o">!</span><span class="n">tcp_peer_is_proven</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
                     <span class="n">tmp_opt</span><span class="p">.</span><span class="n">saw_tstamp</span><span class="p">))</span> <span class="p">{</span>
        <span class="p">...</span> <span class="p">...</span>
        <span class="k">goto</span> <span class="n">drop_and_release</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>在上述的判断中，可以从 1 到 3 计算一下，当尝试建立第 4 个链接时，就会为 true ，那么就直接将报文 drop 掉了。</p>

<h2 id="总结">总结</h2>

<p>listen() 中的入参 backlog 不仅影响到了链接队列，还影响到了半链接队列。</p>

<!--
何时添加到半链接队列中
.queue_hash_add = inet_csk_reqsk_queue_hash_add()
inet_csk_reqsk_queue_added()

tcp_rcv_synsent_state_process()    设置为TCP_SYN_RECV

擦，为什么 nr_table_entries 是 16 ，qlen 是 3 ，却不能再接收 SYN 请求了。
-->


  <hr>
  <nav>
    <ul class="pager">
         <li class="previous"><a href="/post/mysql-myisam_init.html" title="MySQL MyISAM">&larr; Older</a></li> 
         <li class="next"><a href="/post/mysql-log.html" title="MySQL 日志相关">Newer &rarr;</a></li> 
    </ul>
  </nav><br>
<!--
  <hr><div id="section-donate"><span>赏</span></div><br>
  <p style="text-indent:0px;text-align:center;">如果喜欢这里的文章，而且又不差钱的话，欢迎打赏个早餐 ^_^</p><br>
  <div class="row" style="text-align:center;" >
    <div class="col-md-6"><img src="/images/system/barcode-pay-alipay.jpg" style="width:150px;height:150px;" title="支付宝捐赠" /><br>支付宝打赏</div>
    <div class="col-md-6"><img src="/images/system/barcode-pay-wechat.jpg" style="width:150px;height:150px;" title="微信捐赠" /><br>微信打赏</div>
  </div><br><hr>
-->
  <p style="text-indent:0px;text-align:center;">如果喜欢这里的文章，而且又不差钱的话，欢迎打赏个早餐 ^_^</p>
  <div id="donate_module">
    <style type="text/css">
      .donate_bar a.btn_donate{
        display: inline-block;
        position:      relative;
        text-align:    center;
        width: 82px;
        height: 82px;
        background: url("/images/misc/btn_reward.gif") no-repeat;
        _background: url("/images/misc/btn_reward.gif") no-repeat;
        -webkit-transition: background 0s;
        -moz-transition: background 0s;
        -o-transition: background 0s;
        -ms-transition: background 0s;
        transition: background 0s;
      }
      .donate_bar a.btn_donate:hover{ background-position: 0px -82px;}
      .donate_bar .donate_txt {
        display: block;
        color: #9d9d9d;
        font: 14px/2 "Microsoft Yahei";
      }
    </style>
    <div id="donate_board" class="donate_bar row" style="text-align:center;" >
      <a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏"></a>
    </div>
    <div id="donate_guide" class="donate_bar center hidden">
      <div class="row" style="text-align:center;" >
        <div class="col-md-6"><img src="/images/system/barcode-pay-alipay.jpg" style="width:150px;height:150px;" title="支付宝捐赠" /><br>支付宝打赏</div>
        <div class="col-md-6"><img src="/images/system/barcode-pay-wechat.jpg" style="width:150px;height:150px;" title="微信捐赠" /><br>微信打赏</div>
      </div>
    </div>
    <script type="text/javascript">
      document.getElementById('btn_donate').onclick = function(){
        $('#donate_board').addClass('hidden');
        $('#donate_guide').removeClass('hidden');
      }
      function donate_on_web(){
        $('#donate').submit();
      }
    </script>
  </div>

  <hr>

  <div id="gitmentContainer"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
  var gitment = new Gitment({
      id: '1438704000',
      owner: 'Jin-Yang',
      repo: 'jin-yang.github.com',
      oauth: {
          client_id: '6d89d48ce689192bf95d',
          client_secret: 'c9a720aafb8e3084e3feb46cadee80b03cdc792f',
      },
  });
  gitment.render('gitmentContainer');
  </script>

  <!-- 多说评论框 start -->
  <!--<div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>-->
  <!--
  <div class="ds-thread" data-thread-key="/post/network-synack-queue.html" data-title="Linux 网络半链接、链接队列" data-url="/post/network-synack-queue.html"></div>
  -->
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <!--
  <script type="text/javascript">
      var duoshuoQuery = {short_name:"jinyangposts"};
      (function() {
          var ds = document.createElement('script');
          ds.type = 'text/javascript';ds.async = true;
          ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
          ds.charset = 'UTF-8';
          (document.getElementsByTagName('head')[0]
           || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
  </script>
  -->
  <!-- 多说公共JS代码 end -->
</div>

    </div>
    <div class="col-lg-3 visible-lg blog-sidebar">
    <center><a href="/"><img src="/images/system/linux-liberty.png" width="200" /></a></center>
<h2>About This Blog</h2>
<div class="sidebar-module">
<p style="text-indent:0em;margin:0px;padding:0px;">This is a personal weblog ^_^ generated with Jekyll, if you like it or have some questions,
just feel free to contact me :)</p>
</div><!-- end of "node" "about" -->



<h2>Recent Posts</h2>
<div class="list-group">
  
    <a class="list-group-item" href="/post/linux-program-cpu-cache-introduce_init.html">CPU Cache</a>
  
    <a class="list-group-item" href="/post/artificial-intelligence-decision-tree-introduce.html">决策树</a>
  
    <a class="list-group-item" href="/post/linux-ebpf-bcc-tools-introduce.html">BCC 工具使用</a>
  
    <a class="list-group-item" href="/post/linux-ebpf-basic-usage-introduce.html">eBPF 简介</a>
  
    <a class="list-group-item" href="/post/math-monte-carlo-sample-introduce.html">采样算法</a>
  
</div>

<h2>Categories</h2>
<ul class="list-group" style="margin:0px;">
  
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#bash"> bash</a>
    <span class="badge">2</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#database"> database</a>
    <span class="badge">86</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#golang"> golang</a>
    <span class="badge">28</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#linux"> linux</a>
    <span class="badge">301</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#misc"> misc</a>
    <span class="badge">244</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#mysql"> mysql</a>
    <span class="badge">79</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#network"> network</a>
    <span class="badge">49</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#postgresql"> postgresql</a>
    <span class="badge">4</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#program"> program</a>
    <span class="badge">138</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#python"> python</a>
    <span class="badge">25</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#react"> react</a>
    <span class="badge">1</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#rtems"> rtems</a>
    <span class="badge">1</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#sql"> sql</a>
    <span class="badge">10</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#tools"> tools</a>
    <span class="badge">1</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#webserver"> webserver</a>
    <span class="badge">25</span>
  </li>
  
</ul><!-- end of "node" "categories" -->

<h2>Related Links</h2>
<ul class="list-group" style="margin:0px">
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
       <a href="http://www.rtems.org" title="To RTEMS"><img class="img-thumbnail img-responsive" src="/images/system/rtems.png"  alt="RTEMS"/></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>RTEMS</strong><br>
        <div class="sidebar-description">Real-Time Executive for Multiprocessor System</div>
      </div>
    </div>
  </li>
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
       <a href="http://www.gnu.org" title="To GNU">
       <img class="img-thumbnail img-responsive" src="/images/system/gnu.jpg" alt="GNU" /></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>GNU</strong><br>
        <div class="sidebar-description">A Unix-linux Operating System</div>
      </div>
    </div>
  </li>
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
    <a href="http://www.kernel.org" title="To Linux Kernel">
    <img class="img-thumbnail img-responsive" src="/images/system/linux.png"  alt="LINUX" /></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>Linux Kernel</strong><br>
        <div class="sidebar-description">Maintained by Linux Kernel Organization</div>
      </div>
    </div>
  </li>
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
    <a href="http://arduino.cc" title="To Arduino">
    <img class="img-thumbnail img-responsive" src="/images/system/arduino.png"  alt="ARDUINO" /></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>Arduino</strong><br>
        <div class="sidebar-description">Open-source Electronic Prototyping Platform</div>
      </div>
    </div>
  </li>
</ul>

<h2>Search</h2>
<div class="sidebar-module">
  <form class="search" method="GET" action="https://www.google.com.hk/search">
    <input type="text" name="q" class="search-query" placeholder=" Search on Google">
    <input type="hidden" name="ie" value="utf-8">
    <input type="submit" name="sa" value="Search" />
  </form><br>
  <input type="text" class="search-field" placeholder=" Search This Site">
  <div class="search-results"></div>
</div>



    </div>
  </div>
<hr><p class="text-center">This Site was built by Jin Yang, generated with Jekyll, and hosted on GitHub Pages<br/> &copy;2013-2019 &ndash; Jin Yang</p><div class="footer-logo"></div>

</div>
</body>
</html>
