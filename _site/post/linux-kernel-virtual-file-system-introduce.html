<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="baidu-site-verification" content="B786jeR0MV" />
  <meta name="msvalidate.01" content="29F791E7F785800340E37AD7C714D2A7" />
  <meta name="google-site-verification" content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0" />
  <title>Linux VFS 文件系统|JinYang's Blog</title>
  <meta name="keywords" content="linux,lvs">
  <meta name="description" content="在次重申下，*nix 的设计理念是：一切都是文件！ 也就是在 Linux 中，一切设备皆是以文件的形式进行操作，如网络套接字、硬件设备等。这一切都是通过一个中间层实现的，被称为 VFS (Virtual File System) 。">

  <script src="https://cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>
  <script type="text/javascript">
  !window.jQuery && document.write('<script src="/static/js/jquery.min.js"><\/script>');
  </script>
  <script src="https://cdn.bootcss.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
  <script type="text/javascript">
  !$('body').popover && document.write('<script src="/static/js/bootstrap.min.js"><\/script>');
  </script>
  <script type="text/javascript" src="/static/js/main.js"></script>
  <!-- <link rel="stylesheet prefetch" href="http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css"> -->
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/bootstrap.min.css">
  <!-- <link href="http://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/font-awesome.min.css">
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/pygments.css">
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/screen.css">
  <style type="text/css">
  
    .post-container > p {text-indent: 2em;}
  
  </style>
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-124556620-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-124556620-1');
</script>

</head>

<body>
<nav class="navbar navbar-default navbar-inverse navbar-fixed-top navbar-wrapper">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span>
      </button><a class="navbar-brand" href="/">Jin-Yang</a>
    </div>
    <div id="navbar" class="collapse navbar-collapse">
      <ul class="nav navbar-nav">
        <li  ><a href="/"> Home </a></li>
        <li  ><a href="/archives.html"> Archive </a></li>
        <li  ><a href="/categories.html"> Categories </a></li>
        <li  ><a href="/projects.html"> Projects </a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"> Others <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li class="dropdown-header">常用网站</li>
            <li role="separator" class="divider"></li>
            <li><a href="https://www.rtems.org/">www.rtems.org</a></li>
            <li><a href="http://www.gnu.org/">www.gnu.org</a></li>
            <li><a href="https://www.kernel.org/">www.kernel.org</a></li>
            <li><a href="https://www.arduino.cc/">www.arduino.cc</a></li>
          </ul>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li  ><a href="/about.html"> About </a></li>
      </ul>
    </div><!--/.nav-collapse -->
  </div>
</nav>

<div id="myCarousel" class="carousel slide" data-ride="carousel">
  <!-- Indicators -->
  <ol class="carousel-indicators">
    <li data-target="#myCarousel" data-slide-to="0" class="active"></li>
    <li data-target="#myCarousel" data-slide-to="1"></li>
    <li data-target="#myCarousel" data-slide-to="2"></li>
    <li data-target="#myCarousel" data-slide-to="3"></li>
    <li data-target="#myCarousel" data-slide-to="4"></li>
  </ol>
  <div class="carousel-inner" role="listbox">
    <div class="item active">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>KISS</h1>
          <h2>Keep It Simple and Stupid.</h2>
          <!--<a class="btn btn-lg btn-primary" href="#" role="button">Sign up today</a>-->
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Seize The Day</h1><h1>And Get Busy Living</h1>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Stay hungry</h1><h1>Stay foolish</h1>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
	  <h2>Ever tried, ever failed</h2><h2>No matter, try again</h2><h2>Fail again, fail better</h2>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Nothing is true</h1><h1>Every is permitted</h1>
        </div>
      </div>
    </div>
  </div>
  <a class="left carousel-control" href="#myCarousel" role="button" data-slide="prev">
    <span class="glyphicon glyphicon-chevron-left"></span>
    <span class="sr-only">Previous</span>
  </a>
  <a class="right carousel-control" href="#myCarousel" role="button" data-slide="next">
    <span class="glyphicon glyphicon-chevron-right"></span>
    <span class="sr-only">Next</span>
  </a>
</div><!-- /.carousel -->

<div class="container">
  <div class="row">
    <div class="col-lg-9 blog-main" style="min-width: 500px">
    
<div class="post-container">
  <div class="blog-header">
    <h1>Linux VFS 文件系统</h1>
    <div class="post-description">
      <i class="fa fa-calendar"></i> 2014-03-15 Saturday &nbsp; &nbsp;
      <i class="fa fa-tags"></i>  linux  
      
    </div>
  </div>
  <hr>
  <p>在次重申下，*nix 的设计理念是：一切都是文件！</p>

<p>也就是在 Linux 中，一切设备皆是以文件的形式进行操作，如网络套接字、硬件设备等。这一切都是通过一个中间层实现的，被称为 VFS (Virtual File System) 。</p>

<!-- more -->

<h2 id="virtual-file-system-vfs">Virtual File System, VFS</h2>

<p>总体上说 Linux 的文件系统主要可分为三大块：一是上层的文件系统的系统调用，也就是提供的统一文件系统 API；二是虚拟文件系统 VFS；三是挂载到 VFS 中的各实际文件系统，例如 ext4 。</p>

<p>按照类型文件系统可以分为三类：A) 磁盘文件系统，最常见，用来将数据保存在物理存储上，如 ext4、FAT、NTFS；B) 虚拟文件系统，如 procfs、sysfs；C) 网络文件系统，NFS 。</p>

<p>为了支持多种文件系统，Linux 内核在用户进程 (C标准库) 和文件系统之前实现了一个抽象层，虚拟文件系统，也就是 VFS 。</p>

<p>VFS 除了为所有文件系统的实现提供一个通用接口外，还提供了一些文件相关数据结构的磁盘高速缓存。例如最近最常使用的目录项对象被放在所谓目录项高速缓存（dentry cache）的磁盘高速缓存中，从而加速从文件路径名到最后一个路径分量的索引节点的转换过程。</p>

<h3 id="数据结构">数据结构</h3>

<p>对于文件，主要包括了两部分信息：A) 存储的数据本身；B) 该文件的组织和管理的信息。</p>

<p>后者就是 Linux 中维护的一些元数据 (metadata)，主要结构包括了 superblock、inode、dentry 和 file，用来支持如指示存储位置、历史数据、资源查找、文件纪录等功能。</p>

<p>在内存中, 每个文件都有一个 dentry(目录项) 和 inode (索引节点) 结构，dentry 记录着文件名，上级目录等信息，正是它形成了我们所看到的树状结构；而有关该文件的组织和管理的信息主要存放 inode 里面，它记录着文件在存储介质上的位置与分布。</p>

<p>另外，<code>dentry-&gt;d_inode</code> 指向相应的 inode 结构，dentry 与 inode 是多对一的关系，因为有可能一个文件有好几个文件名，如硬链接。</p>

<h3 id="dentry-和-inode-的关系">dentry 和 inode 的关系</h3>

<p>在 Linux 进程中，是通过目录项 (dentry) 和索引节点 (inode) 描述文件的，而所谓 “文件” 就是按一定的格式存储在介质上的信息，所以一个文件其实包含了两方面的信息，一是存储的数据本身，二是有关该文件的组织和管理的信息。</p>

<p>在内存中, 每个文件都有一个 dentry 和 inode 结构，前者记录着文件名、上级目录等信息，所有的 dentry 用 d_parent 和 d_child连 接起来，就形成了我们熟悉的树状结构； 而有关该文件的组织和管理的信息主要存放 inode 里面，它记录着文件在存储介质上的位置与分布。</p>

<p>同时 dentry-&gt;d_inode 指向相应的 inode 结构，由于硬链接导致一个文件可能有好几个文件名，所以 dentry 与 inode 是多对一的关系。</p>

<p>inode 代表的是物理意义上的文件，通过 inode 可以得到一个数组，这个数组记录了文件内容的位置，如该文件位于硬盘的第 3、8、10 块，那么这个数组的内容就是 3、8、10。在同一个文件系统中可以通过索引节点号 inode-&gt;i_ino 计算出在介质上的位置，对于硬盘来说，可直接计算出对应的 inode 属于哪个块 (block)，从而找到相应的 inode 结构。</p>

<p>另外，对于某一种特定的文件系统而言，如 ext4，在内存中用 ext4_inode_info 结构体描述，包含了一个 inode 容器。就磁盘文件而言，dentry 和 inode 的信息保存在磁盘上，对于像 ext4 这样的磁盘文件来说，存储介质中的目录项和索引节点载体通过 ext4_inode、ext4_dir_entry_2 标示。</p>

<h2 id="文件系统">文件系统</h2>

<p>磁盘上的文件内容通过文件系统组织一系列的文件，通常这些文件保存在磁盘的不同分区上，当然不同的分区可能包含不同的文件系统类型，如 ext2、ext3、fat16、ntfs 等。</p>

<p>可以通过 <code>cat /proc/filesystems</code> 查看已经注册的文件系统。</p>

<p>对于每个文件系统，同时会有代码，或者是模块，来告诉我们如何操作这些文件。因此，在使用具体的文件之前，需要告诉内核该文件系统的相关信息，主要包括 A) 文件系统名称；B) 知道如何挂载；C) 如何查找文件的路径；D) 如何查找文件的内容。</p>

<h3 id="数据结构-1">数据结构</h3>

<h4 id="file-system">file system</h4>

<p>其中 <code>struct file_system_type</code> 包括了文件系统的主要参数，如下之列出了主要部分。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">file_system_type</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>                                     <span class="c1">// 文件系统的名称，如EXT4、FAT16、NTFS</span>
    <span class="kt">int</span> <span class="n">fs_flags</span><span class="p">;</span>                                         <span class="c1">// 对应文件系统的类型，在该变量下定义了一些符号的宏</span>
    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">mount</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="p">,</span>   <span class="c1">// 代替早期的get_sb()，用户挂载此文件系统时使用的回调函数</span>
                <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">kill_sb</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>               <span class="c1">// 删除内存中的super block，在卸载文件系统时使用</span>
    <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>                                 <span class="c1">// 指向实现这个文件系统的模块，通常为THIS_MODULE宏</span>
    <span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>                        <span class="c1">// 指向文件系统类型链表的下一个文件系统类型</span>
    <span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">fs_supers</span><span class="p">;</span>                          <span class="c1">// 该文件系统类型的超级块结构，都串连在这个表头下</span>
<span class="p">};</span></code></pre></figure>

<p>另外，存在一个全局变量 <code>file_systems</code>，用于保存所有已经注册的文件系统。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">file_systems</span><span class="p">;</span>
<span class="k">static</span> <span class="nf">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">file_systems_lock</span><span class="p">);</span></code></pre></figure>

<p>文件系统信息在内核中会通过单向链表保存，其中 <code>file_systems</code> 全局变量作为链头，同时对应一个 <code>file_systems_lock</code> 锁，当需要读写时需要先加锁，如上，可以通过 <code>cat /proc/filesystems</code> 查看已经注册的文件系统。</p>

<h4 id="operation">operation</h4>

<p>与文件相关的操作包括了三部分：</p>

<ul>
  <li>SuperBlock 包含了文件系统的元数据信息；</li>
  <li>Inode 与文件相关的信息；</li>
  <li>File 保存的文件主体。</li>
</ul>

<p>针对这三部分同时也对应了三类的操作 API 接口函数。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">super_operations</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sync_fs</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">statfs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="p">);</span>
	<span class="c1">// ... ...</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">inode_operations</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">lookup</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">umode_t</span><span class="p">,</span> <span class="kt">bool</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">link</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mkdir</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span><span class="kt">umode_t</span><span class="p">);</span>
	<span class="c1">// ... ...</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">file_operations</span> <span class="p">{</span>
	<span class="kt">loff_t</span> <span class="p">(</span><span class="o">*</span><span class="n">llseek</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">loff_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">loff_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
	<span class="c1">// ... ...</span>
<span class="p">};</span></code></pre></figure>

<h2 id="文件系统注册">文件系统注册</h2>

<p>这是最简单的，也就是直接添加到全局列表中。</p>

<p>在上面的结构体中包含了文件系统的名称，以及如何产生一个保存在内存中的 <code>super_block</code> 结构体。主要，通过 <code>register_filesystem()</code> 向 VFS 注册，对于编译到内核中的文件系统则是在内核初始化的时候注册，当然也可以在模块初始化的时候注册。</p>

<p>文件系统注册通过 <code>int register_filesystem(struct file_system_type * fs)</code> 来完成，该函数唯一的操作是将相应的结构体添加到 <code>file_systems</code> 链表中。</p>

<p>在 <code>struct file_system_type</code> 中通过链表与 <code>file_systems</code> 链头相连，而 <code>register_filesystem()</code> 也就是将对应的类型添加到链表中。</p>

<p>然后在通过 mount 命令挂载时，会指定相应的文件系统，然后通过对应的 <code>mount()</code> 函数从文件系统 (extN 是从硬盘上) 读取 <code>super_block</code> 并初始化。</p>

<p>新建 inode 实际通过 <code>new_inode()</code> 完成，而该函数最终会调用 <code>super_block-&gt;s_op-&gt;alloc_inode()</code> 完成。</p>

<h2 id="mount-挂载">Mount 挂载</h2>

<p>挂载就是将一个文件系统添加到一个目录上，对应的文件系统通常为磁盘文件系统，如 EXTN、NTFS、XFS、FAT16 等；当然也包括虚拟文件，如 proc、sysfs 等。</p>

<p>挂载时通常包括 A) 一个设备，可以是磁盘、软盘、CDROM 、U盘等；B) 一个对应的目录挂载点；C) 指定相应的文件系统。</p>

<p>一个挂载命令 mount 通常如下，包括了几个重要参数 fstype、devname、mountpoint、options，可以通过 <code>man 8 mount</code> 查看，对于函数的原型可以通过 <code>man 2 mount</code> 查看。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># mount -t ext4 /dev/sda1 /mnt -o ....</code></pre></figure>

<p>对于上述的命令也可以通过如下的程序执行。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ man 2 mount
... ...
int mount(const char *source, const char *target,
             const char *filesystemtype, unsigned long mountflags,
             const void *data);
... ...

$ cat mount_test.c
#include &lt;stdio.h&gt;
#include &lt;sys/mount.h&gt;

int main(int argc, char *argv[]) {
    if (mount(&quot;/dev/sda1&quot;, &quot;/mnt&quot;, &quot;ext4&quot;, 0, NULL)) {
        perror(&quot;mount failed&quot;);
    }
    return 0;
}

$ gcc -Wall -o mount_test mount_test.c                 # 编译
$ ./mount_test                                         # 执行命令挂载
$ findmnt /dev/sda1                                    # 查看执行结果</code></pre></figure>

<p>对于 <code>mount()</code> 函数，source 是要挂载的设备名，target 是要挂载到哪，filesystemtype 就是文件系统类型名，而剩余的两个参数 flags 和 data 对应于传入的参数。</p>

<p>其中 flags 相应宏定义在 <code>include/uapi/linux/fs.h</code> 中，如 <code>MS_RDONLY</code>、<code>MS_NOATIME</code> 等，这些 flags 会在 VFS 层被解析使用。而 data 则是每个文件系统各自支持的挂载选项，可以通过 strace 查看最终调用 <code>mount()</code> 接口是调用的命令。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ strace mount /dev/loop0 /mnt/foobar -o noquota,nodev
... ...
mount(&quot;/dev/loop0&quot;, &quot;/mnt/foobar&quot;, &quot;xfs&quot;, MS_MGC_VAL|MS_NODEV, &quot;noquota&quot;) = 0
... ...</code></pre></figure>

<p>其中 nodev 被解释为 flag，noquota 被当作了 mount data。</p>

<h3 id="挂载过程">挂载过程</h3>

<p>在内核中，<code>struct mount</code> 代表着一个 mount 实例，每次挂载都会新建一个该结构体，其中 <code>struct vfsmount mnt</code> 成员是它最核心的部分，过去所有的成员都保存在 vfsmount 结构体中，后来只保留了核心部分在 vfsmount ，这样使得 vfsmount 的内容更加精简，在很多情况下只需要传递 vfsmount。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// fs/mount.h</span>
<span class="k">struct</span> <span class="n">mount</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">mnt_hash</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt_parent</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">vfsmount</span> <span class="n">mnt</span><span class="p">;</span>
    <span class="p">...</span> <span class="p">...</span>
<span class="p">};</span>

<span class="c1">// include/linux/mount.h</span>
<span class="k">struct</span> <span class="n">vfsmount</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">dentry</span>  <span class="o">*</span><span class="n">mnt_root</span><span class="p">;</span>           <span class="c1">// 该文件系统的根目录</span>
    <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">mnt_sb</span><span class="p">;</span>         <span class="c1">// 指向superblock</span>
    <span class="kt">int</span> <span class="n">mnt_flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// include/linux/path.h</span>
<span class="k">struct</span> <span class="n">path</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure>

<p>在全局文件系统树上要想确定一个位置不能由 dentry 唯一确定，因为有了挂载关系，一切都变的复杂了，比如一个文件系统可以挂装载到不同的挂载点。所以文件系统树的一个位置要由 <code>(mount, dentry)</code> 二元组，或者说 <code>(vfsmount, dentry)</code> 来确定，在内核中通过 <code>struct path</code> 表示。</p>

<p>下面查看 <code>sys_mount()</code> 的执行过程，实际上，mount 操作的过程就是新建一个 <code>struct mount</code>，然后将此结构和挂载点关联。之后，目录查找时就能沿着 mount 挂载点一级级向下查找文件。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">sys_mount()
 |-copy_mount_string()                  # 从用户空间复制文件系统类型名称、设备名称
 |-copy_mount_options()                 # 获取data数据
 |-do_mount()                           # 通过该函数调用已传入内核的参数
   |-user_path()                        # 把挂载点解析成path内核结构，也就是路径解析过程
   | |-user_path_at()
   |   |-filename_lookup()
   |- ... ...                           # 解析flags确定mount的操作类型，如bind、remount、newmount
   |-do_remount()                       # 重新挂载等操作，下面以挂载新节点为例
   |-do_new_mount()
     |-get_fs_type()                    # 通过文件系统名称，找到对应文件系统的类型
     |-vfs_kern_mount()                 # 通过该函数调用具体文件系统的处理函数，构建一个vfsmnt结构
     | |-alloc_vfsmnt()                 # 分配新的struct mount结构体，并初始化其中的一部分，
     | |                                # 构造一个root dentry，包含特定文件系统的super block信息
     | |-mount_fs()                     # 调用具体文件系统的mount回调函数
     | |  |-type-&gt;mount()               # 调用特定文件系统的回调函数
     | |- ... ...                       # 完成最后struct mount的初始化
     |
     |-do_add_mount()                   # 将得到的mnt结构添加到全局文件系统
       |-lock_mount()                   # 找到最新的挂载点，并加锁
       |-real_mount()                   # 挂载到对应的mount点，对挂载进行检查
       |-graft_tree()                   # 将newmount添加到全局文件系统中</code></pre></figure>

<p>在调用 <code>vfs_kern_mount()</code> 时，只有文件系统类型、挂载标记、设备名和挂载选项信息为参数，并没有 mountpoint 参数，其时这里只是用 type 中的 mount 回调函数读取设备的 superblock 信息，填充 mnt 结构，然后把 flag 和 data 解析后填充到 mnt 结构中。</p>

<p>就是说，通过 <code>vfs_kern_mount()</code> 会调用具体文件系统的 <code>mount()</code> 函数，生成 <code>struct mount</code>，最后通过 <code>do_add_mount()</code> 添加到全局的文件系统中。</p>

<h2 id="系统调用">系统调用</h2>

<p>对于文件的常见操作如下：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;fcntl.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;unistd.h</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&quot;syscall.txt&quot;</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>   <span class="c1">// man 2 open</span>
	<span class="k">if</span><span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Error try to open &#39;syscall.txt&#39;&quot;</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s">&quot;just for test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Error try to write &#39;syscall.txt&#39;&quot;</span><span class="p">);</span>
		<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>在 Linux 内核中，每个打开的文件均由一个文件描述符 <code>struct file</code> 表示，而返回给用户的是在 <code>fd_array[]</code> 中的位置索引。</p>

<p>也即，该描述符在特定进程的数组中充当位置索引，这也意味着包括 <code>open()</code> 数组是 <code>task_struct -&gt; files -&gt; fd_arry</code>，该数组的元素包含了 file 结构，其中包括每个打开文件的所有必要信息。</p>

<h3 id="sys_open">sys_open</h3>

<p>对于 open() 系统调用的的主要执行操作在 do_sys_open() 中，下面介绍其主要操作。</p>

<p>do_sys_open() 的操作大致为：A) 找到一个本进程没有使用的文件描述符 fd；B) 分配一个全新的 struct file 结构体；C) 根据传人的 pathname 查找或建立对应的 dentry；D) 建立 fd 到这个 struct file 结构体的联系。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">sys_open()
 |-force_o_largefile()               # 是否要强制使用大文件
 |-do_sys_open()                     # 实际工作，返回索引
   |-build_open_flags()              # 检测传入的flag合法性，并转换为内核的格式struct open_flags
   |-getname()                       # 1. 将用户空间的路径名复制到内核空间，此时申请了内核内存
   | |-getname_flags()               #    主要的处理函数
   |-get_unused_fd_flags()           # 2. 查找一个未使用的文件描述符
   |-do_filp_open()                  # 3. 完成路径搜索并打开文件
   | |-path_openat()                 #    实际返回struct file结构体
   |   |-get_empty_filep()
   |   |-path_init()
   |   |-link_path_walk()
   |   |-do_last()                   #    打开文件的最后一步
   |     |-may_open()                #    进行权限检查
   |     |-vfs_open()
   |     | |-do_dentry_open()        ### 真正的针对文件系统的操作
   |     |-open_check_o_direct()     # 通过f-&gt;f_flags &amp; O_DIRECT判断
   |-fsnotify_open()                 # 4. 通过fsnotify机制唤醒文件系统中的监控进程
   |-fd_install()                    # 5. 为该文件描述符安装文件，设置current-&gt;files-&gt;fd[fd]=file
   |-putname()                       # 6. 释放之前申请的内核内存</code></pre></figure>

<p>在开始，sys_open() 会检测是否要强制支持大文件，在 64 位系统上 flags 会自动加上 O_LARGEFILE ，对于 32 位系统，文件最大受索引节点中表示文件大小的 32-bit 的 i_size 的影响，只能访问 2^32 字节，即 4GB ，而实际高位一般不用，所以通常只有 2G 。</p>

<p>加上 O_LAGEFILE 之后启用索引节点的 i_dir_acl 字段也可以一起表示文件的大小了，这样位数就变成了 64 位，也就是单文件最大为 2^64=16TB 。</p>

<p>do_last() 是文件打开操作的最后一步，其中很大一部分是针对 flag 的判断操作，关于 flags 的含义可以参考 man 2 open，该函数最终会调用 vfs_open() 函数。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">vfs_open</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
         <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">dentry_open</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">dentry_open</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">cred</span><span class="p">);</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span> <span class="o">=</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">do_dentry_open</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">cred</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="p">{</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span>   <span class="o">*</span><span class="n">i_op</span><span class="p">;</span>
    <span class="p">...</span> <span class="p">...</span>
<span class="p">};</span></code></pre></figure>

<p>对于 ext4，可以通过 cd fs/ext4 &amp;&amp; grep -rne ‘^const.*ext4.*inode_operations’ 查看，而 dentry_open() 指针并不存在，实际上会调用 do_dentry_open() 函数。</p>

<p>在 do_dentry_open() 中，会分配一个全新的 struct file 结构体，打开时会根据路径判断所属的文件系统，并执行具体类型的 open() 操作。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">int</span> <span class="nf">do_dentry_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span>
              <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">),</span>
              <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="n">path_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">);</span>
    <span class="n">inode</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_inode</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
    <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">=</span> <span class="n">fops_get</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span><span class="p">);</span>                 <span class="c1">// 后续的操作都使用该行指定的操作</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">cleanup_all</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">error</span> <span class="o">=</span> <span class="n">security_file_open</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">cred</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">cleanup_all</span><span class="p">;</span>

    <span class="n">error</span> <span class="o">=</span> <span class="n">break_lease</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">cleanup_all</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">open</span><span class="p">)</span>
        <span class="n">open</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">open</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">cleanup_all</span><span class="p">;</span>
    <span class="p">...</span> <span class="p">...</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="p">{</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">d_inode</span><span class="p">;</span>      <span class="cm">/* Where the name belongs to - NULL is negative */</span>
    <span class="p">...</span> <span class="p">...</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">path</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">file</span> <span class="p">{</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="k">struct</span> <span class="n">path</span>     <span class="n">f_path</span><span class="p">;</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span>    <span class="o">*</span><span class="n">f_op</span><span class="p">;</span>
    <span class="p">...</span> <span class="p">...</span>
<span class="p">};</span></code></pre></figure>

<p>对于后续的 read()、write() 操作，实际调用的是 struct file_operations 指定的接口，如上述的 open() 函数接口，也就是 inode-&gt;i_fop 指定的值。</p>

<p>另外，可以参考 <a href="http://blog.chinaunix.net/uid-20522771-id-4419666.html">Linux 系统调用 open 七日游</a> 相当不错的介绍文件系统打开的过程。</p>

<h3 id="sys_read">sys_read</h3>

<p>sys_read() 会根据用户空间传入的文件描述符 fd 取出对应的 struct file 结构体，获取 struct file 结构体的当前偏移量指针，从文件读取内容，存放到用户空间内存区，如果读取成功，唤醒相关等待进程，更新文件的当前指针，如果需要则释放对 file 结构的引用。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">sys_read()
 |-fdget_pos()                        # 1. 通过fd获取struct file结构
 |-file_pos_read()                    # 2. 获取当前的偏移量，也即file-&gt;f_pos
 |-vfs_read()                         # 3. 调用VFS接口
   |-file-&gt;f_op-&gt;read()               # 3.1 如果指针存在
   |-do_sync_read()                   # 如果是异步读
     |-wait_on_sync_kiocb()           # 等待数据传输完成</code></pre></figure>

<p>通过 fdget_pos() 返回当前进程下标为 fd (文件描述符) 的 struct file 结构体，其中 current 为当前进程 task_struct，实际返回 current -&gt; files_struct -&gt; fdtable -&gt; file[fd] 这个 struct file 结构体。</p>

<p>在此之前，以及通过 sys_open() 把进程的这个 fd 对应的文件从硬盘上读取或创建好了，所以这里可以之前从数组里面读取。注意，该函数同时会将 file-&gt;file_opeeration 设置为 inode-&gt;file_operation 。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">ssize_t</span> <span class="nf">vfs_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">rw_verify_area</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">aio_read</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">do_sync_read</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">new_sync_read</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fsnotify_access</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
            <span class="n">add_rchar</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">inc_syscr</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">file</span> <span class="p">{</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span>    <span class="o">*</span><span class="n">f_op</span><span class="p">;</span>
    <span class="p">...</span> <span class="p">...</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">file_operations</span> <span class="p">{</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">loff_t</span> <span class="o">*</span><span class="p">);</span>
    <span class="p">...</span> <span class="p">...</span>
<span class="p">};</span></code></pre></figure>

<p>获取偏移量之后会调用 vfs_read()，该函数会把内核读取的文件内容存入 buf 指向的内存地址。如果是同步读，则会直接调用 file-&gt;f_op 对应的 read()，也就是直接调用 inode 对应的文件操作。</p>

<p>如果是异步，也即 f_op 中存在 aio_read() 函数，则会调用 do_sync_read() 。该函数首先会将 buf 和 len 保存，以供后续向用户空间传递数据。</p>

<!--
dentry与inode有什么联系和区别
http://blog.chinaunix.net/uid-26557245-id-3432038.html




## 源码

与文件系统相关的绝大部分代码都保存在 fs 目录下，包括了 VFS、Buffer Cache、可执行文件的格式等等，而不同的文件系统则保存在子目录下，例如 `fs/ext4` 。

## 挂载

以下的讲解都以 ext4 为例，其对应的代码在 `fs/ext4` 目录下。

在系统启动时，会通过 `register_filesystem()` 注册一个文件系统，注册过程实际上将表示各实际文件系统的 `struct file_system_type` 数据结构实例化，并添加到一个链表，内核中用一个名为 `file_systems` 的全局变量来指向该链表的表头。

struct file_system_type {
	const char *name;  # 文件系统的名称，唯一标示
	int fs_flags;
	struct dentry *(*mount) (struct file_system_type *, int,
			const char *, void *);   # 关键的mount操作，用于挂在文件系统
	void (*kill_sb) (struct super_block *);
	struct module *owner;
	struct file_system_type * next; # 链表指针
	struct hlist_head fs_supers;
};

对于每个 mount 的文件系统，都会为它创建一个 `struct super_block` 的数据结构，该结构体保存了文件系统以及挂载点的相关信息。

由于可以在不同的路径挂载同一个文件系统，例如 `/`、`/home`、`/opt` 都挂载了 `ext4` 文件系统，因此同一个文件系统类型会对应多个 `struct super_block` 结构体，而 `fs_supers` 成员就把这个文件系统类型对应的所有 `struct super_block` 都链接起来。

其中比较关键的是 `mount` 回调函数，它是 VFS 能够和底层文件系统交互的起始点，用于处理用户空间的 mount 命令，会读取磁盘数据并实例化一个对应的 `struct super_block` 结构体，对应到 ext4 中就是 `ext4_mount()` 函数。

struct super_block {
	struct file_system_type *s_type;     // 指向文件系统的反向指针
	const struct super_operations *s_op; // 与super block相关的核心操作
};


### 总结

挂载就是实例化一个 `struct super_block` 结构体，并添加到 `fs_supers` 链表上，每个挂载点会对应一个 `struct super_block` 实例。

##

关于各个结构体之间的相互关联关系，有不错的图表可供参考
https://www.linux.it/~rubini/docs/vfs/vfs.html

https://blog.csdn.net/jasonchen_gbd/article/details/51511261
https://blog.csdn.net/u010424605/article/details/41842877
http://hushi55.github.io/2015/10/19/linux-kernel-vfs
https://lihaoquan.me/2019/2/16/linux-vfs.html


该函数是不能放在super_block结构中的，因为super_block是在get_sb执行之后才能建立的。get_sb从底层文件系统获取super_block的信息，是和底层文件系统相关的。

## VFS

虚拟文件系统有四个主要对象类型：
（1）superblock 表示特定加载的文件系统。
（2）inode 表示特定的文件。
（3）dentry 表示一个目录项，路径的一个组成部分。
（4）file 表示进程打开的一个文件。


Superblock

超级块（spuerblock）对象由各自的文件系统实现，用来存储文件系统的信息。这个对 象对应为文件系统超级块或者文件系统控制块，它存储在磁盘特定的扇区上。不是基于磁盘 的文件系统（基于内存的虚拟文件系统，如sysfs）临时生成超级块，并保存在内存中。

Inode

索引节点对象包含了内核在操作文件或目录时需要的全部信息。对于Unix文件系统来 说，这些信息可以从磁盘索引节点直接读入。如果一个文件系统没有索引节点，那么，不管 这些相关信息在磁盘上是怎么存放的，文件系统都必须从中提取这些信息。

Dentry

为了方便查找，VFS引入目录项的概念。每个dentry代表路径中一个特定部分。对于 /bin/ls来说，/、bin和ls都是目录项对象。前面是两个目录，最后一个是普通文件。在路径中， 包括普通文件在内，每一个部分都是目录项对象。解析一个路径是一个耗时的、常规的字符 串比较过程。

File

VFS最后一个主要对象是文件对象。文件对象表示进程已打开的文件。如果我们站在用 户空间的角度考虑VFS，文件对象会首先进入我们的视野。进程直接处理的是文件，而不是 超级块、索引节点或目录项。文件对象包含我们非常熟悉的信息（如访问模式、当前偏移等）， 同样道理，文件操作和我们非常熟悉的系统调用read（）和write（）等也很类似。

文件对象是已打开的文件在内存中的表示。该对象（不是物理文件）由相应的open（） 系统调用创建，由close（）系统调用销毁，所有这些文件相关的调用实际上都是文件操作 表中定义的方法。

## 参考

[A tour of the Linux VFS](https://www.tldp.org/LDP/khg/HyperNews/get/fs/vfstour.html) 关于虚拟文件系统的概览介绍。

图片不错
https://lihaoquan.me/2019/2/16/linux-vfs.html
在 NUMA 系统上，由于不同 CPU 访问本地内存和远端内存的时间相差很大，所以为了更好地调度 Linux 内核引入了 Scheduling Domain 概念。

https://www.linux.it/~rubini/docs/vfs/vfs.html

http://www.haifux.org/lectures/119/linux-2.4-vfs/vfs_relations_static.png
-->


  <hr>
  <nav>
    <ul class="pager">
         <li class="previous"><a href="/post/linux-file-operations.html" title="Linux 文件操作">&larr; Older</a></li> 
         <li class="next"><a href="/post/linux-commands-text-awk-introduce.html" title="Linux 常用命令 AWK">Newer &rarr;</a></li> 
    </ul>
  </nav><br>
<!--
  <hr><div id="section-donate"><span>赏</span></div><br>
  <p style="text-indent:0px;text-align:center;">如果喜欢这里的文章，而且又不差钱的话，欢迎打赏个早餐 ^_^</p><br>
  <div class="row" style="text-align:center;" >
    <div class="col-md-6"><img src="/images/system/barcode-pay-alipay.jpg" style="width:150px;height:150px;" title="支付宝捐赠" /><br>支付宝打赏</div>
    <div class="col-md-6"><img src="/images/system/barcode-pay-wechat.jpg" style="width:150px;height:150px;" title="微信捐赠" /><br>微信打赏</div>
  </div><br><hr>
-->
  <p style="text-indent:0px;text-align:center;">如果喜欢这里的文章，而且又不差钱的话，欢迎打赏个早餐 ^_^</p>
  <div id="donate_module">
    <style type="text/css">
      .donate_bar a.btn_donate{
        display: inline-block;
        position:      relative;
        text-align:    center;
        width: 82px;
        height: 82px;
        background: url("/images/misc/btn_reward.gif") no-repeat;
        _background: url("/images/misc/btn_reward.gif") no-repeat;
        -webkit-transition: background 0s;
        -moz-transition: background 0s;
        -o-transition: background 0s;
        -ms-transition: background 0s;
        transition: background 0s;
      }
      .donate_bar a.btn_donate:hover{ background-position: 0px -82px;}
      .donate_bar .donate_txt {
        display: block;
        color: #9d9d9d;
        font: 14px/2 "Microsoft Yahei";
      }
    </style>
    <div id="donate_board" class="donate_bar row" style="text-align:center;" >
      <a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏"></a>
    </div>
    <div id="donate_guide" class="donate_bar center hidden">
      <div class="row" style="text-align:center;" >
        <div class="col-md-6"><img src="/images/system/barcode-pay-alipay.jpg" style="width:150px;height:150px;" title="支付宝捐赠" /><br>支付宝打赏</div>
        <div class="col-md-6"><img src="/images/system/barcode-pay-wechat.jpg" style="width:150px;height:150px;" title="微信捐赠" /><br>微信打赏</div>
      </div>
    </div>
    <script type="text/javascript">
      document.getElementById('btn_donate').onclick = function(){
        $('#donate_board').addClass('hidden');
        $('#donate_guide').removeClass('hidden');
      }
      function donate_on_web(){
        $('#donate').submit();
      }
    </script>
  </div>

  <hr>

  <div id="gitmentContainer"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
  var gitment = new Gitment({
      id: '1394812800',
      owner: 'Jin-Yang',
      repo: 'jin-yang.github.com',
      oauth: {
          client_id: '6d89d48ce689192bf95d',
          client_secret: 'c9a720aafb8e3084e3feb46cadee80b03cdc792f',
      },
  });
  gitment.render('gitmentContainer');
  </script>

  <!-- 多说评论框 start -->
  <!--<div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>-->
  <!--
  <div class="ds-thread" data-thread-key="/post/linux-kernel-virtual-file-system-introduce.html" data-title="Linux VFS 文件系统" data-url="/post/linux-kernel-virtual-file-system-introduce.html"></div>
  -->
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <!--
  <script type="text/javascript">
      var duoshuoQuery = {short_name:"jinyangposts"};
      (function() {
          var ds = document.createElement('script');
          ds.type = 'text/javascript';ds.async = true;
          ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
          ds.charset = 'UTF-8';
          (document.getElementsByTagName('head')[0]
           || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
  </script>
  -->
  <!-- 多说公共JS代码 end -->
</div>

    </div>
    <div class="col-lg-3 visible-lg blog-sidebar">
    <center><a href="/"><img src="/images/system/linux-liberty.png" width="200" /></a></center>
<h2>About This Blog</h2>
<div class="sidebar-module">
<p style="text-indent:0em;margin:0px;padding:0px;">This is a personal weblog ^_^ generated with Jekyll, if you like it or have some questions,
just feel free to contact me :)</p>
</div><!-- end of "node" "about" -->



<h2>Recent Posts</h2>
<div class="list-group">
  
    <a class="list-group-item" href="/post/linux-program-cpu-cache-introduce_init.html">CPU Cache</a>
  
    <a class="list-group-item" href="/post/artificial-intelligence-decision-tree-introduce.html">决策树</a>
  
    <a class="list-group-item" href="/post/linux-ebpf-bcc-tools-introduce.html">BCC 工具使用</a>
  
    <a class="list-group-item" href="/post/linux-ebpf-basic-usage-introduce.html">eBPF 简介</a>
  
    <a class="list-group-item" href="/post/math-monte-carlo-sample-introduce.html">采样算法</a>
  
</div>

<h2>Categories</h2>
<ul class="list-group" style="margin:0px;">
  
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#bash"> bash</a>
    <span class="badge">2</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#database"> database</a>
    <span class="badge">86</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#golang"> golang</a>
    <span class="badge">28</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#linux"> linux</a>
    <span class="badge">301</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#misc"> misc</a>
    <span class="badge">244</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#mysql"> mysql</a>
    <span class="badge">79</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#network"> network</a>
    <span class="badge">49</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#postgresql"> postgresql</a>
    <span class="badge">4</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#program"> program</a>
    <span class="badge">138</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#python"> python</a>
    <span class="badge">25</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#react"> react</a>
    <span class="badge">1</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#rtems"> rtems</a>
    <span class="badge">1</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#sql"> sql</a>
    <span class="badge">10</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#tools"> tools</a>
    <span class="badge">1</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#webserver"> webserver</a>
    <span class="badge">25</span>
  </li>
  
</ul><!-- end of "node" "categories" -->

<h2>Related Links</h2>
<ul class="list-group" style="margin:0px">
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
       <a href="http://www.rtems.org" title="To RTEMS"><img class="img-thumbnail img-responsive" src="/images/system/rtems.png"  alt="RTEMS"/></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>RTEMS</strong><br>
        <div class="sidebar-description">Real-Time Executive for Multiprocessor System</div>
      </div>
    </div>
  </li>
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
       <a href="http://www.gnu.org" title="To GNU">
       <img class="img-thumbnail img-responsive" src="/images/system/gnu.jpg" alt="GNU" /></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>GNU</strong><br>
        <div class="sidebar-description">A Unix-linux Operating System</div>
      </div>
    </div>
  </li>
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
    <a href="http://www.kernel.org" title="To Linux Kernel">
    <img class="img-thumbnail img-responsive" src="/images/system/linux.png"  alt="LINUX" /></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>Linux Kernel</strong><br>
        <div class="sidebar-description">Maintained by Linux Kernel Organization</div>
      </div>
    </div>
  </li>
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
    <a href="http://arduino.cc" title="To Arduino">
    <img class="img-thumbnail img-responsive" src="/images/system/arduino.png"  alt="ARDUINO" /></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>Arduino</strong><br>
        <div class="sidebar-description">Open-source Electronic Prototyping Platform</div>
      </div>
    </div>
  </li>
</ul>

<h2>Search</h2>
<div class="sidebar-module">
  <form class="search" method="GET" action="https://www.google.com.hk/search">
    <input type="text" name="q" class="search-query" placeholder=" Search on Google">
    <input type="hidden" name="ie" value="utf-8">
    <input type="submit" name="sa" value="Search" />
  </form><br>
  <input type="text" class="search-field" placeholder=" Search This Site">
  <div class="search-results"></div>
</div>



    </div>
  </div>
<hr><p class="text-center">This Site was built by Jin Yang, generated with Jekyll, and hosted on GitHub Pages<br/> &copy;2013-2019 &ndash; Jin Yang</p><div class="footer-logo"></div>

</div>
</body>
</html>
