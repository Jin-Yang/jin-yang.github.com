<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="baidu-site-verification" content="B786jeR0MV" />
  <meta name="msvalidate.01" content="29F791E7F785800340E37AD7C714D2A7" />
  <meta name="google-site-verification" content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0" />
  <title>Linux Cache VS. Buffer|JinYang's Blog</title>
  <meta name="keywords" content="">
  <meta name="description" content="">

  <script src="https://cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>
  <script type="text/javascript">
  !window.jQuery && document.write('<script src="/static/js/jquery.min.js"><\/script>');
  </script>
  <script src="https://cdn.bootcss.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
  <script type="text/javascript">
  !$('body').popover && document.write('<script src="/static/js/bootstrap.min.js"><\/script>');
  </script>
  <script type="text/javascript" src="/static/js/main.js"></script>
  <!-- <link rel="stylesheet prefetch" href="http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css"> -->
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/bootstrap.min.css">
  <!-- <link href="http://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/font-awesome.min.css">
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/pygments.css">
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/screen.css">
  <style type="text/css">
  
    .post-container > p {text-indent: 2em;}
  
  </style>
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-124556620-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-124556620-1');
</script>

</head>

<body>
<nav class="navbar navbar-default navbar-inverse navbar-fixed-top navbar-wrapper">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span>
      </button><a class="navbar-brand" href="/">Jin-Yang</a>
    </div>
    <div id="navbar" class="collapse navbar-collapse">
      <ul class="nav navbar-nav">
        <li  ><a href="/"> Home </a></li>
        <li  ><a href="/archives.html"> Archive </a></li>
        <li  ><a href="/categories.html"> Categories </a></li>
        <li  ><a href="/projects.html"> Projects </a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"> Others <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li class="dropdown-header">常用网站</li>
            <li role="separator" class="divider"></li>
            <li><a href="https://www.rtems.org/">www.rtems.org</a></li>
            <li><a href="http://www.gnu.org/">www.gnu.org</a></li>
            <li><a href="https://www.kernel.org/">www.kernel.org</a></li>
            <li><a href="https://www.arduino.cc/">www.arduino.cc</a></li>
          </ul>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li  ><a href="/about.html"> About </a></li>
      </ul>
    </div><!--/.nav-collapse -->
  </div>
</nav>

<div id="myCarousel" class="carousel slide" data-ride="carousel">
  <!-- Indicators -->
  <ol class="carousel-indicators">
    <li data-target="#myCarousel" data-slide-to="0" class="active"></li>
    <li data-target="#myCarousel" data-slide-to="1"></li>
    <li data-target="#myCarousel" data-slide-to="2"></li>
    <li data-target="#myCarousel" data-slide-to="3"></li>
    <li data-target="#myCarousel" data-slide-to="4"></li>
  </ol>
  <div class="carousel-inner" role="listbox">
    <div class="item active">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>KISS</h1>
          <h2>Keep It Simple and Stupid.</h2>
          <!--<a class="btn btn-lg btn-primary" href="#" role="button">Sign up today</a>-->
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Seize The Day</h1><h1>And Get Busy Living</h1>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Stay hungry</h1><h1>Stay foolish</h1>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
	  <h2>Ever tried, ever failed</h2><h2>No matter, try again</h2><h2>Fail again, fail better</h2>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Nothing is true</h1><h1>Every is permitted</h1>
        </div>
      </div>
    </div>
  </div>
  <a class="left carousel-control" href="#myCarousel" role="button" data-slide="prev">
    <span class="glyphicon glyphicon-chevron-left"></span>
    <span class="sr-only">Previous</span>
  </a>
  <a class="right carousel-control" href="#myCarousel" role="button" data-slide="next">
    <span class="glyphicon glyphicon-chevron-right"></span>
    <span class="sr-only">Next</span>
  </a>
</div><!-- /.carousel -->

<div class="container">
  <div class="row">
    <div class="col-lg-9 blog-main" style="min-width: 500px">
    
<div class="post-container">
  <div class="blog-header">
    <h1>Linux Cache VS. Buffer</h1>
    <div class="post-description">
      <i class="fa fa-calendar"></i> 2018-07-28 Saturday &nbsp; &nbsp;
      <i class="fa fa-tags"></i>  linux  
      
    </div>
  </div>
  <hr>
  <p>实际上 Buffer 和 Cache 是两个用烂的词，在不同的场景下其语义会有所区别。在 Linux 的内存管理中，Buffer 是指 Buffer Cache(缓冲区缓存)，Cache 是指 Page Cache(页面缓存)。</p>

<p>这里简单介绍其概念。</p>

<!-- more -->

<h2 id="简介">简介</h2>

<p>曾经 Buffer 被用来做 IO 设备的写缓存，Cache 被用来作为 IO  设备的读缓存，这里的 IO 设备，主要指的是块设备文件和文件系统上的普通文件；但是现在，它们的意义已经不一样了。</p>

<p>在当前的内核中，PageCache 就是针对内存页的缓存，如果有内存是以 Page 进行分配管理的，都可以使用 PageCache 作为其缓存来管理使用。</p>

<p>当然，不是所有的内存都是以 Page 为单位进行管理，也有很多是针对块 Block 进行管理的，如果这部分需要使用到 Cache 功能，则都集中到 BufferCache 中，从这一角度来说，改称为 BlockCache 更为合适。</p>

<h3 id="前世今生">前世今生</h3>

<p>简单来说，两者都是为了优化磁盘 IO 的读写速率，其中 PageCache 缓存了文件页用来优化文件 IO；而 BufferCache 缓存了磁盘块用来优化块设备的 IO 。</p>

<p>很多的类 Unix 系统采用了与 Linux 2.4 之前版本类似的策略，也就是文件缓存在 PageCache 而磁盘块缓存在 BufferCache。</p>

<p>而实际上，大部分文件是通过文件系统呈现，而且存储在磁盘上，这就会导致同一份文件保存了两份，不优雅也不高效，为此，在 Linux 2.4 版本之后，就将两者进行了统一。</p>

<p>如果被缓存的数据即是文件数据又是块数据 (对于文件来说大部分的数据是的，元数据不是)，此时 BufferCache 会有指针指向 PageCache ，这样数据就只需要在内存中缓存一份。当讨论磁盘缓存时，其实就是 PageCache ，它缓存了磁盘文件数据，从而提高 IO 的吞吐量。</p>

<p>当然，目前 BufferCache 仍然是存在的，因为还存在需要执行的块 IO。因为大多数块都是用来存储文件数据，所以大部分 BufferCache 都指向了 PageCache；但还是有一小部分块并不是文件数据，例如元数据、RawBlock IO，此时还需要通过 BufferCache 来缓存。</p>

<p>明白了这两套缓存系统的区别，就可以理解它们究竟都可以用来做什么了。</p>

<h3 id="page-cache">Page Cache</h3>

<p>主要用来作为文件系统上的文件数据的缓存，常见的是针对文件的 <code>read()/write()</code> 操作，另外也包括了通过 <code>mmap()</code> 映射之后的块设备，也就是说，事实上 Page Cache 负责了大部分的块设备文件的缓存工作。</p>

<h3 id="buffer-cache">Buffer Cache</h3>

<p>BufferCache 用来在系统对块设备进行读写的时候，对块进行数据缓存的系统来使用，例如格式化文件系统时。</p>

<!--
一般情况下两个缓存系统是一起配合使用的，比如当我们对一个文件进行写操作的时候，page cache的内容会被改变，而buffer cache则可以用来将page标记为不同的缓冲区，并记录是哪一个缓冲区被修改了。这样，内核在后续执行脏数据的回写（writeback）时，就不用将整个page写回，而只需要写回修改的部分即可。
-->

<h3 id="总结">总结</h3>

<p>磁盘有逻辑 (文件系统) 和物理 (磁盘块) 两种操作，分别对应了 Page Cache 和 Buffer Cache 。简单来说，如果直接通过 <code>read()/write()</code> 等直接去操作文件，那使用的就是 Page Cache 缓存，而使用 dd 等命令直接操作磁盘块，就是 Buffer Cache 缓存。</p>

<p>注意，块 Block 的大小由所使用块设备决定，而页在 x86 上无论是 32 位还是 64 位都是 4K 。</p>

<h2 id="测试">测试</h2>

<p>那么 free 命令中的 buffers 和 cache 是什么意思？</p>

<p>该命令读取的是 <code>/proc/meminfo</code> 文件中的数据，可以从是否有 available 判断是否为最新版本，对于老版本计算方式如下：</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">cache = Cached + SwapCached + SReclaimable;
available = MemFree + Buffers + cache</code></pre></figure>

<h3 id="free">free</h3>

<p>新版的 free 命令输出如下。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ free -wm
              total        used        free      shared     buffers       cache   available
Mem:           7881        3109         797        1113         309        3665        3310
Swap:          7936         260        7676</code></pre></figure>

<ul>
  <li>buffers，表示块设备 (block device) 所占用的缓存页，包括了直接读写块设备以及文件系统元数据 (metadata) 比如 SuperBlock 所使用的缓存页；</li>
  <li>cached，表示普通文件系统中数据所占用的缓存页。</li>
</ul>

<p>如上所述，该命令读取的是 <code>/proc/meminfo</code> 文件中的 Buffers 和 Cached 数据，而在内核中的实现实际上对应了 <code>meminfo_proc_show()@fs/proc/meminfo.c</code> 函数，内容如下。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">int</span> <span class="nf">meminfo_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">si_meminfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// 通过nr_blockdev_pages()函数填充bufferram</span>
    <span class="n">si_swapinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>

    <span class="n">cached</span> <span class="o">=</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_FILE_PAGES</span><span class="p">)</span> <span class="o">-</span>
            <span class="n">total_swapcache_pages</span><span class="p">()</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">bufferram</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cached</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cached</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
        <span class="s">&quot;Buffers:        %8lu kB</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="s">&quot;Cached:         %8lu kB</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="c1">// ... ..</span>
        <span class="n">K</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">bufferram</span><span class="p">),</span>
        <span class="n">K</span><span class="p">(</span><span class="n">cached</span><span class="p">),</span>
        <span class="c1">// ... ..</span>
<span class="p">}</span></code></pre></figure>

<p>如上计算 cached 公式中，<code>global_page_state(NR_FILE_PAGES)</code> 实际读取的 <code>vmstat[NR_FILE_PAGES]</code>，也就是用于统计所有缓存页 (page cache) 的总和，它包括：</p>

<!--
mm/filemap.c:200:       __dec_zone_page_state(page, NR_FILE_PAGES);
mm/filemap.c:488:               __inc_zone_page_state(new, NR_FILE_PAGES);
mm/filemap.c:580:       __inc_zone_page_state(page, NR_FILE_PAGES);
mm/swap_state.c:105:            __inc_zone_page_state(page, NR_FILE_PAGES);
mm/swap_state.c:157:    __dec_zone_page_state(page, NR_FILE_PAGES);
mm/shmem.c:318:         __inc_zone_page_state(page, NR_FILE_PAGES);
mm/shmem.c:341: __dec_zone_page_state(page, NR_FILE_PAGES);
mm/shmem.c:1003:                __inc_zone_page_state(newpage, NR_FILE_PAGES);
mm/shmem.c:1004:                __dec_zone_page_state(oldpage, NR_FILE_PAGES);
mm/migrate.c:414:       __dec_zone_page_state(page, NR_FILE_PAGES);
mm/migrate.c:415:       __inc_zone_page_state(newpage, NR_FILE_PAGES);

    Cached
    buffers
    交换区缓存(swap cache)
-->

<blockquote>
  <p>swap cache 主要是针对匿名内存页，例如用户进程通过 malloc() 申请的内存页，当要发生 swapping 换页时，如果一个匿名页要被换出时，会先计入到 swap cache，但是不会立刻写入物理交换区，因为 Linux 的原则是除非绝对必要，尽量避免 IO。</p>

  <p>所以 swap cache 中包含的是被确定要 swapping 换页，但是尚未写入物理交换区的匿名内存页。</p>
</blockquote>

<!--
vmstat[NR_FILE_PAGES] 可以通过 /proc/vmstat 来查看，表示所有缓存页的总数量：
# cat /proc/vmstat
...
nr_file_pages 587334
...


注意以上nr_file_pages是以page为单位，而不像free命令是以KB为单位，一个page等于4KB。

    直接修改 nr_file_pages 的内核函数是：
    __inc_zone_page_state(page, NR_FILE_PAGES) 和
    __dec_zone_page_state(page, NR_FILE_PAGES)，
    一个用于增加，一个用于减少。


先看”cached”：

“Cached” 就是除去 “buffers” 和 “swap cache” 之外的缓存页的数量：
global_page_state(NR_FILE_PAGES) – total_swapcache_pages – i.bufferram
所以关键还是要理解 “buffers” 是什么含义。


#### buffers

从源码中可以看到 buffers 来自于 nr_blockdev_pages() 的返回值，该函数如下：


<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">long</span> <span class="nf">nr_blockdev_pages</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdev_lock</span><span class="p">);</span>
    <span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">all_bdevs</span><span class="p">,</span> <span class="n">bd_list</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdev_lock</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>


这段代码就是遍历所有的块设备 (block device)，累加每个块设备的 inode 的 i_mapping 的页数，统计得到的就是 buffers 。所以很明显，buffers 是与块设备直接相关的。

那么谁会更新块设备的缓存页数量(nrpages)呢？我们继续向下看。

搜索kernel源代码发现，最终更新mapping->nrpages字段的函数就是add_to_page_cache和__remove_from_page_cache：

static inline int add_to_page_cache(struct page *page,
                struct address_space *mapping, pgoff_t offset, gfp_t gfp_mask)
{
        int error;

        __set_page_locked(page);
        error = add_to_page_cache_locked(page, mapping, offset, gfp_mask);
        if (unlikely(error))
                __clear_page_locked(page);
        return error;
}

void remove_from_page_cache(struct page *page)
{
        struct address_space *mapping = page->mapping;
        void (*freepage)(struct page *) = NULL;
        struct inode *inode = mapping->host;

        BUG_ON(!PageLocked(page));

        if (IS_AOP_EXT(inode))
                freepage = EXT_AOPS(mapping->a_ops)->freepage;

        spin_lock_irq(&mapping->tree_lock);
        __remove_from_page_cache(page);
        spin_unlock_irq(&mapping->tree_lock);
        mem_cgroup_uncharge_cache_page(page);

        if (freepage)
                freepage(page);
}

page_cache_tree_insert()

__delete_from_page_cache()
 |-page_cache_tree_delete() --

这两个函数是通用的，block device 和 文件inode 都可以调用，至于更新的是块设备的(buffers)还是文件的(cached)，取决于调用参数变量mapping：如果mapping对应的是文件inode，自然就不会影响到 “buffers”；如果mapping对应的是块设备，那么相应的统计信息会反映在 “buffers” 中。我们下面看看kernel中哪些地方会把块设备的mapping传递进来。

搜索内核源代码发现，ext4_readdir 函数调用 page_cache_sync_readahead 时传递的参数是 sb->s_bdev->bd_inode->i_mapping，其中s_bdev就是块设备，也就是说在读目录(ext4_readdir)的时候可能会增加 “buffers” 的值：
static int ext4_readdir(struct file *filp,
                         void *dirent, filldir_t filldir)
{

...
        struct super_block *sb = inode->i_sb;
...
                        if (!ra_has_index(&filp->f_ra, index))
                                page_cache_sync_readahead(
                                        sb->s_bdev->bd_inode->i_mapping,
                                        &filp->f_ra, filp,
                                        index, 1);
...
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14

static int ext4_readdir(struct file *filp,
                         void *dirent, filldir_t filldir)
{

...
        struct super_block *sb = inode->i_sb;
...
                        if (!ra_has_index(&filp->f_ra, index))
                                page_cache_sync_readahead(
                                        sb->s_bdev->bd_inode->i_mapping,
                                        &filp->f_ra, filp,
                                        index, 1);
...
}

继续琢磨上面的代码，sb表示SuperBlock，属于文件系统的metadata（元数据），突然间一切恍然大悟：因为metadata不属于文件，没有对应的inode，所以，对metadata操作所涉及的缓存页都只能利用块设备mapping，算入 buffers 的统计值内。

    打个岔：ext4_readdir() 中调用 page_cache_sync_readahead() 显然是在进行预读(read-ahead)，为什么read-ahead没有使用普通文件inode的mapping，而是使用了底层的块设备呢？从记载在补丁中的说明来看，这是一个权宜之计，看这里，所以不必深究了。

举一反三，如果文件含有间接块(indirect blocks)，因为间接块属于metadata，所以走的也是块设备的mapping。查看源代码，果然如此：
ext4_get_blocks
->  ext4_ind_get_blocks
    ->  ext4_get_branch
        ->  sb_getblk

static inline struct buffer_head *
sb_getblk(struct super_block *sb, sector_t block)
{
        return __getblk(sb->s_bdev, block, sb->s_blocksize);
}
1
2
3
4
5
6
7
8
9
10

ext4_get_blocks
->  ext4_ind_get_blocks
    ->  ext4_get_branch
        ->  sb_getblk

static inline struct buffer_head *
sb_getblk(struct super_block *sb, sector_t block)
{
        return __getblk(sb->s_bdev, block, sb->s_blocksize);
}

这样，我们就知道了，”buffers” 是块设备(block device)占用的缓存页，分为两种情况：

    直接对块设备进行读写操作；
    文件系统的metadata（元数据），比如 SuperBlock。
-->

<h3 id="验证">验证</h3>

<p>如上，读取 EXT4 文件系统的目录会使用到 “buffers”，这里使用 find 命令扫描文件系统，观察 “buffers” 增加的情况：</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># sync
# echo 3 &gt; /proc/sys/vm/drop_caches
$ free -wk; find ~ -name &quot;not exits file&quot; &gt;/dev/null 2&gt;&amp;1; free -wk
              total        used        free      shared     buffers       cache   available
Mem:        8070604     3260408     3445852     1102588        5236     1359108     3418844
Swap:       8127484      300172     7827312
              total        used        free      shared     buffers       cache   available
Mem:        8070604     3249764     3207336     1087716      250484     1363020     3417764
Swap:       8127484      300172     7827312</code></pre></figure>

<p>再测试下直接读取 block device 并观察 “buffers” 增加的现象：</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># sync
# echo 3 &gt; /proc/sys/vm/drop_caches
# free -wk; dd if=/dev/sda1 of=/dev/null count=200M; free -wk
              total        used        free      shared     buffers       cache   available
Mem:        8070604     3244516     3486124     1094648         932     1339032     3451048
Swap:       8127484      300172     7827312
532480+0 records in
532480+0 records out
272629760 bytes (273 MB) copied, 0.612241 s, 445 MB/s
              total        used        free      shared     buffers       cache   available
Mem:        8070604     3245032     3218528     1094868      267196     1339848     3427012
Swap:       8127484      300172     7827312</code></pre></figure>

<p>找个比较大的文件，然后通过 cat 命令读取，可以看到对应的 cache 会增加。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># sync
# echo 3 &gt; /proc/sys/vm/drop_caches
# free -wk; cat /your/big/file/path; free -wk
              total        used        free      shared     buffers       cache   available
Mem:        8070604     3244516     3486124     1094648         932      423384     3451048
Swap:       8127484      300172     7827312
532480+0 records in
532480+0 records out
272629760 bytes (273 MB) copied, 0.612241 s, 445 MB/s
              total        used        free      shared     buffers       cache   available
Mem:        8070604     3245032     3218528     1094868        2354     1019960     3427012
Swap:       8127484      300172     7827312</code></pre></figure>

<!--
free 命令所显示的 “buffers” 表示块设备(block device)所占用的缓存页，包括直接读写块设备、以及文件系统元数据(metadata)如SuperBlock所使用的缓存页；
而 “cached” 表示普通文件所占用的缓存页。
-->

<h2 id="mincore">mincore</h2>

<p>在内核中有个 <code>man mincore(2)</code> 的系统调用，其实现在 <code>mm/mincore.c</code> 中，主要用来判断页面的状态，可以使用 <code>fincore</code> 工具查看。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">mincore -- determine whether pages are resident in memory</code></pre></figure>

<p>最早是由 google 开发，不过已经是七八年前的事情了，现在几乎不再维护，可以从 github 上查找相关的代码。</p>

<p>去掉了异常处理之外，其处理过程大致如下。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">fd = open(fname, O_RDONLY);
if (fstat(fd, &amp;stat) &lt; 0) {
file_pages = (stat.st_size + page_size - 1) / page_size;
vec = malloc(file_pages);
fmap = mmap(NULL, stat.st_size, PROT_NONE, MAP_SHARED, fd, 0);
if (mincore(fmap, stat.st_size, vec) != 0 ) {
if (vec[i] &amp; 1) {</code></pre></figure>

<p><code>open()</code> 获得文件描述符，<code>fstat()</code> 获取文件的长度，页面的大小可以通过系统调用获取，一般是 4K ，有了文件大小，就知道了，需要多少个 <code>int</code> 来存放结果。</p>

<p><code>mmap()</code> 建立映射关系，<code>mincore()</code> 获取文件页面的驻留情况，从起始地址开始，长度是 filesize，结果保存在 <code>vec</code> 数组里，如果 <code>vec[i] &amp; 1 == 1</code> 那么表示该页面驻留在内存中，否则没有对应缓存。</p>

<p>另外，一个不错的工具可以参考 <a href="https://github.com/hoytech/vmtouch/">vmtouch</a> 。</p>

<h2 id="回收-cache">回收 Cache</h2>

<p>内核在内存将要耗尽时，会触发内存回收的工作，一般来说主要释放的是 Buffer/Cache 的内存，但是这种清缓存的操作也并不是没有成本。</p>

<p>理解 Buffer Cache 的作用，那么如果要清理缓存，那么必须要保证数据的一致性，所以一般在清理的时候同时会伴随这 IO 彪高。因为内核要对比内存中的数据和对应硬盘文件上的数据是否一致，如果不一致需要写回，之后才能回收。</p>

<h3 id="手动触发">手动触发</h3>

<p>在系统中除了内存将被耗尽的时候可以清缓存以外，还可以使用下面这个文件来人工触发缓存清除的操作。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># echo 1 &gt; /proc/sys/vm/drop_caches</code></pre></figure>

<p>其中的取值可以是 <code>1</code> <code>2</code> <code>3</code>，代表的含义为：</p>

<ul>
  <li><code>1</code> 清除 PageCache；</li>
  <li><code>2</code> 回收 slab 分配器中的对象 (包括目录项缓存和 inode 缓存)，slab 是内核中管理内存的一种机制，其中很多缓存数据实现都是用的 PageCache；</li>
  <li><code>3</code> 清除 PageCache 和 slab 分配器中的缓存对象。</li>
</ul>

<p>这部分内核代码位于 <code>fs/drop_caches.c</code> 里面。</p>

<h3 id="fadvise">fadvise</h3>

<p>除了上述粗暴的方法外，Linux 还提供了 <code>posix_fadvise()</code> 系统调用，允许用户给 Linux 提建议。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;fcntl.h&gt;</span>

<span class="kt">int</span> <span class="nf">posix_fadvise</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">advice</span><span class="p">);</span></code></pre></figure>

<p>其中比较常用的有两个选项，可以通过 <code>posix_fadvise(2)</code> 查看，信息摘抄如下。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">POSIX_FADV_WILLNEED
	The specified data will be accessed in the near future.

POSIX_FADV_DONTNEED
	The specified data will not be accessed in the near future.</code></pre></figure>

<p>其中，其含义如下：</p>

<ul>
  <li><code>POSIX_FADV_WILLNEED</code> 相当于说，这个文件在不久的将来要用，请准备好相应的页面(从磁盘读入内存)，相当于预读。</li>
  <li><code>POSIX_FADV_DONTNEED</code> 相当于告知 Linux ，这个文件不用了，直接回收掉吧，类似于 sync 操作。</li>
</ul>

<p>在 PostgreSQL 中有如下的应用：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">FilePrefetch</span><span class="p">(</span><span class="n">File</span> <span class="n">file</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(USE_POSIX_FADVISE) &amp;&amp; defined(POSIX_FADV_WILLNEED)</span>
	<span class="kt">int</span> <span class="n">returnCode</span><span class="p">;</span>

	<span class="n">Assert</span><span class="p">(</span><span class="n">FileIsValid</span><span class="p">(</span><span class="n">file</span><span class="p">));</span>

        <span class="n">DO_DB</span><span class="p">(</span><span class="n">elog</span><span class="p">(</span><span class="n">LOG</span><span class="p">,</span> <span class="s">&quot;FilePrefetch: %d (%s) &quot;</span> <span class="n">INT64_FORMAT</span> <span class="s">&quot; %d&quot;</span><span class="p">,</span>
                 <span class="n">file</span><span class="p">,</span> <span class="n">VfdCache</span><span class="p">[</span><span class="n">file</span><span class="p">].</span><span class="n">fileName</span><span class="p">,</span>
                 <span class="p">(</span><span class="n">int64</span><span class="p">)</span> <span class="n">offset</span><span class="p">,</span> <span class="n">amount</span><span class="p">));</span>

        <span class="n">returnCode</span> <span class="o">=</span> <span class="n">FileAccess</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">returnCode</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">returnCode</span><span class="p">;</span>

        <span class="n">returnCode</span> <span class="o">=</span> <span class="n">posix_fadvise</span><span class="p">(</span><span class="n">VfdCache</span><span class="p">[</span><span class="n">file</span><span class="p">].</span><span class="n">fd</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span>
                                 <span class="n">POSIX_FADV_WILLNEED</span><span class="p">);</span> <span class="c1">//预读</span>

        <span class="k">return</span> <span class="n">returnCode</span><span class="p">;</span>
<span class="cp">#else</span>
        <span class="n">Assert</span><span class="p">(</span><span class="n">FileIsValid</span><span class="p">(</span><span class="n">file</span><span class="p">));</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pg_flush_data</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">amount</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(USE_POSIX_FADVISE) &amp;&amp; defined(POSIX_FADV_DONTNEED)</span>
        <span class="k">return</span> <span class="n">posix_fadvise</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span> <span class="n">POSIX_FADV_DONTNEED</span><span class="p">);</span>
<span class="cp">#else</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span></code></pre></figure>

<p>通过 <code>fadvise</code> 就能把某文件彻底赶出缓存，代码非常简单。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">clear_file_cache</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">filename</span> <span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span> <span class="p">,</span> <span class="s">&quot;stat localfile failed, path:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">filename</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span> <span class="p">,</span> <span class="s">&quot;open localfile failed, path:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">filename</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">//clear cache by posix_fadvise</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">posix_fadvise</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">st</span><span class="p">.</span><span class="n">st_size</span><span class="p">,</span><span class="n">POSIX_FADV_DONTNEED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Cache FADV_DONTNEED failed, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Cache FADV_DONTNEED done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>其中 <code>vmtouch -e</code> 以及 <code>linux-ftools</code> 中的 <code>linux-fadvise</code> 提供了类似的功能，实际最终调用的都是 <code>posix_fadvise()</code> 接口。</p>

<p>关于 <code>posix_fadvise()</code> 接口的内核实现，可以参考霸爷的 <a href="http://blog.yufeng.info/archives/1917">posix_fadvise 清除缓存的误解和改进措施</a> 。</p>

<h2 id="其它">其它</h2>

<h3 id="stap">stap</h3>

<p>可以通过 stap 脚本查看是谁在消耗 Cache，不过配置起来比较麻烦，暂不介绍了，后面补充吧。</p>

<!--
Linux下谁在消耗我们的cache
http://blog.yufeng.info/archives/tag/mincore

## 总结

这里面的水比较深，很多地方可以扩展开来，比如缓存到什么程度，操作系统开始出面清理缓存，在比如posix_fadvise的kernel实现，在比如介绍mincore系统调用的时候，我们发现，多个系统调用组合才能得到文件的缓存信息，这太慢了，Chris Frost提出了一个新的系统调用fincore，感兴趣的可以查看http://libprefetch.cs.ucla.edu/及https://lkml.org/lkml/2013/2/15/44。 另外，低于mincore系统调用，只返回是否在文件对应对页是否存在在缓存中，这太浪费了，明明可以把是否dirty一并返回，我今天一直纠结与如何返回文件页面在缓存的dirty情况，很蛋疼，没解决。实际上mincore完全可以顺路返回这个值。毕竟int有32bit，只用一个bit太浪费了。不能展的太开，否则，就收敛不了了，另外，我的功能还不到。

file和page cache 的一些事儿
http://blog.chinaunix.net/uid-24774106-id-3625000.html
-->

<h2 id="参考">参考</h2>

<p>一个不错的工具 linux-ftools，可以直接从 <a href="/reference/linux/monitor/linux-ftools.tar.bz2">本地下载</a> 。</p>


  <hr>
  <nav>
    <ul class="pager">
         <li class="previous"><a href="/post/golang-grpc-sourcecode-details.html" title="GoLang gRPC 源码解析">&larr; Older</a></li> 
         <li class="next"><a href="/post/linux-c-mock-wrap-unit-test.html" title="Linux C Mock Wrap">Newer &rarr;</a></li> 
    </ul>
  </nav><br>
<!--
  <hr><div id="section-donate"><span>赏</span></div><br>
  <p style="text-indent:0px;text-align:center;">如果喜欢这里的文章，而且又不差钱的话，欢迎打赏个早餐 ^_^</p><br>
  <div class="row" style="text-align:center;" >
    <div class="col-md-6"><img src="/images/system/barcode-pay-alipay.jpg" style="width:150px;height:150px;" title="支付宝捐赠" /><br>支付宝打赏</div>
    <div class="col-md-6"><img src="/images/system/barcode-pay-wechat.jpg" style="width:150px;height:150px;" title="微信捐赠" /><br>微信打赏</div>
  </div><br><hr>
-->
  <p style="text-indent:0px;text-align:center;">如果喜欢这里的文章，而且又不差钱的话，欢迎打赏个早餐 ^_^</p>
  <div id="donate_module">
    <style type="text/css">
      .donate_bar a.btn_donate{
        display: inline-block;
        position:      relative;
        text-align:    center;
        width: 82px;
        height: 82px;
        background: url("/images/misc/btn_reward.gif") no-repeat;
        _background: url("/images/misc/btn_reward.gif") no-repeat;
        -webkit-transition: background 0s;
        -moz-transition: background 0s;
        -o-transition: background 0s;
        -ms-transition: background 0s;
        transition: background 0s;
      }
      .donate_bar a.btn_donate:hover{ background-position: 0px -82px;}
      .donate_bar .donate_txt {
        display: block;
        color: #9d9d9d;
        font: 14px/2 "Microsoft Yahei";
      }
    </style>
    <div id="donate_board" class="donate_bar row" style="text-align:center;" >
      <a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏"></a>
    </div>
    <div id="donate_guide" class="donate_bar center hidden">
      <div class="row" style="text-align:center;" >
        <div class="col-md-6"><img src="/images/system/barcode-pay-alipay.jpg" style="width:150px;height:150px;" title="支付宝捐赠" /><br>支付宝打赏</div>
        <div class="col-md-6"><img src="/images/system/barcode-pay-wechat.jpg" style="width:150px;height:150px;" title="微信捐赠" /><br>微信打赏</div>
      </div>
    </div>
    <script type="text/javascript">
      document.getElementById('btn_donate').onclick = function(){
        $('#donate_board').addClass('hidden');
        $('#donate_guide').removeClass('hidden');
      }
      function donate_on_web(){
        $('#donate').submit();
      }
    </script>
  </div>

  <hr>

  <div id="gitmentContainer"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
  var gitment = new Gitment({
      id: '1532707200',
      owner: 'Jin-Yang',
      repo: 'jin-yang.github.com',
      oauth: {
          client_id: '6d89d48ce689192bf95d',
          client_secret: 'c9a720aafb8e3084e3feb46cadee80b03cdc792f',
      },
  });
  gitment.render('gitmentContainer');
  </script>

  <!-- 多说评论框 start -->
  <!--<div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>-->
  <!--
  <div class="ds-thread" data-thread-key="/post/linux-memory-buffer-vs-cache-details.html" data-title="Linux Cache VS. Buffer" data-url="/post/linux-memory-buffer-vs-cache-details.html"></div>
  -->
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <!--
  <script type="text/javascript">
      var duoshuoQuery = {short_name:"jinyangposts"};
      (function() {
          var ds = document.createElement('script');
          ds.type = 'text/javascript';ds.async = true;
          ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
          ds.charset = 'UTF-8';
          (document.getElementsByTagName('head')[0]
           || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
  </script>
  -->
  <!-- 多说公共JS代码 end -->
</div>

    </div>
    <div class="col-lg-3 visible-lg blog-sidebar">
    <center><a href="/"><img src="/images/system/linux-liberty.png" width="200" /></a></center>
<h2>About This Blog</h2>
<div class="sidebar-module">
<p style="text-indent:0em;margin:0px;padding:0px;">This is a personal weblog ^_^ generated with Jekyll, if you like it or have some questions,
just feel free to contact me :)</p>
</div><!-- end of "node" "about" -->



<h2>Recent Posts</h2>
<div class="list-group">
  
    <a class="list-group-item" href="/post/linux-program-cpu-cache-introduce_init.html">CPU Cache</a>
  
    <a class="list-group-item" href="/post/artificial-intelligence-decision-tree-introduce.html">决策树</a>
  
    <a class="list-group-item" href="/post/linux-ebpf-bcc-tools-introduce.html">BCC 工具使用</a>
  
    <a class="list-group-item" href="/post/linux-ebpf-basic-usage-introduce.html">eBPF 简介</a>
  
    <a class="list-group-item" href="/post/math-monte-carlo-sample-introduce.html">采样算法</a>
  
</div>

<h2>Categories</h2>
<ul class="list-group" style="margin:0px;">
  
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#bash"> bash</a>
    <span class="badge">2</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#database"> database</a>
    <span class="badge">86</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#golang"> golang</a>
    <span class="badge">28</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#linux"> linux</a>
    <span class="badge">301</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#misc"> misc</a>
    <span class="badge">244</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#mysql"> mysql</a>
    <span class="badge">79</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#network"> network</a>
    <span class="badge">49</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#postgresql"> postgresql</a>
    <span class="badge">4</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#program"> program</a>
    <span class="badge">138</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#python"> python</a>
    <span class="badge">25</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#react"> react</a>
    <span class="badge">1</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#rtems"> rtems</a>
    <span class="badge">1</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#sql"> sql</a>
    <span class="badge">10</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#tools"> tools</a>
    <span class="badge">1</span>
  </li>
  
    <li style="margin-left:0em" class="list-group-item"><a href="/categories.html#webserver"> webserver</a>
    <span class="badge">25</span>
  </li>
  
</ul><!-- end of "node" "categories" -->

<h2>Related Links</h2>
<ul class="list-group" style="margin:0px">
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
       <a href="http://www.rtems.org" title="To RTEMS"><img class="img-thumbnail img-responsive" src="/images/system/rtems.png"  alt="RTEMS"/></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>RTEMS</strong><br>
        <div class="sidebar-description">Real-Time Executive for Multiprocessor System</div>
      </div>
    </div>
  </li>
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
       <a href="http://www.gnu.org" title="To GNU">
       <img class="img-thumbnail img-responsive" src="/images/system/gnu.jpg" alt="GNU" /></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>GNU</strong><br>
        <div class="sidebar-description">A Unix-linux Operating System</div>
      </div>
    </div>
  </li>
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
    <a href="http://www.kernel.org" title="To Linux Kernel">
    <img class="img-thumbnail img-responsive" src="/images/system/linux.png"  alt="LINUX" /></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>Linux Kernel</strong><br>
        <div class="sidebar-description">Maintained by Linux Kernel Organization</div>
      </div>
    </div>
  </li>
  <li style="margin-left:0em" class="list-group-item">
    <div class="row">
      <div class="col-xs-4">
    <a href="http://arduino.cc" title="To Arduino">
    <img class="img-thumbnail img-responsive" src="/images/system/arduino.png"  alt="ARDUINO" /></a>
      </div>
      <div class="col-xs-8 center-block" style="padding:0px;">
        <strong>Arduino</strong><br>
        <div class="sidebar-description">Open-source Electronic Prototyping Platform</div>
      </div>
    </div>
  </li>
</ul>

<h2>Search</h2>
<div class="sidebar-module">
  <form class="search" method="GET" action="https://www.google.com.hk/search">
    <input type="text" name="q" class="search-query" placeholder=" Search on Google">
    <input type="hidden" name="ie" value="utf-8">
    <input type="submit" name="sa" value="Search" />
  </form><br>
  <input type="text" class="search-field" placeholder=" Search This Site">
  <div class="search-results"></div>
</div>



    </div>
  </div>
<hr><p class="text-center">This Site was built by Jin Yang, generated with Jekyll, and hosted on GitHub Pages<br/> &copy;2013-2019 &ndash; Jin Yang</p><div class="footer-logo"></div>

</div>
</body>
</html>
