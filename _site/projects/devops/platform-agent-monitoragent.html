<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="baidu-site-verification" content="B786jeR0MV" />
  <meta name="msvalidate.01" content="29F791E7F785800340E37AD7C714D2A7" />
  <meta name="google-site-verification" content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0" />
  <title>MonitorAgent 实现|JinYang's Blog</title>
  <meta name="keywords" content="">
  <meta name="description" content="">

  <script src="https://cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>
  <script type="text/javascript">
  !window.jQuery && document.write('<script src="/static/js/jquery.min.js"><\/script>');
  </script>
  <script src="https://cdn.bootcss.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
  <script type="text/javascript">
  !$('body').popover && document.write('<script src="/static/js/bootstrap.min.js"><\/script>');
  </script>
  <script type="text/javascript" src="/static/js/main.js"></script>
  <!-- <link rel="stylesheet prefetch" href="http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css"> -->
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/bootstrap.min.css">
  <!-- <link href="http://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/font-awesome.min.css">
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/pygments.css">
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/screen.css">
  <style type="text/css">
  
    .post-container > p {text-indent: 2em;}
  
  </style>
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-124556620-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-124556620-1');
</script>

</head>

<body>
<nav class="navbar navbar-default navbar-inverse navbar-fixed-top navbar-wrapper">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span>
      </button><a class="navbar-brand" href="/">Jin-Yang</a>
    </div>
    <div id="navbar" class="collapse navbar-collapse">
      <ul class="nav navbar-nav">
        <li  ><a href="/"> Home </a></li>
        <li  ><a href="/archives.html"> Archive </a></li>
        <li  ><a href="/categories.html"> Categories </a></li>
        <li  ><a href="/projects.html"> Projects </a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"> Others <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li class="dropdown-header">常用网站</li>
            <li role="separator" class="divider"></li>
            <li><a href="https://www.rtems.org/">www.rtems.org</a></li>
            <li><a href="http://www.gnu.org/">www.gnu.org</a></li>
            <li><a href="https://www.kernel.org/">www.kernel.org</a></li>
            <li><a href="https://www.arduino.cc/">www.arduino.cc</a></li>
          </ul>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li  ><a href="/about.html"> About </a></li>
      </ul>
    </div><!--/.nav-collapse -->
  </div>
</nav>

<div id="myCarousel" class="carousel slide" data-ride="carousel">
  <!-- Indicators -->
  <ol class="carousel-indicators">
    <li data-target="#myCarousel" data-slide-to="0" class="active"></li>
    <li data-target="#myCarousel" data-slide-to="1"></li>
    <li data-target="#myCarousel" data-slide-to="2"></li>
    <li data-target="#myCarousel" data-slide-to="3"></li>
    <li data-target="#myCarousel" data-slide-to="4"></li>
  </ol>
  <div class="carousel-inner" role="listbox">
    <div class="item active">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>KISS</h1>
          <h2>Keep It Simple and Stupid.</h2>
          <!--<a class="btn btn-lg btn-primary" href="#" role="button">Sign up today</a>-->
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Seize The Day</h1><h1>And Get Busy Living</h1>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Stay hungry</h1><h1>Stay foolish</h1>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
	  <h2>Ever tried, ever failed</h2><h2>No matter, try again</h2><h2>Fail again, fail better</h2>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Nothing is true</h1><h1>Every is permitted</h1>
        </div>
      </div>
    </div>
  </div>
  <a class="left carousel-control" href="#myCarousel" role="button" data-slide="prev">
    <span class="glyphicon glyphicon-chevron-left"></span>
    <span class="sr-only">Previous</span>
  </a>
  <a class="right carousel-control" href="#myCarousel" role="button" data-slide="next">
    <span class="glyphicon glyphicon-chevron-right"></span>
    <span class="sr-only">Next</span>
  </a>
</div><!-- /.carousel -->

<div class="container">
  <div class="row">
    <div class="col-lg-12 blog-main" style="min-width: 500px">
      <div class="post-container">
        <div class="blog-header">
          <h1>MonitorAgent 实现</h1>
        </div>
        <hr>
        <p>负责周期性的采集数据，并将数据 PUSH 到服务器。</p>

<!--
为了简单起见，队列没有采用超时机制，简单来说，也就是读写线程采用协作型。
对于读线程，不会设置超时时间，完全由采集线程控制，不过如果采集超时，会对读线程进行惩罚，简单来说就是增加采集的时间间隔。
对于写线程，每次发送时都会直接从队列中摘除，如果有多个写插件，那么只要有一个插件写成功那么就认为发送成功，失败时则会直接丢弃，不会维护队列进行重试。
  0. 每次接收到一个采集指标时，都会触发写操作，而且会通过单个线程写所有写插件。
  1. 每个写插件需要维护自己的队列进行重试，而且可以在线程中阻塞。
  2. 当所有的线程都阻塞时，那么就没有线程处理写请求了，此时就会阻塞到缓冲队列中。
  3. 要其每个写插件是可重入的。
-->

<h2 id="命令">命令</h2>

<h3 id="常驻进程">常驻进程</h3>

<p>也就是 <code>monitoragent</code> ，支持的详细参数可以直接通过 <code>monitoragent -h</code> 命令查看，常见操作如下。</p>

<h4 id="测试参数">测试参数</h4>

<p>一般用于启动之前检查参数或者插件是否正常。</p>

<h5 id="检查配置">检查配置</h5>

<p>通过 <code>-t</code> 参数检查配置文件是否合法，一般使用命令 <code>monitoragent -t -L test.log</code> ，也就是同时指定日志文件地址，防止日志被混淆。</p>

<p>如果成功则会显示 <code>Success</code> 否则 <code>Failed!!!</code> ，同时程序返回值分别为 <code>0</code> 和 <code>1</code> 。</p>

<p>假设要测试某个配置文件是否合法，可以通过如下命令测试。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ monitoragent -f -C monitoragent.server.conf -L server.log</code></pre></figure>

<h5 id="测试插件">测试插件</h5>

<p>也就是通过 <code>-T</code> 参数，同样一般使用命令 <code>monitoragent -T -L test.log</code> ，会将插件的一次采集打印出来，格式以及其中的示例如下。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">采集时间/周期 插件名(采集指标数/types.db指标数) 采集值1/类型1 采集值2/类型2 ... 采集值N/类型N

1511965574.110/10.000 load(3/3) 2.71/G 2.53/G 2.43/G</code></pre></figure>

<h3 id="控制命令">控制命令</h3>

<p>也就是 <code>monitorctl</code> ，用于查看当前进程的运行状态，如果要查看与服务端的详细通讯过程，可以在执行命令之前设置环境变量，也就是 <code>MONITOR_TRACE=1;</code> ，常见示例如下。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">----- 查看当前加载了那些插件
$ MONITOR_TRACE=1 ./daemon/monitorctl plugin list

----- 删除某个插件
$ MONITOR_TRACE=1 ./daemon/monitorctl plugin remove load

----- 停止某个插件的数据采集
$ MONITOR_TRACE=1 ./daemon/monitorctl plugin stop load

----- 启动某个插件的数据采集
$ MONITOR_TRACE=1 ./daemon/monitorctl plugin start load</code></pre></figure>

<h2 id="开发文档">开发文档</h2>

<h3 id="回调函数">回调函数</h3>

<p>动态库加载完之后，会调用指定的 <code>module_register()</code> 函数，一般来说在该函数中会注册各种的回调函数，也就是如下介绍的内容。</p>

<p>注意，不建议在 <code>module_register()</code> 中执行太复杂的逻辑，如果返回的是非零，那么会打印报错信息加载失败。</p>

<p>初始化的顺序为。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">+--------+    +------+    +------+
| config |---&gt;| init |---&gt;| read |
+--------+    +------+    +------+</code></pre></figure>

<h4 id="config">config</h4>

<p>config 失败只会打印告警信息，但是不会进行其它处理，包括了简单和复杂两种回调函数，如果同时存在两个，会优先调用复杂的回调函数。</p>

<h4 id="init">init</h4>

<p>init 在插件加载完之后会调用该函数，失败会将插件状态转换为 FAILED 或者直接卸载(宏定义)。</p>

<h4 id="read">read</h4>

<p>用于周期性的采集数据，包括了两种。</p>

<h4 id="write">write</h4>

<p>主要用于上报插件的实现。</p>

<h4 id="shutdown">shutdown</h4>

<p>在插件退出时进行相关的清理操作，如果返回非零值，则只打印报错信息。</p>

<h4 id="其它">其它</h4>

<p>注意，在 <code>init()</code> 和 <code>config()</code> 回调函数中只能设置参数，但是不能阻塞，例如不能调用 <code>sleep()</code>、<code>connect()</code> 之类的操作。</p>

<h3 id="配置文件">配置文件</h3>

<p>除了一些常见的配置项之外，还支持类似 <code>&lt;LoadPlugin&gt;</code> <code>&lt;Plugin&gt;</code> 之类的配置块，其中前者包含了一些通用的配置项，例如采集间隔、加载 flag 、是否自动启动等等；而后者为插件的配置项。</p>

<h3 id="pending-机制">Pending 机制</h3>

<p>为了支持一些异步的操作，例如重新加载、卸载、配置等等，提供了一种 Pending 请求的机制，包括了全局、插件两种纬度。</p>

<p>对应的特性包括了：</p>

<ol>
  <li>允许多个线程处理，需要进行并发控制。包括了主进程(通过ctl命令行、重试)、Read线程(因为PROCESS、RUNNING状态)、Write线程(主要是与上层交互的接口，例如目前的CloudAgent)</li>
  <li>尽量减少用户感知。允许有多次重复的操作，例如多次 reload 操作。</li>
</ol>

<!--
注意，只有在将 struct plugin 从全局结构体中添加、删除时才会对全局进行加锁；而插件的状态转移只对插件结构进行加锁。在添加 Pending 请求时需要先获取 G 再获取 P 。

新增请求步骤：A) 创建请求结构体；B) 获取全局锁；C) 获取局部锁；D) 添加到Pending列表。
处理请求部署：A) 处理步骤操作；B) 获取局部锁修改状态；C) 判断是否需要删除；D) 需要删除，则释放局部锁，获取全局锁重新检查是否释放。

只有当插件中没有 Pending 任务时才可以将插件从全局的树中删除。

相关的上下文信息需要确保在进程调用过程中是安全的，例如上下文中包含了对插件指针的引用，需要确保在调度过程中不会发生引用指针异常的情况。

注意，当前含有 write、notify、flush 接口的插件是不支持卸载的。
-->

<h4 id="测试用例">测试用例</h4>

<figure class="highlight"><pre><code class="language-text" data-lang="text">===&gt; COMMON
  * 启动时已经存在 PENDING 任务，直接返回 API_RC_PENDING。
  * 操作成功，并重复执行，返回 API_RC_DONE。

===&gt; START
  *

===&gt; STOP
  * 停止已经停止任务，直接返回 API_RC_DONE。

===&gt; UNLOAD
  * 不支持有write钩子的插件，直接返回 API_RC_UNSUPPORT。

===&gt; RELOAD
  * 不支持有write钩子的插件，直接返回 API_RC_UNSUPPORT。</code></pre></figure>

<h2 id="插件">插件</h2>

<h3 id="系统类">系统类</h3>

<h4 id="load">load</h4>

<p>采集系统的负载，有两种方式：A) 调用 <code>getloadavg()</code> 函数；B) 读取 <code>/proc/loadavg</code> 文件。默认上报的是系统总的负载再处以 CPU 核数，也就是所谓的平均负载，也可以通过 <code>ReportAbsolute true</code> 配置项上报绝对值。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">LoadPlugin load
&lt;Plugin load&gt;
        ReportRelative    false
&lt;/Plugin&gt;</code></pre></figure>

<h4 id="uptime">uptime</h4>

<p>系统的启动时间，单位是秒，有两种采集方式：A) 调用 <code>sysinfo()</code> 函数；B) 读取 <code>/proc/uptime</code> 文件。</p>

<h3 id="测试用例-1">测试用例</h3>

<h4 id="foobar">foobar</h4>

<p>提供一个简单的测试用例 foobar ，可以通过 <code>MONITOR_FOOBAR_SLEEP</code> 环境变量设置在 read 函数中的休眠时间，可以通过如下方式测试。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">MONITOR_FOOBAR_SLEEP=60 ./wrapper.sh ./daemon/monitoragent -f</code></pre></figure>

<h2 id="faq">FAQ</h2>

<h3 id="查看读函数">查看读函数</h3>

<p>查看读插件的调用情况，会显示读线程以及各个读函数的调用过程，需要打开 DEBUG 日志。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ tail -f nodus.log | grep -E &#39;([Rr]ead-function|[Rr]ead thread)&#39;</code></pre></figure>

<!--
https://www.circonus.com/

enum Type {
	COUNTER;
	GAUGE;
}
message Tag {
	required string Key;   // 长度限制为64
	required string Value; // 长度限制为1024
}
message Value {
	required Type type;
	required double value;
}
message Metric {
	optional string hostname;
	required string category;
	optional string indicator;
	optional string instance;

	required int timestamp;
	required int step;            // 包括了高精度ms和低精度s
	required repeated Value values;
	optional repeated Tag mtags;
}
message Data {
	optional string uuid;         // 可以优化为16Bytes的数值
	optional repeated Tag gtags;  // 全局的Tags列表
	repeated Metric metrics;
}

disk.usage  /
mysql.innodb.cache

保留tag关键字

host 主机名，需要按照通用的主机规范进行命名
service 服务名称，可以按照层级进行命名
component 组件或者微服务名称
device 设备类型，例如CPU、GPU、ARM、x86等
from/source 数据来源信息

所有的聚合、告警、展示都有与 tag 相关的内容。

以 DISK 为例，一个指标包含了如下内容：


namespace 命名空间，例如system

metric 指标名称包括三部分组成，通过 `.` 分隔，分别为：
* category 对应了一个插件，最大，例如disk、mysql；
* indicator 指标名称，可以是一个插件的内部子类，例如usage、innodb；
* instance 一般是一个示例

实际上大部分数据只会有一个 tags ，所以在结构体中会默认有一个 tag ，其它的则通过链表进行添加。
-->

<ol>
  <li>插件管理
 1.1 生命周期管理，包括了</li>
  <li>任务管理</li>
</ol>

<p>针对多个插件的操作是可以并发执行的。</p>

<p>正在运行中的插件不会处理，而是添加到插件的 Pending 列表中。</p>

<p>start 启动采集任务
stop 停止采集任务，并执行清理操作但是不卸载</p>

<p>load 加载并根据配置文件判断是否自动运行
unload 卸载
reload 重新加载</p>

<p>INVALID 新建了对象，初始化并添加到了全局内存中。
LOADED 动态库已经加载成功</p>

<p>LAUNCH 已经加载并添加到了 heap 中，但是还没有</p>

<p>可能会在两个线程中调用</p>

<p>在加载时的流程：</p>

<ol>
  <li>在指定的目录下遍历所有的配置文件，并解析，如果有 LoadPlugin 指令则会去尝试加载。</li>
  <li>新建 plugin 内存对象，并添加到全局对象中，此时状态为 INVALID 。</li>
  <li>调用 plugin_do_load() 函数执行真正的加载，这里会调用 <code>module_register()</code>，成功之后为 LOADED 。</li>
  <li>插件加载完成之后会调用 config 函数，注意返回指非 0 只会打印告警信息，而不会进行其它处理。</li>
  <li>所有的插件加载完成之后，如果存在 init 函数则统一再调用 init 函数。</li>
  <li>
    <p>如果插件配置了自动启动，那么在加载完成之后会开始周期调用 read 函数。</p>
  </li>
  <li>插件管理。任务、插件先后顺序。</li>
  <li>自监控能力。脚本失败。</li>
  <li>错误信息统一。</li>
  <li>降龙。</li>
  <li>消息上报。提供多通道上报能力。</li>
  <li>调度状态统计，是否有延迟。</li>
  <li>消息通道做成通用的。</li>
</ol>

<p>int config_read(const char *plugin) 目前是cf_read()函数</p>

<p>读取指定目录下的配置文件，并尝试加载</p>

<p>plugin_do_load(struct plugin *plg, int flags) do_plugin_load()</p>

<p>真正加载动态库，执行步骤为：</p>

<ol>
  <li>扫描指定目录 (目录无权限访问) 找到对应的动态库，如果不存在则报错 ENOENT 。</li>
  <li>加载动态库 (非法动态库)，查找指定的 <code>module_register()</code> 函数 (无函数非法) 。</li>
  <li>执行 <code>module_register()</code> 函数，并检查其返回结果，如果失败则会直接关闭打开的动态库。</li>
</ol>

<p>TODO:</p>

<p>在调用 <code>module_register()</code> 函数时每次都会在全局变量中搜索，是否可以通过 ctx 来减少查找的次数？
明确 context 的真正用途，能否直接干掉。</p>

<p>struct request {
	struct request *next;
	int flags; // 标示是否正在处理
};</p>

<p>struct plugin {
	char name[64];
	void *handle; // 动态库的地址
	struct json *cfg; // 配置项
	struct context *ctx; // 上下文信息
	struct request *req; // 当前请求</p>

<pre><code>init
config
read
write
shutdown };
</code></pre>

<p>如果需要修改采集周期，那么每次都需要触发</p>

<p>start 启动采集任务
stop 停止采集任务，并执行清理操作但是不卸载</p>

<p>load 加载并根据配置文件判断是否自动运行
unload 卸载
reload 重新加载
config 修改配置
        在LAUNCH、PROCESS、RUNNING状态</p>

<p>Interface Description Language, IDL 接口描述语言</p>

<p>Python V2 VS. V3 版本对比
https://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html</p>

<p>初始化过程：</p>

<ol>
  <li>新建 plugin tree、初始化 context、新建 exec 任务树等内存结构，设置 PR_SET_CHILD_SUBREAPER；</li>
  <li>启动SQLite，主要是创建表、设置busy hook、设置同步模式；</li>
  <li>设置常见的信号处理函数，包括了 SIGCHLD、SIGPIPE(设置为ignore)；</li>
  <li>通过读取配置文件加载所有的动态库cf_read() (TODO: 文件解析统一)，主要是加载、然后在 module_register() 中注册回调函数；</li>
  <li>然后通过db启动所有的任务。</li>
</ol>

<p>在 Linux 内核中保存了一个通用的链表头文件 <a href="https://github.com/torvalds/linux/blob/master/include/linux/list.h">linux/list.h</a> ，</p>

<p>注意access()会对文件路径上的权限进行检查，但是不会判断是否有 root 中的 CAP_FOWNER 权限。
https://blog.csdn.net/gmq_syy/article/details/73793721</p>

<ol>
  <li>将解析配置文件和发送配置信息分开。</li>
  <li>启动时可以不需要对操作进行加锁。</li>
  <li>对于API的请求，真正处理插件请求的实际上只有一个线程，通过pending机制进行类似的加锁。</li>
</ol>

<p>COMMON:</p>
<ol>
  <li>每个插件只允许最大有20个Pending的任务。</li>
  <li>
    <p>转交给global处理时的方式。</p>
  </li>
  <li>配置文件不存在。则直接使用默认的配置(不自动启动，间隔为 10 秒)。DONE</li>
  <li>配置文件存在。DONE</li>
  <li>配置文件存在但是非法。不支持配置项只打印警告信息。DONE</li>
  <li>动态库不存在。添加到自动重试列表里面。DONE</li>
  <li>超过了Pending列表数之后应该直接返回失败。</li>
  <li>连续多次测试</li>
</ol>

<p>LOAD</p>
<ol>
  <li>已经加载。直接返回成功。DONE</li>
</ol>

<p>结束的事件一般有两种，可以进行重试的，以及致命错误：</p>

<ol>
  <li>致命错误。</li>
  <li>可以重试。</li>
</ol>

<p>在非主线程中，一次仅处理一个操作，如果有多于一个的则交由主进程进行处理。</p>

<p>启动</p>

<ol>
  <li>检查是否存在 read_func 指针。</li>
</ol>

<p>信号转换为同步的是否就是信号安全的了？</p>

<p>注意，模板和参数应该是分开的，这样可以检查例如系统监控是否全网绑定，但是允许阈值设置不同。在模板修改之后，同时可以将模板修改的内容向相关的责任人推送消息。
在修改、添加、绑定告警的时候，应该向相关的责任人发送消息通知，同时为了防止消息泛滥，允许责任人进行过滤。</p>

<p>插件名称支持分组，也就是说允许一个动态库中注册多个函数，此时的名称为 <code>mysql.innodb</code> ，</p>

<p>enum Type {
	COUNTER;
	GAUGE;
}
message Tag {
	required string Key;   // 长度限制为64
	required string Value; // 长度限制为1024
}
message Value {
	required Type type;
	required double value;
}
message Metric {
	optional string hostname;
	required string category;
	optional string indicator;
	optional string instance;</p>

<pre><code>required int timestamp;
required int step;            // 包括了高精度ms和低精度s
required repeated Value values;
optional repeated Tag mtags; } message Data {
optional string uuid;         // 可以优化为16Bytes的数值
optional repeated Tag gtags;  // 全局的Tags列表
repeated Metric metrics; }
</code></pre>

<p>disk.usage  /
mysql.innodb.cache</p>

<p>保留tag关键字</p>

<p>host 主机名，需要按照通用的主机规范进行命名
service 服务名称，可以按照层级进行命名
component 组件或者微服务名称
device 设备类型，例如CPU、GPU、ARM、x86等
from/source 数据来源信息</p>

<p>所有的聚合、告警、展示都有与 tag 相关的内容。</p>

<p>以 DISK 为例，一个指标包含了如下内容：</p>

<p>namespace 命名空间，例如system</p>

<p>metric 指标名称包括三部分组成，通过 <code>.</code> 分隔，分别为：</p>
<ul>
  <li>category 对应了一个插件，最大，例如disk、mysql；</li>
  <li>indicator 指标名称，可以是一个插件的内部子类，例如usage、innodb；</li>
  <li>instance 一般是一个示例</li>
</ul>

<p>实际上大部分数据只会有一个 tags ，所以在结构体中会默认有一个 tag ，其它的则通过链表进行添加。</p>

<ol>
  <li>插件管理
 1.1 生命周期管理，包括了</li>
  <li>任务管理</li>
</ol>

<h3 id="回调函数类型">回调函数类型</h3>

<p>插件加载完成之后会调用固定的函数 <code>module_register()</code> ，在该函数中会注册各种的回调函数，也就是如下介绍的内容。</p>

<p>注意，不建议在 <code>module_register()</code> 中执行太复杂的逻辑，如果返回的是非 0 ，那么会打印报错信息直接退出。TODO: 目前直接忽略，卸载插件。</p>

<p>init 和 config 回调函数中只能设置参数，但是不能阻塞，例如不能调用 sleep()、connect() 等操作。</p>

<p>init 在插件加载完之后会调用该函数，失败会将插件状态转换为 FAILED 或者直接卸载(宏定义)。 (TODO: init失败后卸载插件)
config 失败只会打印告警信息，但是不会进行其它处理，包括了简单和复杂两种回调。
read 用于周期性的采集数据。
write 主要用于上报插件的实现。
shutdown 在插件退出时进行相关的清理操作。</p>

<p>针对多个插件的操作是可以并发执行的。</p>

<p>正在运行中的插件不会处理，而是添加到插件的 Pending 列表中。</p>

<p>start 启动采集任务
stop 停止采集任务，并执行清理操作但是不卸载</p>

<p>load 加载并根据配置文件判断是否自动运行
unload 卸载
reload 重新加载</p>

<p>INVALID 新建了对象，初始化并添加到了全局内存中。
LOADED 动态库已经加载成功</p>

<p>LAUNCH 已经加载并添加到了 heap 中，但是还没有</p>

<p>可能会在两个线程中调用
plugin_reload()</p>

<p>API_DONE 已经处理完成
API_PENDING 已经有任务了，将添加到pending表中
API_CONT 交给另外的线程进行处理</p>

<h2 id="reload">reload</h2>
<ol>
  <li>插件不存在。</li>
</ol>

<p>./daemon/cloudagent_monitorctl plugin reload foobar</p>

<p>在加载时的流程：</p>

<ol>
  <li>在指定的目录下遍历所有的配置文件，并解析，如果有 LoadPlugin 指令则会去尝试加载。</li>
  <li>新建 plugin 内存对象，并添加到全局对象中，此时状态为 INVALID 。</li>
  <li>调用 plugin_do_load() 函数执行真正的加载，这里会调用 <code>module_register()</code>，成功之后为 LOADED 。</li>
  <li>插件加载完成之后会调用 config 函数，注意返回指非 0 只会打印告警信息，而不会进行其它处理。</li>
  <li>所有的插件加载完成之后，如果存在 init 函数则统一再调用 init 函数。</li>
  <li>如果插件配置了自动启动，那么在加载完成之后会开始周期调用 read 函数。</li>
</ol>

<p>实际上我们分了两类的接口：A) 对外提供的 API，一般是在启动完成之后使用，此时实际上会通过 pending 机制变相加锁；B) 在启动时明确不会出现冲突，对应了 do_XXX 之类的函数，此时只做具体的工作，不需要对全局进行加锁。</p>

<p>为了简化，开始只提供第一种的采集方式。</p>

<p>int config_read(const char *plugin, int flag) 目前是cf_read()函数</p>

<p>读取指定目录下的配置文件，并尝试加载</p>

<p>plugin_do_load(struct plugin *plg, int flags) do_plugin_load()</p>

<p>真正加载动态库，执行步骤为：</p>

<ol>
  <li>扫描指定目录 (目录无权限访问) 找到对应的动态库，如果不存在则报错 ENOENT 。</li>
  <li>加载动态库 (非法动态库)，查找指定的 <code>module_register()</code> 函数 (无函数非法) 。</li>
  <li>执行 <code>module_register()</code> 函数，并检查其返回结果，如果失败则会直接关闭打开的动态库。</li>
</ol>

<p>TODO:</p>

<p>在调用 <code>module_register()</code> 函数时每次都会在全局变量中搜索，是否可以通过 ctx 来减少查找的次数？
明确 context 的真正用途，能否直接干掉。</p>

<p>struct request {
	struct request *next;
	int flags; // 标示是否正在处理
};</p>

<p>struct plugin {
	char name[64];
	void *handle; // 动态库的地址
	struct json *cfg; // 配置项
	struct context *ctx; // 上下文信息
	struct request *req; // 当前请求</p>

<pre><code>init
config
read
write
shutdown };
</code></pre>

<p>如果需要修改采集周期，那么每次都需要触发</p>

<p>+———+           +——–+              +——+             +——-+           +——–+           +———+           +———+
| INVALID |–[load]–&gt;| LOADED |–[init OK]–&gt;| IDLE |–[config]–&gt;| READY |–[heap]–&gt;| LAUNCH |–[wait]–&gt;| PROCESS |–[read]–&gt;| RUNNING |
+———+           +——–+              +——+             +——-+           +——–+           +———+           +———+
     |                                                                                      |                    |                      |
 [init FA]                                                                               <stop>               <stop>                 <stop>
     |                                                                                      |                    |                      |
     |                            +--------+                     +--------+                 |                    |                      |
     `---------------------------&gt;| FAILED |                     | STOPED |&lt;------------------------------------------------------------'
                                  +--------+                     +--------+</stop></stop></stop></p>

<p>全局的插件结构体中保留了相关的信息。</p>

<p>保留的列表包括了：</p>

<p>write
flush
notify
pending</p>

<p>为了防止由于不同的状态与命令发生冲突，例如多次修改配置(某个可能丢失)、多次重启请求，真正在判断处理的时候是在：</p>

<ol>
  <li>转换为 READY 时判断。</li>
  <li>在 LAUNCH PROCESS RUNNING 中等待。</li>
  <li>在 FAILED STOPED 中直接处理。</li>
</ol>

<p>原则：</p>

<ol>
  <li>插件的数据发送之后已经包含了所有信息，不再依赖原有插件的函数、数据等，也就意味着原有的插件可以随时被卸载。</li>
  <li>状态迁移过程中加锁的时间很短，而且不能失败。对于创建内存等操作一般都是提前申请并初始化完成。</li>
</ol>

<p>一个线程加锁释放后如何通知另外被阻塞的线程执行？
一个线程加锁释放后何时开始调度执行另外被阻塞的线程？</p>

<p>那个线程在添加 request 的时候的链表为空，那个线程进行处理。</p>

<p>转换的时候用科学计数法</p>

<p>每次新增任务</p>

<p>start 启动采集任务
	1. 获取全局的plugins_lock；
	2. 检查插件是否存在，不存在则添加全局pending；
	3. 是否有pending的请求，可能会是正在加载，有则添加到pending列表中；
	4. 是否支持read_func，否则直接退出；
	5. 获取read_lock锁，直接处理(处理速度很快);
	6. 释放全局的plugins_lock；
stop 停止采集任务，并执行清理操作但是不卸载
	1. 获取全局的plugins_lock；
	2. 检查插件是否存在，不存在则直接返回成功；
	3. 检查是否有pending任务，如果有则添加；
	4. 是否支持read_func，否则直接退出；
	5. 获取read_lock锁，直接处理(处理速度很快)；
	6. 释放全局的plugins_lock；</p>

<p>load 加载并根据配置文件判断是否自动运行
	1. 获取全局的plugins_lock；
	2. 检查插件是否存在，不存在则新建并添加到plugins_loaded树中；
	3. 是否有pending的请求，有则添加到pending列表中；
	4. 释放全局的plugins_lock；
	5. 开始解析配置文件并加载。参考注 &lt;1&gt;</p>

<p>unload 卸载
	1. 获取全局的plugins_lock；
	2. 检查插件是否存在，不存在则直接返回成功；
	3. 是否有pending的请求，有则添加到pending列表中；
	4. 释放全局的plugins_lock；
	5. «« 开始执行卸载
	6.</p>

<p>reload 重新加载
	1. 获取全局的plugins_lock；
	3. 是否有pending的请求，有则添加到pending列表中；
	4. 释放全局的plugins_lock；
	5. 开始执行卸载操作。</p>

<p>config 修改配置
	在LAUNCH、PROCESS、RUNNING状态</p>

<p>&lt;1&gt; 注意，因为已经添加了一个pending请求，也就是意味着该线程会一直持有该插件的执行权限。</p>

<p>目前只使用了一个全局锁，并使用pending做单线程调用的限制，</p>

<p>测试场景：</p>

<h3 id="reload-1">reload</h3>

<ol>
  <li>插件正在运行。
A) INVALID LOADED IDLE 状态，那么必然存在着一个 Pending 请求，此时直接添加到 Pending 的末尾。
B) READY LAUNCH PROCESS RUNNING STOPED FAILED 此时可能会存在 Pending 请求，有则直接添加到 Pending 的末尾。</li>
</ol>

<h3 id="stop">stop</h3>

<h3 id="其它-1">其它</h3>

<ol>
  <li>设置了一个很大的采集时间间隔(24小时)，然后新增多个插件，或者修改采集间隔。</li>
</ol>

<p>libev 优化</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">+---------+           +--------+              +------+             +-------+           +--------+           +---------+           +---------+
| INVALID |--[load]--&gt;| LOADED |--[init OK]--&gt;| IDLE |--[config]--&gt;| READY |--[heap]--&gt;| LAUNCH |--[wait]--&gt;| PROCESS |--[read]--&gt;| RUNNING |
+---------+           +--------+              +------+             +-------+           +--------+           +---------+           +---------+
     |                                                                                      |                    |                      |
 [init FA]                                                                               &lt;stop&gt;               &lt;stop&gt;                 &lt;stop&gt;
     |                                                                                      |                    |                      |
     |                                                                                      |                    `----------------------&#39;
     |                                                                                      |                                |
     |                                                                                      |                                V
     |                                                                                      |                            +--------+
     |                                                                                      |                            | REMOVE |
     |                                                                                      |                            +--------+
     |                                                                                      |                                           |
     |                                                                                      |                    |                      |
     |                                                                                      |                    |                      |
     |                                                                                      |                    |                      |
     |                                                                                      |                    |                      |
     |                                                                                      |                    |                      |
     |                            +--------+                     +--------+                 |                    |                      |
     `---------------------------&gt;| FAILED |                     | STOPED |&lt;------------------------------------------------------------&#39;
                                  +--------+                     +--------+</code></pre></figure>

<p>如果在多线程中调用 <code>dlopen()</code> 打开动态库，在通过 valgrind 测试时会有报错，目前来看应该是误报，暂时忽略。</p>

<!-- gcc -Wl,--no-as-needed -g -o stuff  main.c -ldl -lpthread -->

<!--
==23267== 21 bytes in 1 blocks are still reachable in loss record 1 of 5
==23267==    at 0x4C29C23: malloc (vg_replace_malloc.c:299)
==23267==    by 0x4019F39: strdup (in /usr/lib64/ld-2.17.so)
==23267==    by 0x4017183: _dl_load_cache_lookup (in /usr/lib64/ld-2.17.so)
==23267==    by 0x4008A69: _dl_map_object (in /usr/lib64/ld-2.17.so)
==23267==    by 0x40143E3: dl_open_worker (in /usr/lib64/ld-2.17.so)
==23267==    by 0x400F913: _dl_catch_error (in /usr/lib64/ld-2.17.so)
==23267==    by 0x4013CCA: _dl_open (in /usr/lib64/ld-2.17.so)
==23267==    by 0x5695081: do_dlopen (in /usr/lib64/libc-2.17.so)
==23267==    by 0x400F913: _dl_catch_error (in /usr/lib64/ld-2.17.so)
==23267==    by 0x5695141: __libc_dlopen_mode (in /usr/lib64/libc-2.17.so)
==23267==    by 0x5049E52: pthread_cancel_init (in /usr/lib64/libpthread-2.17.so)
==23267==    by 0x504A01B: _Unwind_ForcedUnwind (in /usr/lib64/libpthread-2.17.so)
==23267==
{
   Memcheck:Leak
   match-leak-kinds: reachable
   fun:malloc
   fun:strdup
   fun:_dl_load_cache_lookup
   fun:_dl_map_object
   fun:dl_open_worker
   fun:_dl_catch_error
   fun:_dl_open
   fun:do_dlopen
   fun:_dl_catch_error
   fun:__libc_dlopen_mode
   fun:pthread_cancel_init
   fun:_Unwind_ForcedUnwind
}
==23267== 21 bytes in 1 blocks are still reachable in loss record 2 of 5
==23267==    at 0x4C29C23: malloc (vg_replace_malloc.c:299)
==23267==    by 0x400B603: _dl_new_object (in /usr/lib64/ld-2.17.so)
==23267==    by 0x40062F3: _dl_map_object_from_fd (in /usr/lib64/ld-2.17.so)
==23267==    by 0x40087B7: _dl_map_object (in /usr/lib64/ld-2.17.so)
==23267==    by 0x40143E3: dl_open_worker (in /usr/lib64/ld-2.17.so)
==23267==    by 0x400F913: _dl_catch_error (in /usr/lib64/ld-2.17.so)
==23267==    by 0x4013CCA: _dl_open (in /usr/lib64/ld-2.17.so)
==23267==    by 0x5695081: do_dlopen (in /usr/lib64/libc-2.17.so)
==23267==    by 0x400F913: _dl_catch_error (in /usr/lib64/ld-2.17.so)
==23267==    by 0x5695141: __libc_dlopen_mode (in /usr/lib64/libc-2.17.so)
==23267==    by 0x5049E52: pthread_cancel_init (in /usr/lib64/libpthread-2.17.so)
==23267==    by 0x504A01B: _Unwind_ForcedUnwind (in /usr/lib64/libpthread-2.17.so)
==23267==
{
   Memcheck:Leak
   match-leak-kinds: reachable
   fun:malloc
   fun:_dl_new_object
   fun:_dl_map_object_from_fd
   fun:_dl_map_object
   fun:dl_open_worker
   fun:_dl_catch_error
   fun:_dl_open
   fun:do_dlopen
   fun:_dl_catch_error
   fun:__libc_dlopen_mode
   fun:pthread_cancel_init
   fun:_Unwind_ForcedUnwind
}
==23267== 360 bytes in 1 blocks are still reachable in loss record 4 of 5
==23267==    at 0x4C2B9B5: calloc (vg_replace_malloc.c:711)
==23267==    by 0x40112AD: _dl_check_map_versions (in /usr/lib64/ld-2.17.so)
==23267==    by 0x4014720: dl_open_worker (in /usr/lib64/ld-2.17.so)
==23267==    by 0x400F913: _dl_catch_error (in /usr/lib64/ld-2.17.so)
==23267==    by 0x4013CCA: _dl_open (in /usr/lib64/ld-2.17.so)
==23267==    by 0x5695081: do_dlopen (in /usr/lib64/libc-2.17.so)
==23267==    by 0x400F913: _dl_catch_error (in /usr/lib64/ld-2.17.so)
==23267==    by 0x5695141: __libc_dlopen_mode (in /usr/lib64/libc-2.17.so)
==23267==    by 0x5049E52: pthread_cancel_init (in /usr/lib64/libpthread-2.17.so)
==23267==    by 0x504A01B: _Unwind_ForcedUnwind (in /usr/lib64/libpthread-2.17.so)
==23267==    by 0x5048331: __pthread_unwind (in /usr/lib64/libpthread-2.17.so)
==23267==    by 0x5042E76: pthread_exit (in /usr/lib64/libpthread-2.17.so)
==23267==
{
   Memcheck:Leak
   match-leak-kinds: reachable
   fun:calloc
   fun:_dl_check_map_versions
   fun:dl_open_worker
   fun:_dl_catch_error
   fun:_dl_open
   fun:do_dlopen
   fun:_dl_catch_error
   fun:__libc_dlopen_mode
   fun:pthread_cancel_init
   fun:_Unwind_ForcedUnwind
   fun:__pthread_unwind
   fun:pthread_exit
}

###################################
## Histogram
###################################

最简单的是指定上下限，然后进行统计。

Brubeck 实际上没有使用直方图，而是将所有的数据保存下来，当需要进行采样时会进行快排，在采样时才会真正的执行计算。

Statsite 中同样固定长度，但是对于百分位数的计算，可以在丢失一部分精度的前提下使用 Cormode-Muthukrishnan Algorithm 算法。

目前实现的方式是，固定整体的 `bins` 数量 (1000) ，如果超过范围大小，那么直接调整 `bin_width` 的宽度以适应新的范围，因为需要将原有的统计信息重新添加到分组中，有一定的计算量，应该尽量避免。

注意，使用前最好通过 `bin_width` 明确好当前直方图支持的范围，如果当超过支持范围后，当执行 `bin_width` 的指数扩展时，可能会丢失原有的精度。

High Dynamic Range (HDR) Histogram
http://hdrhistogram.github.io/HdrHistogram/
https://github.com/sorenmacbeth/streaming-papers
https://github.com/powturbo/TurboHist

-->


        <hr>
      </div>
    </div>
  </div>
  <hr><p class="text-center">This Site was built by Jin Yang, generated with Jekyll, and hosted on GitHub Pages<br/> &copy;2013-2019 &ndash; Jin Yang</p><div class="footer-logo"></div>

</div>
</body>
</html>
