<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="baidu-site-verification" content="B786jeR0MV" />
  <meta name="msvalidate.01" content="29F791E7F785800340E37AD7C714D2A7" />
  <meta name="google-site-verification" content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0" />
  <title>BootAgent 实现|JinYang's Blog</title>
  <meta name="keywords" content="">
  <meta name="description" content="">

  <script src="https://cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>
  <script type="text/javascript">
  !window.jQuery && document.write('<script src="/static/js/jquery.min.js"><\/script>');
  </script>
  <script src="https://cdn.bootcss.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
  <script type="text/javascript">
  !$('body').popover && document.write('<script src="/static/js/bootstrap.min.js"><\/script>');
  </script>
  <script type="text/javascript" src="/static/js/main.js"></script>
  <!-- <link rel="stylesheet prefetch" href="http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css"> -->
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/bootstrap.min.css">
  <!-- <link href="http://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/font-awesome.min.css">
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/pygments.css">
  <link type="text/css" rel="stylesheet prefetch" href="/static/css/screen.css">
  <style type="text/css">
  
    .post-container > p {text-indent: 2em;}
  
  </style>
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-124556620-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-124556620-1');
</script>

</head>

<body>
<nav class="navbar navbar-default navbar-inverse navbar-fixed-top navbar-wrapper">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span>
      </button><a class="navbar-brand" href="/">Jin-Yang</a>
    </div>
    <div id="navbar" class="collapse navbar-collapse">
      <ul class="nav navbar-nav">
        <li  ><a href="/"> Home </a></li>
        <li  ><a href="/archives.html"> Archive </a></li>
        <li  ><a href="/categories.html"> Categories </a></li>
        <li  ><a href="/projects.html"> Projects </a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"> Others <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li class="dropdown-header">常用网站</li>
            <li role="separator" class="divider"></li>
            <li><a href="https://www.rtems.org/">www.rtems.org</a></li>
            <li><a href="http://www.gnu.org/">www.gnu.org</a></li>
            <li><a href="https://www.kernel.org/">www.kernel.org</a></li>
            <li><a href="https://www.arduino.cc/">www.arduino.cc</a></li>
          </ul>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li  ><a href="/about.html"> About </a></li>
      </ul>
    </div><!--/.nav-collapse -->
  </div>
</nav>

<div id="myCarousel" class="carousel slide" data-ride="carousel">
  <!-- Indicators -->
  <ol class="carousel-indicators">
    <li data-target="#myCarousel" data-slide-to="0" class="active"></li>
    <li data-target="#myCarousel" data-slide-to="1"></li>
    <li data-target="#myCarousel" data-slide-to="2"></li>
    <li data-target="#myCarousel" data-slide-to="3"></li>
    <li data-target="#myCarousel" data-slide-to="4"></li>
  </ol>
  <div class="carousel-inner" role="listbox">
    <div class="item active">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>KISS</h1>
          <h2>Keep It Simple and Stupid.</h2>
          <!--<a class="btn btn-lg btn-primary" href="#" role="button">Sign up today</a>-->
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Seize The Day</h1><h1>And Get Busy Living</h1>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Stay hungry</h1><h1>Stay foolish</h1>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
	  <h2>Ever tried, ever failed</h2><h2>No matter, try again</h2><h2>Fail again, fail better</h2>
        </div>
      </div>
    </div>
    <div class="item">
      <img src="data:image/gif;base64,R0lGODlhAQABAIAAAGZmZgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" alt="Second slide">
      <div class="container">
        <div class="carousel-caption">
          <h1>Nothing is true</h1><h1>Every is permitted</h1>
        </div>
      </div>
    </div>
  </div>
  <a class="left carousel-control" href="#myCarousel" role="button" data-slide="prev">
    <span class="glyphicon glyphicon-chevron-left"></span>
    <span class="sr-only">Previous</span>
  </a>
  <a class="right carousel-control" href="#myCarousel" role="button" data-slide="next">
    <span class="glyphicon glyphicon-chevron-right"></span>
    <span class="sr-only">Next</span>
  </a>
</div><!-- /.carousel -->

<div class="container">
  <div class="row">
    <div class="col-lg-12 blog-main" style="min-width: 500px">
      <div class="post-container">
        <div class="blog-header">
          <h1>BootAgent 实现</h1>
        </div>
        <hr>
        <p>当管理的机器达到上万的数量级时，即使 Agent 的部署成功率能达到 99% 那也会导致有几百台的机器离线，如果 Agent 频繁变更可能会导致离线机器更多。</p>

<p>BootAgent 就是为了管理各个 Agent ，同时保证机制简单、功能稳定。</p>

<h2 id="简介">简介</h2>

<p>用来管理上述列表中最基本的 Agent，提供基本的功能。通过最简单的方式与服务端进行通讯，也就是利用 <code>HTTP/1.1</code> 短链接与服务端通讯，只提供简单的 PUSH 机制，由 BootAgent 主动发起。</p>

<p>简单来说，尽量保证 BootAgent 功能的简单稳定，通过尽量少的资源实现其功能，这也同时意味着，很多的功能无法保证其时效性。</p>

<p>单个二进制文件即可运行，配置使用命令行参数，无需配置文件。当然安装包会包含了很多辅助程序，可以用来调测等。</p>

<h3 id="限制">限制</h3>

<p>如上所述，在实现时尽量做到简化，所以必然会带来很多的限制，简单列举如下：</p>

<ol>
  <li>与服务端通讯的发送、接收缓存默认是 64K 大小，通过 <code>CLI_SNDBUF_SIZE</code> <code>CLI_RCVBUF_SIZE</code> 设置。</li>
  <li>客户端会周期将状态上报到服务端，默认 10min (可配 3min~60min )，通过 <code>PROJECT_CLIENT_INTERVAL</code> 设置。</li>
  <li>如果在一个周期内数据上报失败，那么会减少到 3min (可配 1min~60min) 重试上报，可通过 <code>PROJECT_RETRY_DELAY</code> 设置。</li>
</ol>

<p>注意，客户端上报周期并非严格设置，可能会在连接服务端失败时导致延迟。</p>

<h3 id="实现功能">实现功能</h3>

<p>其中主要功能点包括了。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">client.c    作为客户端与服务端进行通讯
process.c   提供异步进程的实现</code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">1. 子进程管理。
   1.1 任务接口，包括了子Agent的安装、卸载、启动、停止。
   1.2 状态管理。
       自动拉起，可以配置是否在启动时拉起进程。
       状态检查、资源限制。

1. 任务管理。
   1.1 修改配置。

3. 事件上报机制。
   3.1 子进程异常。

4. 状态信息上报。与BootAgent相关的状态信息。
   4.1 任务信息。接收到的任务数、执行成功数、执行失败数、忽略执行数(任务已经存在)。</code></pre></figure>

<p>上述的子进程管理，支持基于 tag 的批量升级，同时允许按照比例升级部分 (用于灰度验证) 。</p>

<p>如果任务执行失败，只能等待下次 BootAgent 上报数据时处理。</p>

<h2 id="1-子进程管理">1. 子进程管理</h2>

<p>默认会在配置目录下保存相关的配置，配置文件的后缀需要确保是 <code>*.json</code>，默认配置目录可以通过 <code>BootAgent -h</code> 查看。在管理进程时，会将配置的名称作为唯一标示，如果有重复则会忽略后面的配置。</p>

<p>另外，配置文件的名称需要与文件中 <code>name</code> 字段的名称保持一致。</p>

<p>其中的配置文件示例如下，文件名为 <code>BasicAgent.json</code> ，文件最大为 16K(<code>PRG_FILE_MAXSIZE</code>)。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">{
        &quot;name&quot;: &quot;BasicAgent&quot;,                          # 必选，子Agent的名称
        &quot;version&quot;: &quot;1.2.3&quot;,                            # 必选，子Agent的版本号
        &quot;exec&quot;: &quot;/bin/bash /usr/bin/gearman&quot;,          # 必选，注意，命令行必须是绝对路径，用来匹配进程，最长为255

        &quot;type&quot;: &quot;simple&quot;,                              # 可选，以不同的方式启动 (默认是simple)
                                                       #       simple 以fork+exec方式运行，作为子进程
                                                       #       fork 子进程会fork子进程，也就是常驻进程

	&quot;single&quot;: true,                                # 可选，在启动前是否允许有多个进程存在 (默认是true)
                                                       #       true 每次启动检查进程是否已经启动
                                                       #       false 启动时直接拉起，如果需要单实例则由子进程自己控制

        &quot;pidfile&quot;: &quot;/var/run/cargo/gearman.pid&quot;,       # 对于fork必选，每行一条记录，不过只会检查第一行
        &quot;user&quot;: &quot;root&quot;,                                # 可选，默认是root
        &quot;group&quot;: &quot;root&quot;,

        &quot;envs&quot;: {                                      # 可选
                &quot;PATH&quot;: &quot;/usr/bin:/usr/local/bin&quot;,
                &quot;LANG&quot;: &quot;en_US.UTF-8&quot;
        },

        &quot;cgroup&quot;: {                                    # 可选，会通过cgroup进行资源限制
                &quot;CPU&quot;: 20,                             # CPU资源限制，单位是%
                &quot;MEM&quot;: 3000                            # 内存限制，单位是KB
        },

	&quot;limits&quot;: {                                    # 可选，BA会周期性的检查，超过资源限制后kill进程
		&quot;interval&quot;:60,                         # 检查间隔
		&quot;CPU&quot;:30,                              # CPU使用率，单位%
		&quot;MEM&quot;:102400,                          # RSS内存，单位KB
		&quot;FDS&quot;:1000                             # 文件描述符
	},

	&quot;check&quot;: {                                     # 可选，健康检查，超时时间是70%*interval
		&quot;interval&quot;:60,                         # 检查间隔
		&quot;path&quot;:&quot;/usr/run/BootAgent.sock&quot;,      # 目前只支持Unix Domain Socket
		&quot;match&quot;:&quot;regex:success&quot;                # 对返回信息进行检查，可以使用正则(regex)或字符串(string)
	},

	&quot;heartbeat&quot;: {                                 # 可选，心跳检查
		&quot;interval&quot;:60,                         # 心跳间隔，默认是1分钟
		&quot;match&quot;:&quot;regex:success&quot;                # 对上报报文的&quot;message&quot;字段进行匹配
	},
        &quot;checks&quot;: 3,                                   # 可选，如上的检查超过这里的设置次数后认为异常

        &quot;autostart&quot;: true,                             # 可选，是否在安装或者启动BootAgent时自动拉起该进程
        &quot;stopit&quot;: false,                               # 可选，进程退出是否杀死进程，默认是false
        &quot;autorestart&quot;: &quot;yes&quot;,                          # 可选，失败之后的启动方式，默认或者非法是yes
                                                       #       no 不再重启，无论退出的状态是什么
                                                       #       yes 一直尝试重启，同样无论退出的状态是什么
                                                       #       unexpect 只有退出码不在exitcode中时才会重启
        &quot;retries&quot;: 100,                                # 可选，重试次数，包括了启动、异常退出等状态时的重试

        &quot;exitcodes&quot;: &quot;0,9&quot;,                            # 可选，认为正常的退出码，不会再重启，只支持正值
        &quot;restartsecs&quot;: 20,                             # 可选，失败之后启动前sleep时间
        &quot;startsecs&quot;: 20,                               # 可选，启动多久之后认为正常，其中fork默认为60
        &quot;checksecs&quot;: 20,                               # 可选，健康检查机制
        &quot;stopsecs&quot;: 20,                                # 可选，超过多久之后直接向进程发送SIGKILL

        &quot;stopasgroup&quot;: true,                           # 可选，在kill进程时以组方式
        &quot;stopsignal&quot;: &quot;SIGTERM&quot;                        # 可选，在退出时向进程发送的信号，默认为SIGTERM
                                                       #       支持信号TERM HUP INT QUIT KILL USR1 USR2
}</code></pre></figure>

<p>注意，在匹配时会检查 <code>/proc/&lt;PID&gt;/exe</code> 中的二进制文件路径，需要保证与配置文件 <code>exec</code> 中的第一个参数相同。</p>

<h3 id="处理流程">处理流程</h3>

<h4 id="启动">启动</h4>

<p>每次 BootAgent 启动时，会根据 <code>autostart</code> 确认是否启动子进程，如果 <code>mode</code> 是 <code>single</code> 那么会根据 <code>/proc/&lt;PID&gt;/exec</code> 检查进程是否已经启动，如果已经启动，则会更新状态。</p>

<h3 id="进程类型">进程类型</h3>

<p>进程分为了 <code>simple</code> 和 <code>fork</code> 两种方式，使用方式如下。</p>

<h4 id="simple">simple</h4>

<p>作为 BootAgent 的子进程存在，此时在父进程退出时，子进程同样会退出。</p>

<p>这也就意味着，如果子进程退出那么就认为进程异常。</p>

<h4 id="fork">fork</h4>

<p>BootAgent 在调用子 Agent 之后，子 Agent 会作为 Daemon 进程存在，所以启动流程会比较复杂。</p>

<ol>
  <li>调用子进程后，一般子进程会再次执行 fork ，也就是真正执行业务逻辑的进程，所以会忽略子进程退出；</li>
  <li>在 <code>startsecs</code> 之后检查并刷新进程信息，主要是 PID；</li>
</ol>

<p>注意，如果进程的启动时间超过了 <code>startsecs</code> 设置，那么会在该进程退出后再次刷新。</p>

<h3 id="常见场景">常见场景</h3>

<p>简单列举一些常见的使用场景。</p>

<h4 id="一直尝试拉起">一直尝试拉起</h4>

<p>直接忽略退出状态，一直尝试重新拉起，参数设置包括 <code>"autorestart": "yes"</code>、<code>"restartsecs": 20</code>，其中后者主要是为了防止重复拉起导致异常，例如由于 cgroup OOM 。</p>

<h4 id="注意事项">注意事项</h4>

<p>子进程需要处理好部分状态，其中部分场景列举如下：</p>

<h5 id="退出异常">退出异常</h5>

<p>如果 BootAgent 接收到了停止命令，并向子进程发送了退出信号，而子进程还没有退出；此时，如果 BootAgent 又收到启动命令，那么会立即再启动一个进程。</p>

<p>所以，子进程需要处理好该场景，例如可以只保留一个进程。同时，也就意味着需要注意 <code>startsecs</code> 参数的设置。</p>

<h2 id="2-健康检查">2. 健康检查</h2>

<p>用来检查子进程是否正常，总共有三种方式。</p>

<h3 id="资源检查">资源检查</h3>

<p>主要是检查子进程的 CPU、内存、句柄等信息。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">&quot;limits&quot;: {
	&quot;interval&quot;:60,
	&quot;CPU&quot;:30,
	&quot;MEM&quot;:102400,
	&quot;FDS&quot;:1000
}</code></pre></figure>

<h3 id="健康度">健康度</h3>

<p>通过配置的健康检查端口判断，目前只支持 Unix Domain Socket，使用简单的换行进行分割。</p>

<p>会发送 <code>health\r\n</code> 请求，返回的结果会读取到 <code>\r\n</code> 处为止，最大长度为 127 字节。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">&quot;check&quot;: {
	&quot;interval&quot;:60,
	&quot;path&quot;:&quot;/usr/run/BootAgent.sock&quot;,
	&quot;match&quot;:&quot;regex:success&quot;
}</code></pre></figure>

<h3 id="心跳">心跳</h3>

<p>由子 Agent 周期性的向 BootAgent 发送固定格式的心跳报文。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">&quot;heartbeat&quot;: {
	&quot;interval&quot;:60,
	&quot;match&quot;:&quot;regex:success&quot;
}</code></pre></figure>

<h2 id="3-任务管理">3. 任务管理</h2>

<p>BootAgent 不会持久化任务信息，因此实现的各种任务需要保证任务的可重入性，也就是可以重复执行多次不会带来逻辑上的问题。</p>

<p>另外，为了防止由于服务端的 BUG 引起任务多次重复执行，在 Agent 的内存中会保存一段时间的任务信息(<code>1小时 50个</code>)，当检查到有重复执行的任务时则直接忽略。</p>

<p>每次上报信息时会带上正在执行的任务信息，不过需要注意，如果报文非法(<code>id</code> 或者 <code>action</code> 不存在)、内存不足 那么不会返回相应的任务状态，此时就需要依赖上层重试。</p>

<h3 id="任务状态">任务状态</h3>

<p>任务的基本状态处理流程如下。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">+--------+
|  INIT  |
+--------+

INIT   新建任务对象之后的状态。
VALID  任务已经添加到任务列表。
START  已经开始处理任务。</code></pre></figure>

<h3 id="任务类型">任务类型</h3>

<p>包括了异步任务和同步任务，同步任务在下发解析时会立即开始执行(实现时一般为异步)，而异步任务则会串行执行，例如对于下载任务来说，为了防止带宽不可控。</p>

<p><strong>注意</strong> 任务必须确保 <code>id</code> <code>action</code> <code>name</code> <code>version</code> 字段存在，如果 <code>id</code> 和 <code>action</code> 不存在，则会直接忽略任务；其中 <code>name</code> 和 <code>version</code> 用来确定操作的对象 (如果是全局配置不需要)。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">----- 安装任务，异步，用于第一次安装 注意，如果已经安装则尝试升级
{
	&quot;id&quot;: &quot;ddc8a9b9-55bd-4ddd-b53d-47095ee19466&quot;,  # 必选，任务ID信息，由服务端指定，客户端上报执行结果时会带上
	&quot;action&quot;: &quot;install&quot;,                           # 必选，指定任务操作
	&quot;name&quot;: &quot;BasicAgent&quot;,                          # 必选，需要操作的子Agent名称
	&quot;version&quot;: &quot;0.1.0&quot;,                            # 必选，操作子Agent的版本号
	&quot;speed&quot;: 100,                                  # 可选，下载限速，默认是100，单位是KB/s
	&quot;url&quot;: &quot;ftp://server:port/BasicAgent/BasicAgent-0.1.0-0.x86_64.rpm&quot;,
	&quot;checksum&quot;: &quot;SHA256:4a34b8d7d3009bb9ef9475fbf33e7bbe4a1e8db003aefc578a241c2f51c2c2f2&quot;,

	&quot;parameter&quot;: {                                 # 进程相关的参数，详见&lt;子进程管理&gt;中的配置参数
		&quot;name&quot;: &quot;BasicAgent&quot;,                  # 必选，注意需要与上述名称保持相同
		&quot;version&quot;: &quot;0.1.0&quot;,                    # 必选，类似，与上述安装包保持相同

		&quot;envs&quot;: {
			&quot;PATH&quot;: &quot;/usr/bin;/usr/local/bin&quot;
		}
	}
}

----- 升级任务，异步
{
	&quot;id&quot;: &quot;ddc8a9b9-55bd-4ddd-b53d-47095ee19466&quot;,
	&quot;action&quot;: &quot;upgrade&quot;,
	&quot;name&quot;: &quot;BasicAgent&quot;,                         # 必选，需要操作的子Agent名称
	&quot;version&quot;: &quot;1.2.3&quot;,                           # 必选，及其版本号
	&quot;url&quot;: &quot;ftp://server:port/BasicAgent/BasicAgent-0.1.0-0.x86_64.rpm&quot;,
	&quot;checksum&quot;: &quot;SHA256:4a34b8d7d3009bb9ef9475fbf33e7bbe4a1e8db003aefc578a241c2f51c2c2f2&quot;,
}

----- 卸载任务，同步
{
	&quot;id&quot;: &quot;ddc8a9b9-55bd-4ddd-b53d-47095ee19466&quot;,
	&quot;action&quot;: &quot;uninstall&quot;,
	&quot;name&quot;: &quot;BasicAgent&quot;,                         # 必选，需要操作的子Agent名称
	&quot;version&quot;: &quot;1.2.3&quot;,                           # 必选，及其版本号
	&quot;option&quot;: &quot;force&quot;,                            # 可选，是否尝试强制卸载
}

----- 进程操作，同步
{
	&quot;id&quot;: &quot;ddc8a9b9-55bd-4ddd-b53d-47095ee19466&quot;,
	&quot;action&quot;: &quot;program&quot;,
	&quot;name&quot;: &quot;BasicAgent&quot;,                         # 必选，需要操作的子Agent名称
	&quot;version&quot;: &quot;1.2.3&quot;,                           # 必选，及其版本号
	&quot;operation&quot;: &quot;restart&quot;,                       # 必选，对子进程的操作，包括了start、restart、stop
}

----- 配置相关，同步
{
	&quot;id&quot;: &quot;ddc8a9b9-55bd-4ddd-b53d-47095ee19466&quot;,
	&quot;action&quot;: &quot;config&quot;,
	&quot;name&quot;: &quot;BasicAgent&quot;,                         # 可选，如果配置的是子Agent需要与版本一块添加
	&quot;version&quot;: &quot;1.2.3&quot;,                           # 可选，及其版本号
	&quot;svrlist&quot;: &quot;192.168.9.1:1234,&quot;,               # 全局配置，服务端列表，不会修改默认的列表
	&quot;step&quot;: 1200                                  # 全局配置，状态上报时间间隔，单位是秒，其范围为[60, 3600]
}</code></pre></figure>

<h3 id="3-事件上报">3. 事件上报</h3>

<p>简单来说就是将 Agent 中发生的关键事件上报，其中某个事件通过 <code>AgentSN</code> <code>TimeStamp</code> <code>LocalID</code> 来标识，表示在那台主机上何时发生了什么事件，其中 <code>LocalID</code> 在进程重启后会重新开始计数。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">{
	&quot;timestamp&quot;: 123456789,                         # 必选，事件发生的时间
	&quot;category&quot;: &quot;agent&quot;                             # 必选，分类信息
	&quot;subject&quot;: &quot;MiniAgent&quot;                          # 可选，事件发生的主体，标示那个进程异常
	&quot;extra&quot;: &quot;1.2.1-2.x86_64&quot;                       # 可选，标识主体的附加信息，例如进程的版本号等
	&quot;message&quot;: &quot;resource overflow, CPU(10%)&quot;        # 必选，详细日志信息，例如资源超过限制
}</code></pre></figure>

<p>包括了，BootAgent 检测到异常后发送的数据，以及服务端通过 BootAgent 上报的数据判断异常的事件：</p>

<ol>
  <li>服务端健康检查。BootAgent 离线、进程 CPU MEM 异常。</li>
  <li>子进程信息。例如升级、重启、异常、健康检查失败等。</li>
</ol>

<h3 id="4-状态信息上报">4. 状态信息上报</h3>

<p>与 BootAgent 相关的状态信息。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">A. 任务状态信息统计
    tasknum     Agent在内存中缓存的任务数
    taskrun     已经执行的任务数，单调递增
    taskfail    执行任务失败数，单调递增
    taskpass    任务已经存在忽略的任务数，单调递增</code></pre></figure>

<!--
### 其它

BootAgent 在启动时通过判断是否存在 `MetaFile` 来决定是否为第一次启动。
-->

<h2 id="cgroup-管理">cgroup 管理</h2>

<p>这里只针对 CPU、内存进行限制，简单来说，会新建一个管理所有 DEVOPS Agent 相关的分组，默认使用的是 <code>devops</code> ，也可以在启动的时候通过 <code>-C</code> 参数指定。</p>

<p>当使用了 cgroup 机制后，其它 Agent 会存放到所对应分组目录下，如果没有配置则会添加到 cgroup 的根目录下，也就是资源不做限制。</p>

<p>注意，此时各个子 Agent 指定的 CPU 使用率实际上是相对于总体而言，也就是说设置的是 <code>cpu.shares</code> 参数对应的值。</p>

<h3 id="分组">分组</h3>

<p>默认 BootAgent 会使用 systemd 配置的 cgroup 组，而其它的 DevOps 工具则使用一个统一的 cgroup 组，这样可以将两者分开。</p>

<p>可以在启动的时候通过 <code>-G</code> 参数指定，也就是将 BootAgent 同样添加到 DevOps 组中。</p>

<h3 id="实现">实现</h3>

<p>在实现时使用的是 libcgroup 库，启动顺序如下：</p>

<ol>
  <li>在 cgroup 的根目录下创建对应的分组，并将 BootAgent 添加到分组中，默认不会限制资源使用。</li>
</ol>

<h2 id="文件下载">文件下载</h2>

<p>简单的可以通过多个连接同时下载，只支持单进程。</p>

<h3 id="ftp-协议">FTP 协议</h3>

<p>支持 FTP 协议下载，关于详细的服务器配置方式可以查看 <a href="https://jin-yang.github.io/post/network-service-ftp.html">FTP 服务简介</a> 中的相关介绍，这里简单介绍其实现流程。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">1. 建立TCP链接，也就是命令管道。
2. USER + PASS 登陆。
3. TYPE I 使用二进制模式。
4. CWD dir 切换到目标目录下。

FTP 第一个链接
1. REST 1 测试是否支持分段下载。
2. SIZE filename.txt 获取文件的大小。

FTP 分组链接
1. 同建立链接过程。
2. PASV 建立被动链接。
3. REST offset 发送本链接的文件偏移。
4. RETR filename.txt 开始下载。
5. 命令链接等待处理完成。</code></pre></figure>

<h2 id="开发调试">开发调试</h2>

<h3 id="编译工程">编译工程</h3>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ cmake .. -DCMAKE_BUILD_TYPE=Debug -DBOOT_SERVER_ADDR=&quot;booter.cargo.com:8180,192.168.9.1:9090&quot;</code></pre></figure>

<h3 id="打包">打包</h3>

<p>在源码目录下可以直接通过如下命令进行打包，其中入参是版本号。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ ./contrib/package.sh BootAgent 1.2.1-1</code></pre></figure>

<h3 id="安装路径">安装路径</h3>

<figure class="highlight"><pre><code class="language-text" data-lang="text">----- 配置文件
/etc/cargo/BootAgent

----- 二进制程序
/usr/sbin/bootagent
/usr/sbin/bootctl

----- 基目录以及临时目录
/usr/local/cargo/BootAgent
/usr/local/cargo/BootAgent/tmp

----- 日志以及PID文件
/var/log/cargo/BootAgent.log
/var/run/cargo/BootAgent.pid
/var/run/cargo/BootAgent.sock</code></pre></figure>

<!--
----- 文档以及特定的配置文件等
/usr/share/cargo
/usr/share/cargo/nodus/types.db
/usr/share/doc/cargo/AUTHORS
/usr/share/doc/cargo/COPYING
/usr/share/doc/cargo/ChangeLog
/usr/share/doc/cargo/README
/usr/share/doc/cargo/TODO
/usr/share/man/man1/cargo.1.xz
/usr/share/man/man5/cargo-exec.5.xz
-->

<h3 id="命令行参数">命令行参数</h3>

<h4 id="bootagent">bootagent</h4>

<p>这个是主要的进程。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">-f
    前台运行，默认是后台运行。
-l &lt;level&gt;
    日志级别，可以
-L &lt;path&gt;
    日志保存路径。
-P &lt;path&gt;
    PIDFile 保存路径。
-S &lt;list&gt;
    服务器地址。
-C &lt;name&gt;
    cgroup 组名称。
-T
    用于测试当前的配置，而非真正运行，为了防止覆盖老日志，可以同时使用 -L 参数。</code></pre></figure>

<h4 id="bootctl">bootctl</h4>

<p>一般用来调试、检查状态等使用，可以通过 <code>BOOTAGENT_TRACE</code> 环境变量来查看 <code>bootctl</code> 与 <code>bootagent</code> 的命令交互过程。</p>

<h5 id="检查当前配置">检查当前配置</h5>

<h5 id="设置日志级别">设置日志级别</h5>

<figure class="highlight"><pre><code class="language-text" data-lang="text">export BOOTAGENT_TARCE=1; ./daemon/bootctl config setlog trace</code></pre></figure>

<h5 id="检查文件-sha256">检查文件 SHA256</h5>

<figure class="highlight"><pre><code class="language-text" data-lang="text">./daemon/bootctl sha256 &lt;YourFile&gt;</code></pre></figure>

<h3 id="systemd">Systemd</h3>

<p>在 CentOS 中也就是通过 systemd 管理进程，其中相关的 service 文件可以参考 <code>contrib/BootAgent.service</code> 中的配置内容。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">----- 更新配置
# cp BootAgent.service /usr/lib/systemd/system/BootAgent.service
# systemctl daemon-reload

----- 查看状态以及重启
# systemctl status BootAgent
# systemctl restart BootAgent

----- 配置后的cgroup会添加到如下目录
$ ls /sys/fs/cgroup/cpu/system.slice/BootAgent.service
$ ls /sys/fs/cgroup/memory/system.slice/BootAgent.service</code></pre></figure>

<h3 id="测试">测试</h3>

<p>通过 Flask 实现了一个 <code>contrib/testmocksvr.py</code> 用来模拟服务端，可以发送任务。</p>

<h2 id="rest-api-接口">REST-API 接口</h2>

<p>状态返回接口。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">{
	&quot;status&quot;: 2,                            # 必选，0表示正常，非0则表示异常
	&quot;message&quot;: &quot;common error type&quot;,         # 可选，通常是一类通用的错误类型
	&quot;cause&quot;: &quot;unmarshal body failed&quot;        # 可选，具体的错误信息
}</code></pre></figure>

<h3 id="启动注册接口">启动注册接口</h3>

<figure class="highlight"><pre><code class="language-text" data-lang="text">----- POST /api/v1/agent/register
{
	&quot;hostname&quot;: &quot;127.0.0.1&quot;,                            # 可以通过hostname命令查看
	&quot;ipaddr&quot;: &quot;127.0.0.1&quot;,                              # 在发送注册信息时与服务端建立连接的IP
	&quot;agentsn&quot;: &quot;bfdcc18c-b6b9-4725-9c47-37fd93dba5b6&quot;   # 本地生成的UUID用来唯一标识一台主机
}

----- 返回信息
{
	&quot;status&quot;: 0,
	&quot;agentsn&quot;: &quot;dcb886e9-04ed-41bb-9c12-4d2de12cd59b&quot;,  # 如果上层判断有冲突，则返回合法的AgentSN
	&quot;tags&quot;: &quot;svc=ecs,cmpt=DB&quot;,
}</code></pre></figure>

<p>当第一次启动时 (MetaFile不存在) 会向服务端注册，此时服务端可以根据配置返回一些配置信息，Agent 会尝试持久化到 MetaFile 文件中。</p>

<p>如果 Agent 因为某些原因失败，会尝试下次重试，此时上报的 AgentSN 可能会被修改，因此，只有当上报收到状态信息之后，才会被认为是合法的。</p>

<h3 id="状态上报接口">状态上报接口</h3>

<figure class="highlight"><pre><code class="language-text" data-lang="text">----- POST /api/v1/agent/status 上报当前Agent状态
{
	&quot;hostname&quot;: &quot;127.0.0.1&quot;,                                # 主机名
	&quot;agentsn&quot;: &quot;33c5b8b4-5a2c-43c5-ab90-96721451b4ec&quot;,      # AgentSN
	&quot;version&quot;: &quot;1.2.4-x86_64&quot;,                              # BootAgent的版本号
	&quot;feature&quot;: 7,                                           # 支持特性 0: cgroup
	&quot;uptime&quot;: 1234,                                         # 进程已经启动时间，单位秒
	&quot;timestamp&quot;: 1232,                                      # 上报时的时间戳
	&quot;step&quot;: 600,                                            # 上报的时间间隔，可以做修改，默认10min
	&quot;stats&quot;: {                                              # 当前BootAgent的状态统计信息
		&quot;task&quot;: [1, 2, 3, 4],                           # 任务执行状态信息，分别为tasknum taskrun taskfail taskpass
	},
	&quot;agents&quot;: [{                                            # 当前主机Agent信息
		&quot;name&quot;: &quot;BasicAgent&quot;,                           # Agent名称，需要保证唯一
		&quot;version&quot;: &quot;1.2.3&quot;,                             # Agent当前版本号
		&quot;status&quot;: &quot;stoped&quot;,                             # Agent的状态
		&quot;uptime&quot;: 123,                                  # 已经运行时间
	}],
	&quot;tasks&quot;: [{                                             # 任务执行状态
		&quot;id&quot;: &quot;ddc8a9b9-55bd-4ddd-b53d-47095ee19466&quot;,   # 任务ID
		&quot;errcode&quot;: 0,                                   # 统一错误码信息
		&quot;message&quot;: &quot;success&quot;                            # 返回信息
	}],
	&quot;events&quot;: [{                                            # 本地发生的事件信息
		&quot;timestamp&quot;: 123456789,                         # 发生的事件点
		&quot;category&quot;: &quot;agent&quot;                             # 分类信息
		&quot;message&quot;: &quot;resource overflow, CPU(10%)&quot;        # 详细日志信息，例如资源超过限制
	}],
}

----- 返回信息，可以包含请求
{
	&quot;status&quot;: 2,                                           # 返回状态，0表示正常，目前直接忽略返回值
	&quot;tasks&quot;: [{
		&quot;id&quot;: &quot;ddc8a9b9-55bd-4ddd-b53d-47095ee19466&quot;,  # 任务ID信息，由服务端指定，客户端上报执行结果时会带上
		&quot;action&quot;: &quot;install&quot;,                           # 指定任务操作，也开始是&quot;upgrade&quot; &quot;uninstall&quot; &quot;restart&quot; &quot;stop&quot;等
		&quot;name&quot;: &quot;BasicAgent&quot;,                          # 需要操作的子Agent名称
		&quot;url&quot;: &quot;ftp://server:port/BasicAgent/BasicAgent-0.1.0-0.x86_64.rpm&quot;,
		&quot;checksum&quot;: &quot;SHA256:4a34b8d7d3009bb9ef9475fbf33e7bbe4a1e8db003aefc578a241c2f51c2c2f2&quot;,
		&quot;envs&quot;: {                                      # 运行时的环境变量，一般在初次安装时配置，可以每次更新
			&quot;PATH&quot;: &quot;/usr/bin;/usr/local/bin&quot;
		},
		&quot;limits&quot;: {                                    # 资源使用限制
			&quot;CPU&quot;: &quot;10%&quot;,
			&quot;MEM&quot;: &quot;20M&quot;
		}
	}, {
		&quot;id&quot;: &quot;ddc8a9b9-55bd-4ddd-b53d-47095ee19466&quot;,
		&quot;action&quot;: &quot;config&quot;,                            # 修改BootAgent的相关配置
		&quot;svrlist&quot;: &quot;192.168.9.1:1234,&quot;,                # 服务端列表，不会修改默认的列表
		&quot;step&quot;: 1200,                                  # 状态上报时间间隔，其范围为[60, 3600]
	}]
}

备注:
    Agent状态
      * stoped 主动停止
      * running 正在运行
      * fatal 多次重试后失败
      * killed 资源超限等原因被强制杀死</code></pre></figure>

<h4 id="其它">其它</h4>

<h5 id="下载地址">下载地址</h5>

<p>目前支持两种方式 <code>FTP</code>、<code>FILE</code>，其中后者仅用来测试。</p>

<!--
BUG:
   1. 只使用测试时，会导致libev部分内存未释放。


1. 服务器地址配置
   1. 域名解析错误。

1. 进程管理
   1.1 DONE 配置文件中有多个 Name 相同的配置文件(最大为8K)。后续的配置文件解析时会报错，注意，读取时不保证顺序。
   1.2 执行用户相关(主进程需要以ROOT运行)。
       1.2.0 用户存在。以指定用户执行。
       1.2.1 用户不存在。直接报错退出。
       1.2.2 用户没有指定。默认通过root执行。
       1.2.3 属组非默认。指定属组执行。
   1.3 进程资源使用检查。
`
2. 通讯管道异常
   2.1 服务端未开启，链接失败。
       2.1.1 本地子网段(127.0.0.1~20)，路由正常，访问IP无监听服务，此时TCP交互时会返回RST，也就是立即返回 Connection refused.
       2.1.2 非本地子网(192.168.9.1~20)，此时会由于路由不通导致异常，发送SYN报文之后无响应，对于Linux来说2min报错 Connection timed out.
       2.1.3 网络不可达(227.0.0.1~20)，一般是由于路由不可达，此时报错 Network is unreachable.
   2.2 建立链接成功，数据发送，但是服务端无响应，客户端超时后重联。CLI_READ_TIMEOUT
   2.3 从服务端读取的数据格式异常，关闭重试。

   2.2 服务端返回的报文格式异常。

3. cgroup 资源隔离
   3.1 DONE 如果有 CPU MEM 不存在会修复两者所在目录。
   3.2 DONE 首先会解析任务的配置文件，启动时如果任务不存在则会删除。
   3.2 CPU MEM 资源限制。

4. 任务管理
   4.1 配置任务。

域名解析失败
-->

<h2 id="faq">FAQ</h2>

<h4 id="metafile">MetaFile</h4>

<p>用来记录 BootAgent 相关的配置信息，目前包括了 <code>AgentSN</code>、<code>Tags</code>、<code>ServerList</code> 三个，文件最大限制为 4K ，其配置信息示例如下。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># 该机器的AgentSN信息
AgentSN:7a5ae7ab-3878-4ecc-b367-810e5bc21a29
Tags:
ServerList:</code></pre></figure>

<p>默认的配置文件路径可以通过 <code>-h</code> 查看，如果 MetaFile 不存在则会向服务端发送注册信息，否则会正常启动。</p>

<h4 id="服务器地址">服务器地址</h4>

<p>总共有三种方式指定服务器的地址，可以在列表中指定多个，其格式为 <code>SVR1IP:PORT,SVR2IP</code> 。</p>

<ol>
  <li>编译时通过 <code>-DBOOT_SERVER_ADDR="booter.cargo.com,127.0.0.1:8090"</code> 参数指定，该地址会编译到可执行文件中，会一直存在。</li>
  <li>首次启动时通过 <code>-S</code> 指定(以后直接忽略)，该参数会持久化到 <code>metafile</code> 中，以后启动则忽略入参并直接使用 <code>metafile</code> 中的配置。</li>
  <li>可以通过服务端进行修改，最终同样会持久化到 <code>metafile</code> 中。</li>
</ol>

<p>所以，在实践中，应该尽量保证 <code>&lt;1&gt;</code> 中的服务器可用，可以是 HAProxy、LVS 之类的负载均衡地址，如果要修改只能通过升级完成。</p>

<p><strong>注意</strong>，如果有重复的地址，是不会去重的。</p>

<h4 id="agent-重启策略">Agent 重启策略</h4>

<p>每隔 60s 检查一次，如果进程异常退出在 3min 内不会重启，如果在 15min 内异常则标记一次异常事件，当连续异常超过 3 次后则认为程序异常，不再尝试重启。</p>

<h4 id="临时目录">临时目录</h4>

<p>主要有两个用途：A) 文件原子操作；B) 临时目录，例如下载文件等。</p>

<p>为了保证配置文件的完整性，会先将文件写入到临时目录下的临时文件，然后通过 rename 操作保证原子性。注意，在编译时，需要 <strong>保证配置文件的目录与临时目录在同一个挂载点</strong>，否则会报 <code>Invalid cross-device link</code> 的错误。</p>

<p>另外，为了防止临时目录中出现脏数据，会每隔 15min 扫描一次目录 (注意，不扫描子目录以及隐藏文件)，对于修改时间超过 24 小时的文件会自动删除。</p>

<h3 id="todo">TODO</h3>

<figure class="highlight"><pre><code class="language-text" data-lang="text">1. 安全通讯。
2. systemd notify 启动，自动健康检查。
3. completion 命令自动补齐。
4. Async DNS 目前的 DNS 使用同步方式。
5. 数据上报压缩。</code></pre></figure>

<!--
ps -eo ppid,pid,pgid,user,group,euser,egroup,cmd | grep gearman
usermod -a -G root monitor 将monitor用户添加到root组中

https://github.com/Jin-Yang/cgfy
https://github.com/chr15p/cgshares

Reap zombie processes using a SIGCHLD handler
http://www.microhowto.info/howto/reap_zombie_processes_using_a_sigchld_handler.html


https://github.com/mludvig/mini-printf
https://github.com/mpaland/printf
https://github.com/cjlano/tinyprintf
https://github.com/MarioViara/xprintfc
https://github.com/wkoszek/mini_printf
https://github.com/idning/safe_snprintf  这个不错


## 直方图

High Dynamic Range Histogram
http://hdrhistogram.org/
https://github.com/HdrHistogram/HdrHistogram_c

https://github.com/powturbo/TurboHist
https://github.com/astrofrog/fast-histogram

Vector Field Histogram 机器人中的算法
https://github.com/agarie/vector-field-histogram

https://github.com/retrage/sqlite-bench
https://github.com/Scottz0r/sqlite_performance_demo


down_new() 申请所需要的内存，并解析下载URL
  |-conn_parse() 解析下载地址信息，包括路径以及用户名密码
  |-conn_init() 根据不同的下载协议进行初始化
    |-ftp_connect() FTP建立链接登陆，并切换到Binary模式
    | |-tcp_connect() 通过TCP链接，注意，如果设置了io_timeout会采用异步链接 尝试建立链接
    |-ftp_cwd() 切换目录
    |
    |-http_connect() 建立TCP链接  HTTP connected with fd
  |-conn_info() 获取文件大小信息
    |-ftp_size() 获取文件大小
    |
    |-conn_setup() 对于HTTP下载模式，会包括了多次的重定向
    | |-conn_init() 如果还没有建立链接则初始化
    | |-http_get() 拼接请求头信息
    |-conn_exec() 发送HTTP请求获取返回头
      |-http_exec()
    |-conn_disconnect() 关闭请求

down_open()  打开状态文件，以及保存文件，如果不支持并发下载，则回归到单线程
  |-open() 打开*.st文件，查看是否有之前的保存信息
  |-downloader_divide() 拆分单个线程下载文件的范围
  |-open() 打开dl->filename文件下载

booter_start() 开始下载文件，会创建多个线程，入口函数为setup_thread()
  |-conn_set() 针对不同的线程重新解析URL
  |-setup_thread()
    |-conn_setup() 不同的线程建立不同的链接，多线程用于建立链接
      |-conn_init() 初始化链接
    |-conn_exec()

booter_do() 开始真正下载

简单的SO加密方法
https://bbs.pediy.com/thread-191649.htm
https://paper.seebug.org/89/







一个文件所属的分区可以通过 fstat() 函数查看，或者 `df <DIR>` 。


EAGAIN的处理方式
https://blog.csdn.net/tianmohust/article/details/8691644
-->


        <hr>
      </div>
    </div>
  </div>
  <hr><p class="text-center">This Site was built by Jin Yang, generated with Jekyll, and hosted on GitHub Pages<br/> &copy;2013-2019 &ndash; Jin Yang</p><div class="footer-logo"></div>

</div>
</body>
</html>
